  Sun Nov 21 2021 15:13                                                                                                Page 1


                                             ***************************************
                                             **      WDC 65C816 Macro Assembler   **
                                             **                                   **
                                             **     Version 3.49.1- Feb  6 2006    **
                                             ***************************************

     1                        
     2                        ; Enhanced BASIC to assemble under 6502 simulator, $ver 2.23
     3                        ; THIS WORK IS DERIVED FROM ehBASIC BY LEE DAVIDSON
     4                        ;
     5                        ; $E7E1 $E7CF $E7C6 $E7D3 $E7D1 $E7D5 $E7CF $E81E $E825
     6                        
     7                        ; 2.00	new revision numbers start here
     8                        ; 2.01	fixed LCASE$() and UCASE$()
     9                        ; 2.02	new get value routine done
    10                        ; 2.03	changed RND() to galoise method
    11                        ; 2.04	fixed SPC()
    12                        ; 2.05	new get value routine fixedf
    13                        ; 2.06	changed USR() code
    14                        ; 2.07	fixed STR$()
    15                        ; 2.08	changed INPUT and READ to remove need for $00 start to input buffer
    16                        ; 2.09	fixed RND()
    17                        ; 2.10	integrated missed changes from an earlier version
    18                        ; 2.20	added ELSE to IF .. THEN and fixed IF .. GOTO <statement> to cause error
    19                        ; 2.21	fixed IF .. THEN RETURN to not cause error
    20                        ; 2.22	fixed RND() breaking the get byte routine
    21                        ; 2.30  CONVERT TO 65816 ADDRESS SPACE
    22                        
    23                        
    24                        		CHIP	65816		; SET CHIP
    25                            	LONGA	OFF		; ASSUME EMULATION MODE
    26                            	LONGI	OFF		;
    27                            	PW	128
    28                            	PL 	60
    29                            	INCLIST ON
    30                        
    31                           	.ORG	0FF1000H
    32                        BASICORG:
    33 FF:1000: 4C 32 27     	JMP 	BASICBEGIN
    34                        ;____________________________________________________________________________________________
    35                        ;
    36                        ; MACROS
    37                        
    38                        	INCLUDE 'MACROS.ASM'
     1                        ;_________________________________________________________________________________________________
                    __
     2                        ;
     3                        ;	USEFUL 65186 MACROS
     4                        ;_________________________________________________________________________________________________
                    _
     5                        
     6                        
     7                        STYZP.X  .macro _op
     8                                 .DB $94
     9                                 .db <_op
    10                                 .endm
    11                        
  Sun Nov 21 2021 15:13                                                                                                Page 2


    12                        
    13                        StoreContext    .macro                ; Store Complete Context at the beginning of a Sub
    14                                PHX
    15                                phy
    16                                pha
    17                                php
    18                                .endm
    19                        
    20                        RestoreContext  .macro                ; Restore Complete Context at the end of a Sub
    21                                plp
    22                                pla
    23                                ply
    24                                plx
    25                                .endm
    26                        
    27                        Index16         .macro                ; Set 16bit Index Registers
    28                        		REP #$10 		; 16 bit Index registers
    29                        		LONGI ON
    30                                .endm
    31                        Index8          .macro                ; Set 8bit Index Registers
    32                        		SEP #$10 		; 8 bit Index registers
    33                        		LONGI OFF
    34                                .endm
    35                        
    36                        Accumulator16   .macro                ; Set 16bit Index Registers
    37                        		REP #$20 		; 16 bit Index registers
    38                        		LONGA ON
    39                                .endm
    40                        
    41                        Accumulator8    .macro                ; Set 8bit Index Registers
    42                        		SEP #$20 		; 8 bit Index registers
    43                        		LONGA OFF
    44                                .endm
    45                        
    46                        AccumulatorIndex16  .macro            ; Set 16bit Index Registers
    47                        		REP #$30 		; 16 bit Index registers
    48                        		LONGA ON
    49                                LONGI ON
    50                                .endm
    51                        
    52                        AccumulatorIndex8   .macro            ; Set 8bit Index Registers
    53                        		SEP #$30 		; 8 bit Index registers
    54                        		LONGA OFF
    55                                LONGI OFF
    56                                .endm
    57                        
    58                        
    59                        
    60                        cr      .macro                ; Restore Complete Context at the end of a Sub
    61                                SEP #$20 		; 8 bit accum
    62                        		LONGA OFF
    63                                .endm
    64                        
    65                        
    66                        
    67                        
    68                        LDAINDIRECTY .MACRO PARM1
  Sun Nov 21 2021 15:13                                                                                                Page 3


    69                            PHB
    70                        	PHX
    71                            LDX #$01
    72                            LDA <PARM1,X
    73                            CMP #$00
    74                            BNE *+6
    75                        	LDX #00
    76                        	PHX
    77                        	PLB
    78                            PLX
    79                        	LDA	(<PARM1),Y		;
    80                            STA <TMPFLG
    81                            PLB
    82                            LDA <TMPFLG
    83                            .endm
    84                        
    85                        STAINDIRECTY .MACRO PARM1
    86                            PHB
    87                        	PHX
    88                            PHA
    89                            LDX #$01
    90                            LDA <PARM1,X
    91                            CMP #$00
    92                            BNE *+6
    93                        	LDX #00
    94                        	PHX
    95                        	PLB
    96                            PLA
    97                            PLX
    98                        	STA	(<PARM1),Y		;
    99                        	PLB
   100                            STA <TMPFLG
   101                            .endm
   102                        
   103                        SETBANK .MACRO PARM1
   104                            PHX
   105                        	LDX #PARM1
   106                        	PHX
   107                        	PLB
   108                            PLX
   109                            .endm
   110                        
   111                        
   112                        FETCHINDIRECTY .MACRO PARM1
   113                            PHB
   114                        	PHA
   115                            PHX
   116                            LDX #$01
   117                            LDA <PARM1,X
   118                            CMP #$00
   119                            BNE *+6
   120                        	LDX #00
   121                        	PHX
   122                        	PLB
   123                            PLX
   124                            LDA	(<PARM1),Y		;
   125                            STA <TMPFLG
  Sun Nov 21 2021 15:13                                                                                                Page 4


   126                            PLA
   127                            PLB
   128                            .endm
   129                        
   130                        CMPINDIRECTY .MACRO PARM1
   131                            PHB
   132                            PHA
   133                            PHX
   134                            LDX #$01
   135                            LDA <PARM1,X
   136                            CMP #$00
   137                            BNE *+6
   138                        	LDX #00
   139                        	PHX
   140                        	PLB
   141                            PLX
   142                            LDA	(<PARM1),Y		;
   143                            STA <TMPFLG
   144                            PLA
   145                            PLB
   146                            CMP	<TMPFLG		    ;
   147                            .endm
   148                        
   149                        ADCINDIRECTY .MACRO PARM1
   150                            PHB
   151                            PHA
   152                            PHX
   153                            LDX #$01
   154                            LDA <PARM1,X
   155                            CMP #$00
   156                            BNE *+6
   157                        	LDX #00
   158                        	PHX
   159                        	PLB
   160                            PLX
   161                            LDA	(<PARM1),Y		;
   162                            STA <TMPFLG
   163                            PLA
   164                            PLB
   165                            CLC
   166                            ADC	<TMPFLG 		;
   167                            .endm
   168                        
   169                        LBEQ .MACRO PARM1
   170                             bne *+5
   171                             jmp PARM1
   172                            .endm
   173                        
   174                        LBNE .MACRO PARM1
   175                             beq *+5
   176                             jmp PARM1
   177                            .endm
   178                        
   179                        LBCC .MACRO PARM1
   180                             bcc *+4
   181                             bra *+5
   182                             jmp PARM1
  Sun Nov 21 2021 15:13                                                                                                Page 5


   183                            .endm
   184                        
   185                        LBCS .MACRO PARM1
   186                             bcs *+4
   187                             bra *+5
   188                             jmp PARM1
   189                            .endm
   190                        
   191                        ;
    39                        
    40                        ; ZERO PAGE DEFINITIONS
    41                        	INCLUDE 'ZEROPAGE.ASM'
     1                        ;____________________________________________________________________________________________
     2                        ;
     3                        ; ZERO PAGE DEFINITIONS
     4                        ;____________________________________________________________________________________________
     5                        
     6             00000000   LAB_WARM 	.EQU $00		; BASIC warm start entry point
     7             00000001   Wrmjpl 		.EQU LAB_WARM+1; BASIC warm start vector jump low byte
     8             00000002   Wrmjph 		.EQU LAB_WARM+2; BASIC warm start vector jump high byte
     9             00000004   TMPFLG      	.EQU $04
    10             00000006   VIDEOMODE	.EQU $06
    11             00000007   LOCALWORK	.EQU $07		; word (2 bytes)
    12             0000000A   Usrjmp		.EQU $0A		; USR function JMP address
    13             0000000B   Usrjpl		.EQU <Usrjmp+1	; USR function JMP vector low byte
    14             0000000C   Usrjph		.EQU <Usrjmp+2	; USR function JMP vector high byte
    15             0000000D   Nullct		.EQU $0D		; nulls output after each line
    16             0000000E   TPos		.EQU $0E		; BASIC terminal position byte
    17             0000000F   TWidth		.EQU $0F		; BASIC terminal width byte
    18             00000010   Iclim		.EQU $10		; input column limit
    19             00000011   Itempl		.EQU $11		; temporary integer low byte
    20             00000012   Itemph		.EQU <Itempl+1	; temporary integer high byte
    21                        
    22             00000011   nums_1		.EQU <Itempl	; number to bin/hex string convert MSB
    23             00000012   nums_2		.EQU <nums_1+1	; number to bin/hex string convert
    24             00000013   nums_3		.EQU <nums_1+2	; number to bin/hex string convert LSB
    25                        
    26             0000005B   Srchc		.EQU $5B		; search character
    27             0000005B   Temp3		.EQU <Srchc	; temp byte used in number routines
    28             0000005C   Scnquo		.EQU $5C		; scan-between-quotes flag
    29             0000005C   Asrch		.EQU <Scnquo	; alt search character
    30                        
    31             0000005B   XOAw_l		.EQU <Srchc	; eXclusive OR, OR and AND word low byte
    32             0000005C   XOAw_h		.EQU <Scnquo	; eXclusive OR, OR and AND word high byte
    33                        
    34             0000005D   Ibptr		.EQU $5D		; input buffer pointer
    35             0000005D   Dimcnt		.EQU <Ibptr	; # of dimensions
    36             0000005D   Tindx		.EQU <Ibptr	; token index
    37                        
    38             0000005E   Defdim		.EQU $5E		; default DIM flag
    39             0000005F   Dtypef		.EQU $5F		; data type flag, $FF=string, $00=numeric
    40             00000060   Oquote		.EQU $60		; open quote flag (b7) (Flag: DATA scan; LIST quote; mem
                    ory)
    41             00000060   Gclctd		.EQU $60		; garbage collected flag
    42             00000061   Sufnxf		.EQU $61		; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
    43             00000062   Imode		.EQU $62		; input mode flag, $00=INPUT, $80=READ
    44             00000063   Cflag		.EQU $63		; comparison evaluation flag
  Sun Nov 21 2021 15:13                                                                                                Page 6


    45                        
    46             00000064   TabSiz		.EQU $64		; TAB step size (was input flag)
    47                        
    48             00000065   next_s		.EQU $65		; next descriptor stack address
    49                        					; these two bytes form a word pointer to the item
    50                        					; currently on top of the descriptor stack
    51             00000066   last_sl		.EQU $66		; last descriptor stack address low byte
    52             00000067   last_sh		.EQU $67		; last descriptor stack address high byte (always $00)
    53                        
    54             00000068   des_sk		.EQU $68		; descriptor stack start address (temp strings)
    55                        
    56                        ;			= $70		; End of descriptor stack
    57                        
    58             00000071   ut1_pl		.EQU $71		; utility pointer 1 low byte
    59             00000072   ut1_ph		.EQU <ut1_pl+1	; utility pointer 1 high byte
    60             00000073   ut2_pl		.EQU $73		; utility pointer 2 low byte
    61             00000074   ut2_ph		.EQU <ut2_pl+1	; utility pointer 2 high byte
    62                        
    63             00000071   Temp_2		.EQU <ut1_pl	; temp byte for block move
    64                        
    65             00000075   FACt_1		.EQU $75		; FAC temp mantissa1
    66             00000076   FACt_2		.EQU <FACt_1+1	; FAC temp mantissa2
    67             00000077   FACt_3		.EQU <FACt_2+1	; FAC temp mantissa3
    68                        
    69             00000076   dims_l		.EQU <FACt_2	; array dimension size low byte
    70             00000077   dims_h		.EQU <FACt_3	; array dimension size high byte
    71                        
    72             00000078   TempB		.EQU $78		; temp page 0 byte
    73                        
    74             00000079   Smeml		.EQU $79		; start of mem low byte		(Start-of-Basic)
    75             0000007A   Smemh		.EQU <Smeml+1	; start of mem high byte	(Start-of-Basic)
    76             0000007B   Svarl		.EQU $7B		; start of vars low byte	(Start-of-Variables)
    77             0000007C   Svarh		.EQU <Svarl+1	; start of vars high byte	(Start-of-Variables)
    78             0000007D   Sarryl		.EQU $7D		; var mem end low byte		(Start-of-Arrays)
    79             0000007E   Sarryh		.EQU <Sarryl+1	; var mem end high byte		(Start-of-Arrays)
    80             0000007F   Earryl		.EQU $7F		; array mem end low byte	(End-of-Arrays)
    81             00000080   Earryh		.EQU <Earryl+1	; array mem end high byte	(End-of-Arrays)
    82             00000081   Sstorl		.EQU $81		; string storage low byte	(String storage (moving 
                    down))
    83             00000082   Sstorh		.EQU <Sstorl+1	; string storage high byte	(String storage (moving down))
    84             00000083   Sutill		.EQU $83		; string utility ptr low byte
    85             00000084   Sutilh		.EQU <Sutill+1	; string utility ptr high byte
    86             00000085   Ememl		.EQU $85		; end of mem low byte		(Limit-of-memory)
    87             00000086   Ememh		.EQU <Ememl+1	; end of mem high byte		(Limit-of-memory)
    88                        
    89             00000087   Clinel		.EQU $87		; current line low byte		(Basic line number)
    90             00000088   Clineh		.EQU <Clinel+1	; current line high byte	(Basic line number)
    91             00000089   Blinel		.EQU $89		; break line low byte		(Previous Basic line num
                    ber)
    92             0000008A   Blineh		.EQU <Blinel+1	; break line high byte		(Previous Basic line number)
    93                        
    94             0000008B   Cpntrl		.EQU $8B		; continue pointer low byte
    95             0000008C   Cpntrh		.EQU <Cpntrl+1	; continue pointer high byte
    96                        
    97             0000008D   Dlinel		.EQU $8D		; current DATA line low byte
    98             0000008E   Dlineh		.EQU <Dlinel+1	; current DATA line high byte
    99                        
  Sun Nov 21 2021 15:13                                                                                                Page 7


   100             0000008F   Dptrl		.EQU $8F		; DATA pointer low byte
   101             00000090   Dptrh		.EQU <Dptrl+1	; DATA pointer high byte
   102                        
   103             00000091   Rdptrl		.EQU $91		; read pointer low byte
   104             00000092   Rdptrh		.EQU <Rdptrl+1	; read pointer high byte
   105                        
   106             00000093   Varnm1		.EQU $93		; current var name 1st byte
   107             00000094   Varnm2		.EQU <Varnm1+1	; current var name 2nd byte
   108                        
   109             00000095   Cvaral		.EQU $95		; current var address low byte
   110             00000096   Cvarah		.EQU <Cvaral+1	; current var address high byte
   111                        
   112             00000097   Frnxtl		.EQU $97		; var pointer for FOR/NEXT low byte
   113             00000098   Frnxth		.EQU <Frnxtl+1	; var pointer for FOR/NEXT high byte
   114                        
   115             00000097   Tidx1		.EQU <Frnxtl	; temp line index
   116                        
   117             00000097   Lvarpl		.EQU <Frnxtl	; let var pointer low byte
   118             00000098   Lvarph		.EQU <Frnxth	; let var pointer high byte
   119                        
   120             00000099   prstk		.EQU $99		; precedence stacked flag
   121                        
   122             0000009B   comp_f		.EQU $9B		; compare function flag, bits 0,1 and 2 used
   123                        					; bit 2 set if >
   124                        					; bit 1 set if =
   125                        					; bit 0 set if <
   126                        
   127             0000009C   func_l		.EQU $9C		; function pointer low byte
   128             0000009D   func_h		.EQU <func_l+1	; function pointer high byte
   129                        
   130             0000009C   garb_l		.EQU <func_l	; garbage collection working pointer low byte
   131             0000009D   garb_h		.EQU <func_h	; garbage collection working pointer high byte
   132                        
   133             0000009E   des_2l		.EQU $9E		; string descriptor_2 pointer low byte
   134             0000009F   des_2h		.EQU <des_2l+1	; string descriptor_2 pointer high byte
   135                        
   136             000000A0   g_step		.EQU $A0		; garbage collect step size
   137                        
   138             000000A1   Fnxjmp		.EQU $A1		; jump vector for functions
   139             000000A2   Fnxjpl		.EQU <Fnxjmp+1	; functions jump vector low byte
   140             000000A3   Fnxjph		.EQU <Fnxjmp+2	; functions jump vector high byte
   141                        
   142             000000A2   g_indx		.EQU <Fnxjpl	; garbage collect temp index
   143                        
   144             000000A3   FAC2_r		.EQU $A3		; FAC2 rounding byte
   145                        
   146             000000A4   Adatal		.EQU $A4		; array data pointer low byte
   147             000000A5   Adatah		.EQU <Adatal+1	; array data pointer high  byte
   148                        
   149             000000A4   Nbendl		.EQU <Adatal	; new block end pointer low byte
   150             000000A5   Nbendh		.EQU <Adatah	; new block end pointer high  byte
   151                        
   152             000000A6   Obendl		.EQU $A6		; old block end pointer low byte
   153             000000A7   Obendh		.EQU <Obendl+1	; old block end pointer high  byte
   154                        
   155             000000A8   numexp		.EQU $A8		; string to float number exponent count
   156             000000A9   expcnt		.EQU $A9		; string to float exponent count
  Sun Nov 21 2021 15:13                                                                                                Page 8


   157                        
   158             000000A8   numbit		.EQU <numexp	; bit count for array element calculations
   159                        
   160             000000AA   numdpf		.EQU $AA		; string to float decimal point flag
   161             000000AB   expneg		.EQU $AB		; string to float eval exponent -ve flag
   162                        
   163             000000AA   Astrtl		.EQU <numdpf	; array start pointer low byte
   164             000000AB   Astrth		.EQU <expneg	; array start pointer high  byte
   165                        
   166             000000AA   Histrl		.EQU <numdpf	; highest string low byte
   167             000000AB   Histrh		.EQU <expneg	; highest string high  byte
   168                        
   169             000000AA   Baslnl		.EQU <numdpf	; BASIC search line pointer low byte
   170             000000AB   Baslnh		.EQU <expneg	; BASIC search line pointer high  byte
   171                        
   172             000000AA   Fvar_l		.EQU <numdpf	; find/found variable pointer low byte
   173             000000AB   Fvar_h		.EQU <expneg	; find/found variable pointer high  byte
   174                        
   175             000000AA   Ostrtl		.EQU <numdpf	; old block start pointer low byte
   176             000000AB   Ostrth		.EQU <expneg	; old block start pointer high  byte
   177                        
   178             000000AA   Vrschl		.EQU <numdpf	; variable search pointer low byte
   179             000000AB   Vrschh		.EQU <expneg	; variable search pointer high  byte
   180                        
   181             000000AC   FAC1_e		.EQU $AC		; FAC1 exponent
   182             000000AD   FAC1_1		.EQU <FAC1_e+1	; FAC1 mantissa1
   183             000000AE   FAC1_2		.EQU <FAC1_e+2	; FAC1 mantissa2
   184             000000AF   FAC1_3		.EQU <FAC1_e+3	; FAC1 mantissa3
   185             000000B0   FAC1_s		.EQU <FAC1_e+4	; FAC1 sign (b7)
   186                        
   187             000000AC   str_ln		.EQU <FAC1_e	; string length
   188             000000AD   str_pl		.EQU <FAC1_1	; string pointer low byte
   189             000000AE   str_ph		.EQU <FAC1_2	; string pointer high byte
   190                        
   191             000000AE   des_pl		.EQU <FAC1_2	; string descriptor pointer low byte
   192             000000AF   des_ph		.EQU <FAC1_3	; string descriptor pointer high byte
   193                        
   194             000000AF   mids_l		.EQU <FAC1_3	; MID$ string temp length byte
   195                        
   196             000000B1   negnum		.EQU $B1		; string to float eval -ve flag
   197             000000B1   numcon		.EQU $B1		; series evaluation constant count
   198                        
   199             000000B2   FAC1_o		.EQU $B2		; FAC1 overflow byte
   200                        
   201             000000B3   FAC2_e		.EQU $B3		; FAC2 exponent
   202             000000B4   FAC2_1		.EQU <FAC2_e+1	; FAC2 mantissa1
   203             000000B5   FAC2_2		.EQU <FAC2_e+2	; FAC2 mantissa2
   204             000000B6   FAC2_3		.EQU <FAC2_e+3	; FAC2 mantissa3
   205             000000B7   FAC2_s		.EQU <FAC2_e+4	; FAC2 sign (b7)
   206                        
   207             000000B8   FAC_sc		.EQU $B8		; FAC sign comparison, Acc#1 vs #2
   208             000000B9   FAC1_r		.EQU $B9		; FAC1 rounding byte
   209                        
   210             000000B8   ssptr_l		.EQU <FAC_sc	; string start pointer low byte
   211             000000B9   ssptr_h		.EQU <FAC1_r	; string start pointer high byte
   212                        
   213             000000B8   sdescr		.EQU <FAC_sc	; string descriptor pointer
  Sun Nov 21 2021 15:13                                                                                                Page 9


   214                        
   215             000000BA   csidx		.EQU $BA		; line crunch save index
   216             000000BA   Asptl		.EQU <csidx	; array size/pointer low byte
   217             000000BB   Aspth		.EQU $BB		; array size/pointer high byte
   218                        
   219             000000BA   Btmpl		.EQU <Asptl	; BASIC pointer temp low byte
   220             000000BB   Btmph		.EQU <Aspth	; BASIC pointer temp low byte
   221                        
   222             000000BA   Cptrl		.EQU <Asptl	; BASIC pointer temp low byte
   223             000000BB   Cptrh		.EQU <Aspth	; BASIC pointer temp low byte
   224                        
   225             000000BA   Sendl		.EQU <Asptl	; BASIC pointer temp low byte
   226             000000BB   Sendh		.EQU <Aspth	; BASIC pointer temp low byte
   227                        
   228             000000BC   LAB_IGBY	.EQU $BC		; get next BASIC byte subroutine
   229                        
   230             000000C2   LAB_GBYT	.EQU $C2		; get current BASIC byte subroutine
   231             000000C3   Bpntrl		.EQU $C3		; BASIC execute (get byte) pointer low byte
   232             000000C4   Bpntrh		.EQU <Bpntrl+1	; BASIC execute (get byte) pointer high byte
   233             000000C5   Bpntrp		.EQU <Bpntrl+2	; BASIC execute (get byte) pointer PAGE byte
   234                        
   235                        ;			= $E0		; end of get BASIC char subroutine
   236                        
   237             000000E1   Rbyte4		.EQU $E1		; extra PRNG byte
   238             000000E2   Rbyte1		.EQU <Rbyte4+1	; most significant PRNG byte
   239             000000E3   Rbyte2		.EQU <Rbyte4+2	; middle PRNG byte
   240             000000E4   Rbyte3		.EQU <Rbyte4+3	; least significant PRNG byte
   241                        
   242             000000E5   NmiBase		.EQU $E5		; NMI handler enabled/setup/triggered flags
   243                        					; bit	function
   244                        					; ===	========
   245                        					; 7	interrupt enabled
   246                        					; 6	interrupt setup
   247                        					; 5	interrupt happened
   248                        ;			= $E6		; NMI handler addr low byte
   249                        ;			= $E7		; NMI handler addr high byte
   250             000000E8   IrqBase		.EQU $E8		; IRQ handler enabled/setup/triggered flags
   251                        ;			= $E9		; IRQ handler addr low byte
   252                        ;			= $EA		; IRQ handler addr high byte
   253             000000EB   FCBPTR		.EQU	$EB		; POINTER TO FCB FOR FILE OPS
   254                        
   255             000000EF   Decss		.EQU $EF		; number to decimal string start
   256             000000F0   Decssp1		.EQU Decss+1	; number to decimal string start
   257                        
   258             000000FD   TEMPW       .EQU $FD
   259                        ;			= $FF		; decimal string end
   260                        
   261                        
   262                        ;____________________________________________________________________________________________
   263                        ;
   264                        ; character get subroutine for zero page
   265                        
   266                        ; For a 1.8432MHz 6502 including the JSR and RTS
   267                        ; fastest (>=":")	=  29 cycles =  15.7uS
   268                        ; slowest (<":")	=  40 cycles =  21.7uS
   269                        ; space skip	= +21 cycles = +11.4uS
   270                        ; inc across page	=  +4 cycles =  +2.2uS
  Sun Nov 21 2021 15:13                                                                                                Page 10


   271                        
   272                        ; the target address for the LDA at LAB_2CF4 becomes the BASIC execute pointer once the
   273                        ; block is copied to it's destination, any non zero page address will do at assembly
   274                        ; time, to assemble a three byte instruction.
   275                        
   276                        ; page 0 initialisation table from $BC
   277                        ; increment and scan memory
   278                        ;____________________________________________________________________________________________
   279                        
   280                        LAB_2CEE
   281 FF:1003: E6 C3        	INC	<Bpntrl		; increment BASIC execute pointer low byte
   282 FF:1005: D0 02        	BNE	LAB_2CF4		; branch if no carry
   283                        					; else
   284 FF:1007: E6 C4        	INC	<Bpntrh		; increment BASIC execute pointer high byte
   285                        
   286                        ; page 0 initialisation table from $C2
   287                        ; scan memory
   288                        LAB_2CF4
   289 FF:1009: AF FF FF FF  	LDA	$FFFFFF			; get byte to scan (addr set by call routine)
   290 FF:100D: C9 C1        	CMP	#TK_ELSE		; compare with the token for ELSE
   291 FF:100F: F0 0E        	BEQ	LAB_2D05		; exit if ELSE, not numeric, carry set
   292                        
   293 FF:1011: C9 3A        	CMP	#':'			; compare with ":"
   294 FF:1013: B0 0A        	BCS	LAB_2D05		; exit if >= ":", not numeric, carry set
   295                        
   296 FF:1015: C9 20        	CMP	#' '			; compare with " "
   297 FF:1017: F0 EA        	BEQ	LAB_2CEE		; if " " go do next
   298                        
   299 FF:1019: 38           	SEC				; set carry for SBC
   300 FF:101A: E9 30        	SBC	#'0'			; subtract "0"
   301 FF:101C: 38           	SEC				; set carry for SBC
   302 FF:101D: E9 D0        	SBC	#$D0			; subtract -"0"
   303                        					; clear carry if byte = "0"-"9"
   304                        LAB_2D05
   305 FF:101F: 6B           	RTL
   306                        LAB_2CEE_END
   307                        ;____________________________________________________________________________________________
   308                        ;
   309                        ; page zero initialisation table $00-$12 inclusive
   310                        ;____________________________________________________________________________________________
   311                        
   312                        StrTab
   313 FF:1020: 4C           	.byte	$4C			; JMP opcode
   314 FF:1021: 52 27        	.word LAB_COLD		; initial warm start vector (cold start)
   315                        
   316 FF:1023: 00           	.byte	$00			; these bytes are not used by BASIC
   317 FF:1024: 00 00        	.word	$0000			;
   318 FF:1026: 00 00        	.word	$0000			;
   319 FF:1028: 00 00        	.word	$0000			;
   320                        
   321 FF:102A: 4C           	.byte	$4C			; JMP opcode
   322 FF:102B: 87 38        	.word	LAB_FCER		; initial user function vector ("Function call" error)
   323 FF:102D: 00           	.byte	$00			; default NULL count
   324 FF:102E: 00           	.byte	$00			; clear terminal position
   325 FF:102F: 00           	.byte	$00			; default terminal width byte
   326 FF:1030: F2           	.byte	$F2			; default limit for TAB = 14
   327 FF:1031: 00 22        	.word	Ram_base		; start of user RAM
  Sun Nov 21 2021 15:13                                                                                                Page 11


   328                        EndTab
   329                        
   330                        ;  BASIC start-up code
   331                        
   332                        PG2_TABS
   333 FF:1033: 00           	.byte	$00			; ctrl-c flag		-	$00 = enabled
   334 FF:1034: 03           	.byte	$03			; ctrl-c byte		-	GET needs this
   335 FF:1035: 00           	.byte	$00			; ctrl-c byte timeout	-	GET needs this
   336 FF:1036: 36 4D        	.word	CTRLC			; ctrl c check vector
   337                        PG2_TABE
    42                        
    43                        ; BASIC TOKENS
    44                        	INCLUDE 'TOKENS.ASM'
     1                        ; token values needed for BASIC
     2                        
     3                        ; primary command tokens (can start a statement)
     4                        
     5             00000080   TK_END		.EQU $80			; END
     6             00000081   TK_FOR		.EQU TK_END+1		; FOR token
     7             00000082   TK_NEXT		.EQU TK_FOR+1		; NEXT token
     8             00000083   TK_DATA		.EQU TK_NEXT+1		; DATA token
     9             00000084   TK_DIRECTORY	.EQU TK_DATA+1		; DISKSTATUS token
    10             00000085   TK_DISKSTATUS	.EQU TK_DIRECTORY+1	; DIRECTORY token
    11             00000086   TK_INPUT	.EQU TK_DISKSTATUS+1	; INPUT token
    12             00000087   TK_DIM		.EQU TK_INPUT+1	; DIM token
    13             00000088   TK_READ		.EQU TK_DIM+1		; READ token
    14             00000089   TK_LET		.EQU TK_READ+1		; LET token
    15             0000008A   TK_DEC		.EQU TK_LET+1		; DEC token
    16             0000008B   TK_GOTO		.EQU TK_DEC+1		; GOTO token
    17             0000008C   TK_RUN		.EQU TK_GOTO+1		; RUN token
    18             0000008D   TK_IF		.EQU TK_RUN+1		; IF token
    19             0000008E   TK_RESTORE	.EQU TK_IF+1		; RESTORE token
    20             0000008F   TK_GOSUB	.EQU TK_RESTORE+1	; GOSUB token
    21             00000090   TK_RETURN	.EQU TK_GOSUB+1	; RETURN token
    22             00000091   TK_REM		.EQU TK_RETURN+1	; REM token
    23             00000092   TK_STOP		.EQU TK_REM+1		; STOP token
    24             00000093   TK_ON		.EQU TK_STOP+1		; ON token
    25             00000094   TK_NULL		.EQU TK_ON+1		; NULL token
    26             00000095   TK_INC		.EQU TK_NULL+1		; INC token
    27             00000096   TK_WAIT		.EQU TK_INC+1		; WAIT token
    28             00000097   TK_LOAD		.EQU TK_WAIT+1		; LOAD token
    29             00000098   TK_SAVE		.EQU TK_LOAD+1		; SAVE token
    30             00000099   TK_DEF		.EQU TK_SAVE+1		; DEF token
    31             0000009A   TK_POKE		.EQU TK_DEF+1		; POKE token
    32             0000009B   TK_CALL		.EQU TK_POKE+1		; CALL token
    33             0000009C   TK_DO		 .EQU TK_CALL+1		; DO token
    34             0000009D   TK_LOOP		.EQU TK_DO+1		; LOOP token
    35             0000009E   TK_PRINT	.EQU TK_LOOP+1		; PRINT token
    36             0000009F   TK_CONT		.EQU TK_PRINT+1	; CONT token
    37             000000A0   TK_LIST		.EQU TK_CONT+1		; LIST token
    38             000000A1   TK_CLEAR	.EQU TK_LIST+1		; CLEAR token
    39             000000A2   TK_NEW		.EQU TK_CLEAR+1	; NEW token
    40             000000A3   TK_WIDTH	.EQU TK_NEW+1		; WIDTH token
    41             000000A4   TK_GET		.EQU TK_WIDTH+1	; GET token
    42             000000A5   TK_SWAP		.EQU TK_GET+1		; SWAP token
    43             000000A6   TK_BITSET	.EQU TK_SWAP+1		; BITSET token
    44             000000A7   TK_BITCLR	.EQU TK_BITSET+1	; BITCLR token
  Sun Nov 21 2021 15:13                                                                                                Page 12


    45             000000A8   TK_MONITOR	.EQU TK_BITCLR+1		; MONITOR token
    46             000000A9   TK_OPEN		.EQU TK_MONITOR+1	; OPEN token
    47             000000AA   TK_CLOSE	.EQU TK_OPEN+1		; CLOSE token
    48             000000AB   TK_IECINPUT	.EQU TK_CLOSE+1		; IECINPUT token
    49             000000AC   TK_IECOUTPUT	.EQU TK_IECINPUT+1	; IECOUTPUT token
    50             000000AD   TK_PUTN		.EQU TK_IECOUTPUT+1	; PUTN token
    51             000000AE   TK_GETN		.EQU TK_PUTN+1	; GETN token
    52             000000AF   TK_DISKCMD	.EQU TK_GETN+1		; DISKCMD token
    53             000000B0   TK_SCNCLR	.EQU TK_DISKCMD+1		;SCNCLR token
    54             000000B1   TK_LOCATE	.EQU TK_SCNCLR+1		;LOCATE token
    55             000000B2   TK_COLOR	.EQU TK_LOCATE+1		;COLOR token
    56             000000B3   TK_SPOKE	.EQU TK_COLOR+1			;SPOKE token
    57             000000B4   TK_SCREEN	.EQU TK_SPOKE+1			;SCREEN token
    58             000000B5   TK_SPRITE	.EQU TK_SCREEN+1		;SPRITE token
    59             000000B6   TK_SPRDEF	.EQU TK_SPRITE+1		;SPRDEF token
    60             000000B7   TK_SPRSIZE	.EQU TK_SPRDEF+1		;SPRSIZE token
    61             000000B8   TK_PLOT		.EQU TK_SPRSIZE+1		;PLOT token
    62             000000B9   TK_PATTERN	.EQU TK_PLOT+1			;PATTERN token
    63             000000BA   TK_SYS		.EQU TK_PATTERN+1		;SYS token
    64             000000BB   TK_SOUND	.EQU TK_SYS+1			;SOUND token
    65             000000BC   TK_NOISE	.EQU TK_SOUND+1			;NOISE token
    66             000000BD   TK_TONE		.EQU TK_NOISE+1			;TONE token
    67             000000BE   TK_VOLUME	.EQU TK_TONE+1			;VOLUME token
    68             000000BF   TK_VOICE	.EQU TK_VOLUME+1		;VOICE token
    69                        
    70                        ; secondary command tokens, can't start a statement
    71                        
    72             000000C0   TK_TAB		.EQU TK_VOICE+1		; TAB token
    73             000000C1   TK_ELSE		.EQU TK_TAB+1		; ELSE token
    74             000000C2   TK_TO		.EQU TK_ELSE+1		; TO token
    75             000000C3   TK_FN		.EQU TK_TO+1		; FN token
    76             000000C4   TK_SPC		.EQU TK_FN+1		; SPC token
    77             000000C5   TK_THEN		.EQU TK_SPC+1		; THEN token
    78             000000C6   TK_NOT		.EQU TK_THEN+1		; NOT token
    79             000000C7   TK_STEP		.EQU TK_NOT+1		; STEP token
    80             000000C8   TK_UNTIL	.EQU TK_STEP+1		; UNTIL token
    81             000000C9   TK_WHILE	.EQU TK_UNTIL+1	; WHILE token
    82             000000CA   TK_OFF		.EQU TK_WHILE+1	; OFF token
    83                        
    84                        ; opperator tokens
    85                        
    86             000000CB   TK_PLUS		.EQU TK_OFF+1		; + token
    87             000000CC   TK_MINUS	.EQU TK_PLUS+1		; - token
    88             000000CD   TK_MUL		.EQU TK_MINUS+1	; * token
    89             000000CE   TK_DIV		.EQU TK_MUL+1		; / token
    90             000000CF   TK_POWER	.EQU TK_DIV+1		; ^ token
    91             000000D0   TK_AND		.EQU TK_POWER+1	; AND token
    92             000000D1   TK_EOR		.EQU TK_AND+1		; EOR token
    93             000000D2   TK_OR		.EQU TK_EOR+1		; OR token
    94             000000D3   TK_RSHIFT	.EQU TK_OR+1		; RSHIFT token
    95             000000D4   TK_LSHIFT	.EQU TK_RSHIFT+1	; LSHIFT token
    96             000000D5   TK_GT		.EQU TK_LSHIFT+1	; > token
    97             000000D6   TK_EQUAL	.EQU TK_GT+1		; = token
    98             000000D7   TK_LT		.EQU TK_EQUAL+1	; < token
    99                        
   100                        ; functions tokens
   101                        
  Sun Nov 21 2021 15:13                                                                                                Page 13


   102             000000D8   TK_SGN		.EQU TK_LT+1		; SGN token
   103             000000D9   TK_INT		.EQU TK_SGN+1		; INT token
   104             000000DA   TK_ABS		.EQU TK_INT+1		; ABS token
   105             000000DB   TK_USR		.EQU TK_ABS+1		; USR token
   106             000000DC   TK_FRE		.EQU TK_USR+1		; FRE token
   107             000000DD   TK_POS		.EQU TK_FRE+1		; POS token
   108             000000DE   TK_SQR		.EQU TK_POS+1		; SQR token
   109             000000DF   TK_RND		.EQU TK_SQR+1		; RND token
   110             000000E0   TK_LOG		.EQU TK_RND+1		; LOG token
   111             000000E1   TK_EXP		.EQU TK_LOG+1		; EXP token
   112             000000E2   TK_COS		.EQU TK_EXP+1		; COS token
   113             000000E3   TK_SIN		.EQU TK_COS+1		; SIN token
   114             000000E4   TK_TAN		.EQU TK_SIN+1		; TAN token
   115             000000E5   TK_ATN		.EQU TK_TAN+1		; ATN token
   116             000000E6   TK_PEEK		.EQU TK_ATN+1		; PEEK token
   117             000000E7   TK_SPEEK	.EQU TK_PEEK+1		;SPEEK token
   118             000000E8   TK_SADD		.EQU TK_SPEEK+1		; SADD token
   119             000000E9   TK_LEN		.EQU TK_SADD+1		; LEN token
   120             000000EA   TK_STRS		.EQU TK_LEN+1		; STR$ token
   121             000000EB   TK_VAL		.EQU TK_STRS+1		; VAL token
   122             000000EC   TK_ASC		.EQU TK_VAL+1		; ASC token
   123             000000ED   TK_UCASES	.EQU TK_ASC+1		; UCASE$ token
   124             000000EE   TK_LCASES	.EQU TK_UCASES+1	; LCASE$ token
   125             000000EF   TK_CHRS		.EQU TK_LCASES+1	; CHR$ token
   126             000000F0   TK_HEXS		.EQU TK_CHRS+1		; HEX$ token
   127             000000F1   TK_BINS		.EQU TK_HEXS+1		; BIN$ token
   128             000000F2   TK_BITTST	.EQU TK_BINS+1		; BITTST token
   129             000000F3   TK_MAX		.EQU TK_BITTST+1	; MAX token
   130             000000F4   TK_MIN		.EQU TK_MAX+1		; MIN token
   131             000000F5   TK_PI		.EQU TK_MIN+1		; PI token
   132             000000F6   TK_IECST	.EQU TK_PI+1		; IECST token
   133             000000F7   TK_VIDST	.EQU TK_IECST+1		; VIDST token
   134             000000F8   TK_VPTR		.EQU TK_VIDST+1		; VARPTR token
   135             000000F9   TK_LEFTS	.EQU TK_VPTR+1		; LEFT$ token
   136             000000FA   TK_RIGHTS	.EQU TK_LEFTS+1		; RIGHT$ token
   137             000000FB   TK_MIDS		.EQU TK_RIGHTS+1	; MID$ token
   138             000000FC   TK_CON		.EQU TK_MIDS+1		; CON token
   139                        
   140                        
   141                        
   142                        
   143                        LAB_CTBL
   144 FF:1038: D7 2C        	.word	LAB_END-1		; END
   145 FF:103A: 0F 2C        	.word	LAB_FOR-1		; FOR
   146 FF:103C: 6C 33        	.word	LAB_NEXT-1		; NEXT
   147 FF:103E: 5A 2E        	.word	LAB_DATA-1		; DATA
   148 FF:1040: 77 1A        	.WORD	V_DIR-1			; DIRECTORY
   149 FF:1042: FC 19        	.word   V_ERR-1 		; DISKSTATUS
   150 FF:1044: 0C 32        	.word	LAB_INPUT-1		; INPUT
   151 FF:1046: B2 36        	.word	LAB_DIM-1		; DIM
   152 FF:1048: 25 32        	.word	LAB_READ-1		; READ
   153 FF:104A: 7F 2F        	.word	LAB_LET-1		; LET
   154 FF:104C: 4F 2F        	.word	LAB_DEC-1		; DEC			new command
   155 FF:104E: B4 2D        	.word	LAB_GOTO-1		; GOTO
   156 FF:1050: 71 2D        	.word	LAB_RUN-1		; RUN
   157 FF:1052: 88 2E        	.word	LAB_IF-1		; IF
   158 FF:1054: 09 2D        	.word	LAB_RESTORE-1	; RESTORE		modified command
  Sun Nov 21 2021 15:13                                                                                                Page 14


   159 FF:1056: 96 2D        	.word	LAB_GOSUB-1		; GOSUB
   160 FF:1058: 45 2E        	.word	LAB_RETURN-1	; RETURN
   161 FF:105A: F3 2E        	.word	LAB_REM-1		; REM
   162 FF:105C: D5 2C        	.word	LAB_STOP-1		; STOP
   163 FF:105E: FC 2E        	.word	LAB_ON-1		; ON			modified command
   164 FF:1060: 47 2D        	.word	LAB_NULL-1		; NULL		modified command
   165 FF:1062: 52 2F        	.word	LAB_INC-1		; INC			new command
   166 FF:1064: 1C 42        	.word	LAB_WAIT-1		; WAIT
   167 FF:1066: 71 19        	.word	V_LOAD-1		; LOAD
   168 FF:1068: E4 18        	.word	V_SAVE-1		; SAVE
   169 FF:106A: DA 39        	.word	LAB_DEF-1		; DEF
   170 FF:106C: 6C 41        	.word	LAB_POKE-1		; POKE
   171 FF:106E: 08 42        	.word	LAB_CALL-1		; CALL		new command
   172 FF:1070: 7B 2D        	.word	LAB_DO-1		; DO			new command
   173 FF:1072: E6 2D        	.word	LAB_LOOP-1		; LOOP		new command
   174 FF:1074: E9 30        	.word	LAB_PRINT-1		; PRINT
   175 FF:1076: 4D 2D        	.word	LAB_CONT-1		; CONT
   176 FF:1078: 4F 2B        	.word	LAB_LIST-1		; LIST
   177 FF:107A: 4C 2B        	.word	LAB_CLEAR-1		; CLEAR
   178 FF:107C: FC 2A        	.word	LAB_NEW-1		; NEW
   179 FF:107E: 4A 4E        	.word	LAB_WDTH-1		; WIDTH		new command
   180 FF:1080: A3 30        	.word	LAB_GET-1		; GET			new command
   181 FF:1082: 90 41        	.word	LAB_SWAP-1		; SWAP		new command
   182 FF:1084: CD 4B        	.word	LAB_BITSET-1	; BITSET		new command
   183 FF:1086: E1 4B        	.word	LAB_BITCLR-1	; BITCLR		new command
   184 FF:1088: 1D 27        	.word	LAB_MONITOR-1		; MONITOR		MONITOR command
   185 FF:108A: 12 1C        	.word	V_OPEN-1		; OPEN			OPEN command
   186 FF:108C: 95 1C        	.word	V_CLOSE-1		; CLOSE			CLOSE command
   187 FF:108E: A6 1C        	.word	V_IECINPUT-1		; IECINPUT		IECINPUT command
   188 FF:1090: BC 1C        	.word	V_IECOUTPUT-1		; IECOUTPUT		IECOUTPUT command
   189 FF:1092: D2 1C        	.word	V_PUTN-1		; PUTN			PUTN command
   190 FF:1094: 3E 1D        	.word	V_GETN-1		; GETN			GETN command
   191 FF:1096: 4E 1B        	.WORD 	V_DISKCMD-1		; DISKCMD		DISKCMD COMMAND
   192 FF:1098: 8B 1D        	.WORD 	V_SCNCLR-1		; SCNCLR		SCNCLR COMMAND
   193 FF:109A: 98 1D        	.WORD 	V_LOCATE-1		; LOCATE		LOCATE COMMAND
   194 FF:109C: B0 1D        	.WORD 	V_COLOR-1		; COLOR			COLOR COMMAND
   195 FF:109E: 20 1E        	.WORD 	V_SPOKE-1		; SPOKE			SPOKE COMMAND
   196 FF:10A0: 45 1E        	.WORD 	V_SCREEN-1		; SCREEN		SCREEN COMMAND
   197 FF:10A2: 42 20        	.WORD 	V_SPRITE-1		; SPRITE		SPRITE COMMAND
   198 FF:10A4: B6 20        	.WORD 	V_SPRDEF-1		; SPRDEF		SPRDEF COMMAND
   199 FF:10A6: 1F 21        	.WORD 	V_SPRSIZE-1		; SPRSIZE		SPRSIZE COMMAND
   200 FF:10A8: 4E 21        	.WORD 	V_PLOT-1		; PLOT			PLOT COMMAND
   201 FF:10AA: 32 23        	.WORD 	V_PATTERN-1		; PATTERN		PATTERN COMMAND
   202 FF:10AC: 7D 41        	.WORD 	LAB_SYS-1		; SYS			SYS COMMAND
   203 FF:10AE: 16 24        	.WORD 	V_SOUND-1		; SOUND			SOUND COMMAND
   204 FF:10B0: 6D 24        	.WORD 	V_NOISE-1		; NOISE			NOISE COMMAND
   205 FF:10B2: AC 24        	.WORD 	V_TONE-1		; TONE			TONE COMMAND
   206 FF:10B4: 36 24        	.WORD 	V_VOLUME-1		; VOLUME		VOLUME COMMAND
   207 FF:10B6: 4B 24        	.WORD 	V_VOICE-1		; VOICE			VOICE COMMAND
   208                        ; function pre process routine table
   209                        
   210                        LAB_FTPL
   211             00FF10B9   LAB_FTPM	.EQU LAB_FTPL+$01
   212 FF:10B8: 8A 35        	.word	LAB_PPFN-1		; SGN(n)	process numeric expression in ()
   213 FF:10BA: 8A 35        	.word	LAB_PPFN-1		; INT(n)		"
   214 FF:10BC: 8A 35        	.word	LAB_PPFN-1		; ABS(n)		"
   215 FF:10BE: 09 34        	.word	LAB_EVEZ-1		; USR(x)	process any expression
  Sun Nov 21 2021 15:13                                                                                                Page 15


   216 FF:10C0: 0F 35        	.word	LAB_1BF7-1		; FRE(x)		"
   217 FF:10C2: 0F 35        	.word	LAB_1BF7-1		; POS(x)		"
   218 FF:10C4: 8A 35        	.word	LAB_PPFN-1		; SQR(n)	process numeric expression in ()
   219 FF:10C6: 8A 35        	.word	LAB_PPFN-1		; RND(n)		"
   220 FF:10C8: 8A 35        	.word	LAB_PPFN-1		; LOG(n)		"
   221 FF:10CA: 8A 35        	.word	LAB_PPFN-1		; EXP(n)		"
   222 FF:10CC: 8A 35        	.word	LAB_PPFN-1		; COS(n)		"
   223 FF:10CE: 8A 35        	.word	LAB_PPFN-1		; SIN(n)		"
   224 FF:10D0: 8A 35        	.word	LAB_PPFN-1		; TAN(n)		"
   225 FF:10D2: 8A 35        	.word	LAB_PPFN-1		; ATN(n)		"
   226 FF:10D4: 8A 35        	.word	LAB_PPFN-1		; PEEK(n)		"
   227 FF:10D6: 8A 35        	.WORD 	LAB_PPFN-1		; SPEEK(N)		"
   228 FF:10D8: 00 00        	.word	$0000			; SADD()	none
   229 FF:10DA: 84 35        	.word	LAB_PPFS-1		; LEN($)	process string expression in ()
   230 FF:10DC: 8A 35        	.word	LAB_PPFN-1		; STR$(n)	process numeric expression in ()
   231 FF:10DE: 84 35        	.word	LAB_PPFS-1		; VAL($)	process string expression in ()
   232 FF:10E0: 84 35        	.word	LAB_PPFS-1		; ASC($)		"
   233 FF:10E2: 84 35        	.word	LAB_PPFS-1		; UCASE$($)		"
   234 FF:10E4: 84 35        	.word	LAB_PPFS-1		; LCASE$($)		"
   235 FF:10E6: 8A 35        	.word	LAB_PPFN-1		; CHR$(n)	process numeric expression in ()
   236 FF:10E8: B3 35        	.word	LAB_BHSS-1		; HEX$(n)		"
   237 FF:10EA: B3 35        	.word	LAB_BHSS-1		; BIN$(n)		"
   238 FF:10EC: 00 00        	.word	$0000			; BITTST()	none
   239 FF:10EE: DD 4D        	.word	LAB_MMPP-1		; MAX()	process numeric expression
   240 FF:10F0: DD 4D        	.word	LAB_MMPP-1		; MIN()		"
   241 FF:10F2: 90 35        	.word	LAB_PPBI-1		; PI		advance pointer
   242 FF:10F4: 37 1D        	.word	LAB_PIECST-1		; IECST		"
   243 FF:10F6: 18 21        	.word	LAB_PVIDST-1		; VIDST		"
   244 FF:10F8: 00 00        	.word	$0000			; VARPTR()	none
   245 FF:10FA: 97 35        	.word	LAB_LRMS-1		; LEFT$()	process string expression
   246 FF:10FC: 97 35        	.word	LAB_LRMS-1		; RIGHT$()		"
   247 FF:10FE: 97 35        	.word	LAB_LRMS-1		; MID$()		"
   248 FF:1100: 8A 35        	.word	LAB_PPFN-1		; CON()		"
   249                        
   250                        ; action addresses for functions
   251                        
   252                        LAB_FTBL
   253             00FF1103   LAB_FTBM	.EQU LAB_FTBL+$01
   254 FF:1102: 95 46        	.word	LAB_SGN-1		; SGN()
   255 FF:1104: 83 47        	.word	LAB_INT-1		; INT()
   256 FF:1106: B2 46        	.word	LAB_ABS-1		; ABS()
   257 FF:1108: 98 4B        	.word	LAB_USR-1		; USR()
   258 FF:110A: A8 39        	.word	LAB_FRE-1		; FRE()
   259 FF:110C: C7 39        	.word	LAB_POS-1		; POS()
   260 FF:110E: A1 4E        	.word	LAB_SQR-1		; SQR()
   261 FF:1110: E8 4A        	.word	LAB_RND-1		; RND()		modified function
   262 FF:1112: A9 43        	.word	LAB_LOG-1		; LOG()
   263 FF:1114: 36 4A        	.word	LAB_EXP-1		; EXP()
   264 FF:1116: 1C 4B        	.word	LAB_COS-1		; COS()
   265 FF:1118: 23 4B        	.word	LAB_SIN-1		; SIN()
   266 FF:111A: 6C 4B        	.word	LAB_TAN-1		; TAN()
   267 FF:111C: 9E 4B        	.word	LAB_ATN-1		; ATN()
   268 FF:111E: 59 41        	.word	LAB_PEEK-1		; PEEK()
   269 FF:1120: D7 1D        	.WORD 	V_SPEEK-1		; SPEEK()
   270 FF:1122: 28 40        	.word	LAB_SADD-1		; SADD()		new function
   271 FF:1124: 6A 40        	.word	LAB_LENS-1		; LEN()
   272 FF:1126: 19 3B        	.word	LAB_STRS-1		; STR$()
  Sun Nov 21 2021 15:13                                                                                                Page 16


   273 FF:1128: AE 40        	.word	LAB_VAL-1		; VAL()
   274 FF:112A: 75 40        	.word	LAB_ASC-1		; ASC()
   275 FF:112C: DE 3F        	.word	LAB_UCASE-1		; UCASE$()		new function
   276 FF:112E: 92 3F        	.word	LAB_LCASE-1		; LCASE$()		new function
   277 FF:1130: 96 3E        	.word	LAB_CHRS-1		; CHR$()
   278 FF:1132: 9A 4C        	.word	LAB_HEXS-1		; HEX$()		new function
   279 FF:1134: 22 4C        	.word	LAB_BINS-1		; BIN$()		new function
   280 FF:1136: F7 4B        	.word	LAB_BTST-1		; BITTST()		new function
   281 FF:1138: E3 4D        	.word	LAB_MAX-1		; MAX()		new function
   282 FF:113A: F3 4D        	.word	LAB_MIN-1		; MIN()		new function
   283 FF:113C: 3F 4F        	.word	LAB_PI-1		; PI			new function
   284 FF:113E: 2A 1D        	.word	LAB_IECST-1		; IECST		new function
   285 FF:1140: FF 20        	.word	LAB_VIDST-1		; VIDST		new function
   286 FF:1142: 2E 4F        	.word	LAB_VARPTR-1		; VARPTR()		new function
   287 FF:1144: BC 3E        	.word	LAB_LEFT-1		; LEFT$()
   288 FF:1146: DB 3E        	.word	LAB_RIGHT-1		; RIGHT$()
   289 FF:1148: 34 3F        	.word	LAB_MIDS-1		; MID$()
   290 FF:114A: DA 24        	.word	LAB_CON-1		; CON()
   291                        
   292                        ; hierarchy and action addresses for operator
   293                        
   294                        LAB_OPPT
   295 FF:114C: 79           	.byte	$79			; +
   296 FF:114D: 69 42        	.word	LAB_ADD-1
   297 FF:114F: 79           	.byte	$79			; -
   298 FF:1150: 4E 42        	.word	LAB_SUBTRACT-1
   299 FF:1152: 7B           	.byte	$7B			; *
   300 FF:1153: EA 43        	.word	LAB_MULTIPLY-1
   301 FF:1155: 7B           	.byte	$7B			; /
   302 FF:1156: 02 45        	.word	LAB_DIVIDE-1
   303 FF:1158: 7F           	.byte	$7F			; ^
   304 FF:1159: F2 49        	.word	LAB_POWER-1
   305 FF:115B: 50           	.byte	$50			; AND
   306 FF:115C: FE 35        	.word	LAB_AND-1
   307 FF:115E: 46           	.byte	$46			; EOR			new operator
   308 FF:115F: E4 35        	.word	LAB_EOR-1
   309 FF:1161: 46           	.byte	$46			; OR
   310 FF:1162: F1 35        	.word	LAB_OR-1
   311 FF:1164: 56           	.byte	$56			; >>			new operator
   312 FF:1165: D5 36        	.word	LAB_RSHIFT-1
   313 FF:1167: 56           	.byte	$56			; <<			new operator
   314 FF:1168: BD 36        	.word	LAB_LSHIFT-1
   315 FF:116A: 7D           	.byte	$7D			; >
   316 FF:116B: 2B 4A        	.word	LAB_GTHAN-1
   317 FF:116D: 5A           	.byte	$5A			; =
   318 FF:116E: 3C 35        	.word	LAB_EQUAL-1
   319 FF:1170: 64           	.byte	$64			; <
   320 FF:1171: 1F 36        	.word	LAB_LTHAN-1
   321                        
   322                        ; keywords start with ..
   323                        ; this is the first character table and must be in alphabetic order
   324                        
   325                        TAB_1STC
   326 FF:1173: 2A           	.byte	"*"
   327 FF:1174: 2B           	.byte	"+"
   328 FF:1175: 2D           	.byte	"-"
   329 FF:1176: 2F           	.byte	"/"
  Sun Nov 21 2021 15:13                                                                                                Page 17


   330 FF:1177: 3C           	.byte	"<"
   331 FF:1178: 3D           	.byte	"="
   332 FF:1179: 3E           	.byte	">"
   333 FF:117A: 3F           	.byte	"?"
   334 FF:117B: 41           	.byte	"A"
   335 FF:117C: 42           	.byte	"B"
   336 FF:117D: 43           	.byte	"C"
   337 FF:117E: 44           	.byte	"D"
   338 FF:117F: 45           	.byte	"E"
   339 FF:1180: 46           	.byte	"F"
   340 FF:1181: 47           	.byte	"G"
   341 FF:1182: 48           	.byte	"H"
   342 FF:1183: 49           	.byte	"I"
   343 FF:1184: 4B           	.byte	"K"
   344 FF:1185: 4C           	.byte	"L"
   345 FF:1186: 4D           	.byte	"M"
   346 FF:1187: 4E           	.byte	"N"
   347 FF:1188: 4F           	.byte	"O"
   348 FF:1189: 50           	.byte	"P"
   349 FF:118A: 52           	.byte	"R"
   350 FF:118B: 53           	.byte	"S"
   351 FF:118C: 54           	.byte	"T"
   352 FF:118D: 55           	.byte	"U"
   353 FF:118E: 56           	.byte	"V"
   354 FF:118F: 57           	.byte	"W"
   355 FF:1190: 5E           	.byte	"^"
   356 FF:1191: 00           	.byte	$00			; table terminator
   357                        
   358                        ; pointers to keyword tables
   359                        
   360                        TAB_CHRT
   361 FF:1192: CE 11        	.word	TAB_STAR		; table for "*"
   362 FF:1194: D0 11        	.word	TAB_PLUS		; table for "+"
   363 FF:1196: D2 11        	.word	TAB_MNUS		; table for "-"
   364 FF:1198: D4 11        	.word	TAB_SLAS		; table for "/"
   365 FF:119A: D6 11        	.word	TAB_LESS		; table for "<"
   366 FF:119C: DA 11        	.word	TAB_EQUL		; table for "="
   367 FF:119E: DC 11        	.word	TAB_MORE		; table for ">"
   368 FF:11A0: E0 11        	.word	TAB_QEST		; table for "?"
   369 FF:11A2: E2 11        	.word	TAB_ASCA		; table for "A"
   370 FF:11A4: F2 11        	.word	TAB_ASCB		; table for "B"
   371 FF:11A6: 0B 12        	.word	TAB_ASCC		; table for "C"
   372 FF:11A8: 30 12        	.word	TAB_ASCD		; table for "D"
   373 FF:11AA: 5A 12        	.word	TAB_ASCE		; table for "E"
   374 FF:11AC: 69 12        	.word	TAB_ASCF		; table for "F"
   375 FF:11AE: 73 12        	.word	TAB_ASCG		; table for "G"
   376 FF:11B0: 84 12        	.word	TAB_ASCH		; table for "H"
   377 FF:11B2: 8A 12        	.word	TAB_ASCI		; table for "I"
   378 FF:11B4: AF 12        	.word	TAB_ASCK		; table for "K"
   379 FF:11B6: AF 12        	.word	TAB_ASCL		; table for "L"
   380 FF:11B8: DA 12        	.word	TAB_ASCM		; table for "M"
   381 FF:11BA: EF 12        	.word	TAB_ASCN		; table for "N"
   382 FF:11BC: 03 13        	.word	TAB_ASCO		; table for "O"
   383 FF:11BE: 0F 13        	.word	TAB_ASCP		; table for "P"
   384 FF:11C0: 33 13        	.word	TAB_ASCR		; table for "R"
   385 FF:11C2: 56 13        	.word	TAB_ASCS		; table for "S"
   386 FF:11C4: B3 13        	.word	TAB_ASCT		; table for "T"
  Sun Nov 21 2021 15:13                                                                                                Page 18


   387 FF:11C6: C6 13        	.word	TAB_ASCU		; table for "U"
   388 FF:11C8: D7 13        	.word	TAB_ASCV		; table for "V"
   389 FF:11CA: F3 13        	.word	TAB_ASCW		; table for "W"
   390 FF:11CC: 02 14        	.word	TAB_POWR		; table for "^"
   391                        
   392                        ; tables for each start character, note if a longer keyword with the same start
   393                        ; letters as a shorter one exists then it must come first, else the list is in
   394                        ; alphabetical order as follows ..
   395                        
   396                        ; [keyword,token
   397                        ; [keyword,token]]
   398                        ; end marker (#$00)
   399                        
   400                        TAB_STAR
   401 FF:11CE: CD 00        	.byte TK_MUL,$00		; *
   402                        TAB_PLUS
   403 FF:11D0: CB 00        	.byte TK_PLUS,$00		; +
   404                        TAB_MNUS
   405 FF:11D2: CC 00        	.byte TK_MINUS,$00	; -
   406                        TAB_SLAS
   407 FF:11D4: CE 00        	.byte TK_DIV,$00		; /
   408                        TAB_LESS
   409                        LBB_LSHIFT
   410 FF:11D6: 3C D4        	.byte	"<",TK_LSHIFT	; <<	note - "<<" must come before "<"
   411 FF:11D8: D7           	.byte TK_LT			; <
   412 FF:11D9: 00           	.byte	$00
   413                        TAB_EQUL
   414 FF:11DA: D6 00        	.byte TK_EQUAL,$00	; =
   415                        TAB_MORE
   416                        LBB_RSHIFT
   417 FF:11DC: 3E D3        	.byte	">",TK_RSHIFT	; >>	note - ">>" must come before ">"
   418 FF:11DE: D5           	.byte TK_GT			; >
   419 FF:11DF: 00           	.byte	$00
   420                        TAB_QEST
   421 FF:11E0: 9E 00        	.byte TK_PRINT,$00	; ?
   422                        TAB_ASCA
   423                        LBB_ABS
   424 FF:11E2: 42 53 28 DA  	.byte	"BS(",TK_ABS	; ABS(
   425                        LBB_AND
   426 FF:11E6: 4E 44 D0     	.byte	"ND",TK_AND		; AND
   427                        LBB_ASC
   428 FF:11E9: 53 43 28 EC  	.byte	"SC(",TK_ASC	; ASC(
   429                        LBB_ATN
   430 FF:11ED: 54 4E 28 E5  	.byte	"TN(",TK_ATN	; ATN(
   431 FF:11F1: 00           	.byte	$00
   432                        TAB_ASCB
   433                        LBB_BINS
   434 FF:11F2: 49 4E 24 28  	.byte	"IN$(",TK_BINS	; BIN$(
       FF:11F6: F1 
   435                        LBB_BITCLR
   436 FF:11F7: 49 54 43 4C  	.byte	"ITCLR",TK_BITCLR	; BITCLR
       FF:11FB: 52 A7 
   437                        LBB_BITSET
   438 FF:11FD: 49 54 53 45  	.byte	"ITSET",TK_BITSET	; BITSET
       FF:1201: 54 A6 
   439                        LBB_BITTST
   440 FF:1203: 49 54 54 53  	.byte	"ITTST(",TK_BITTST
  Sun Nov 21 2021 15:13                                                                                                Page 19


       FF:1207: 54 28 F2 
   441                        					; BITTST(
   442 FF:120A: 00           	.byte	$00
   443                        TAB_ASCC
   444                        LBB_CALL
   445 FF:120B: 41 4C 4C 9B  	.byte	"ALL",TK_CALL	; CALL
   446                        LBB_CHRS
   447 FF:120F: 48 52 24 28  	.byte	"HR$(",TK_CHRS	; CHR$(
       FF:1213: EF 
   448                        LBB_CLEAR
   449 FF:1214: 4C 45 41 52  	.byte	"LEAR",TK_CLEAR	; CLEAR
       FF:1218: A1 
   450                        LBB_CLOSE
   451 FF:1219: 4C 4F 53 45  	.byte	"LOSE",TK_CLOSE	; CLOSE
       FF:121D: AA 
   452                        LBB_COLOR
   453 FF:121E: 4F 4C 4F 52  	.BYTE 	"OLOR",TK_COLOR ; COLOR
       FF:1222: B2 
   454                        LBB_CON
   455 FF:1223: 4F 4E 28 FC  	.BYTE	"ON(",TK_CON 	;CON
   456                        LBB_CONT
   457 FF:1227: 4F 4E 54 9F  	.byte	"ONT",TK_CONT	; CONT
   458                        LBB_COS
   459 FF:122B: 4F 53 28 E2  	.byte	"OS(",TK_COS	; COS(
   460 FF:122F: 00           	.byte	$00
   461                        TAB_ASCD
   462                        LBB_DATA
   463 FF:1230: 41 54 41 83  	.byte	"ATA",TK_DATA	; DATA
   464                        LBB_DEC
   465 FF:1234: 45 43 8A     	.byte	"EC",TK_DEC		; DEC
   466                        LBB_DEF
   467 FF:1237: 45 46 99     	.byte	"EF",TK_DEF		; DEF
   468                        LBB_DIM
   469 FF:123A: 49 4D 87     	.byte	"IM",TK_DIM		; DIM
   470                        LBB_DIRECTORY
   471 FF:123D: 49 52 45 43  	.byte	"IRECTORY",TK_DIRECTORY ; DIRECTORY
       FF:1241: 54 4F 52 59 
       FF:1245: 84 
   472                        LBB_DISKCMD
   473 FF:1246: 49 53 4B 43  	.byte	"ISKCMD",TK_DISKCMD		; DISKCMD
       FF:124A: 4D 44 AF 
   474                        LBB_DISKSTATUS
   475 FF:124D: 49 53 4B 53  	.byte	"ISKSTATUS",TK_DISKSTATUS ; DISKSTATUS
       FF:1251: 54 41 54 55 
       FF:1255: 53 85 
   476                        LBB_DO
   477 FF:1257: 4F 9C        	.byte	"O",TK_DO		; DO
   478 FF:1259: 00           	.byte	$00
   479                        TAB_ASCE
   480                        LBB_ELSE
   481 FF:125A: 4C 53 45 C1  	.byte	"LSE",TK_ELSE	; ELSE
   482                        LBB_END
   483 FF:125E: 4E 44 80     	.byte	"ND",TK_END		; END
   484                        LBB_EOR
   485 FF:1261: 4F 52 D1     	.byte	"OR",TK_EOR		; EOR
   486                        LBB_EXP
   487 FF:1264: 58 50 28 E1  	.byte	"XP(",TK_EXP	; EXP(
  Sun Nov 21 2021 15:13                                                                                                Page 20


   488 FF:1268: 00           	.byte	$00
   489                        TAB_ASCF
   490                        LBB_FN
   491 FF:1269: 4E C3        	.byte	"N",TK_FN		; FN
   492                        LBB_FOR
   493 FF:126B: 4F 52 81     	.byte	"OR",TK_FOR		; FOR
   494                        LBB_FRE
   495 FF:126E: 52 45 28 DC  	.byte	"RE(",TK_FRE	; FRE(
   496 FF:1272: 00           	.byte	$00
   497                        TAB_ASCG
   498                        LBB_GETN
   499 FF:1273: 45 54 23 AE  	.byte	"ET#",TK_GETN		; GETN
   500                        LBB_GET
   501 FF:1277: 45 54 A4     	.byte	"ET",TK_GET		; GET
   502                        LBB_GOSUB
   503 FF:127A: 4F 53 55 42  	.byte	"OSUB",TK_GOSUB	; GOSUB
       FF:127E: 8F 
   504                        LBB_GOTO
   505 FF:127F: 4F 54 4F 8B  	.byte	"OTO",TK_GOTO	; GOTO
   506 FF:1283: 00           	.byte	$00
   507                        TAB_ASCH
   508                        LBB_HEXS
   509 FF:1284: 45 58 24 28  	.byte	"EX$(",TK_HEXS	; HEX$(
       FF:1288: F0 
   510 FF:1289: 00           	.byte	$00
   511                        TAB_ASCI
   512                        LBB_IECINPUT
   513 FF:128A: 45 43 49 4E  	.byte	"ECINPUT",TK_IECINPUT	; IECINPUT
       FF:128E: 50 55 54 AB 
   514                        LBB_IECOUTPUT
   515 FF:1292: 45 43 4F 55  	.byte	"ECOUTPUT",TK_IECOUTPUT	; IECOUTPUT
       FF:1296: 54 50 55 54 
       FF:129A: AC 
   516                        LBB_IECST
   517 FF:129B: 45 43 53 54  	.byte	"ECST",TK_IECST	; IECST
       FF:129F: F6 
   518                        LBB_IF
   519 FF:12A0: 46 8D        	.byte	"F",TK_IF		; IF
   520                        LBB_INC
   521 FF:12A2: 4E 43 95     	.byte	"NC",TK_INC		; INC
   522                        LBB_INPUT
   523 FF:12A5: 4E 50 55 54  	.byte	"NPUT",TK_INPUT		; INPUT
       FF:12A9: 86 
   524                        LBB_INT
   525 FF:12AA: 4E 54 28 D9  	.byte	"NT(",TK_INT		; INT(
   526 FF:12AE: 00           	.byte	$00
   527                        TAB_ASCK
   528                        TAB_ASCL
   529                        LBB_LCASES
   530 FF:12AF: 43 41 53 45  	.byte	"CASE$(",TK_LCASES
       FF:12B3: 24 28 EE 
   531                        					; LCASE$(
   532                        LBB_LEFTS
   533 FF:12B6: 45 46 54 24  	.byte	"EFT$(",TK_LEFTS	; LEFT$(
       FF:12BA: 28 F9 
   534                        LBB_LEN
   535 FF:12BC: 45 4E 28 E9  	.byte	"EN(",TK_LEN	; LEN(
  Sun Nov 21 2021 15:13                                                                                                Page 21


   536                        LBB_LET
   537 FF:12C0: 45 54 89     	.byte	"ET",TK_LET		; LET
   538                        LBB_LIST
   539 FF:12C3: 49 53 54 A0  	.byte	"IST",TK_LIST	; LIST
   540                        LBB_LOAD
   541 FF:12C7: 4F 41 44 97  	.byte	"OAD",TK_LOAD	; LOAD
   542                        LBB_LOCATE
   543 FF:12CB: 4F 43 41 54  	.BYTE 	"OCATE",TK_LOCATE ; LOCATE
       FF:12CF: 45 B1 
   544                        LBB_LOG
   545 FF:12D1: 4F 47 28 E0  	.byte	"OG(",TK_LOG	; LOG(
   546                        LBB_LOOP
   547 FF:12D5: 4F 4F 50 9D  	.byte	"OOP",TK_LOOP	; LOOP
   548 FF:12D9: 00           	.byte	$00
   549                        TAB_ASCM
   550                        LBB_MAX
   551 FF:12DA: 41 58 28 F3  	.byte	"AX(",TK_MAX	; MAX(
   552                        LBB_MIDS
   553 FF:12DE: 49 44 24 28  	.byte	"ID$(",TK_MIDS	; MID$(
       FF:12E2: FB 
   554                        LBB_MIN
   555 FF:12E3: 49 4E 28 F4  	.byte	"IN(",TK_MIN	; MIN(
   556                        LBB_MONITOR
   557 FF:12E7: 4F 4E 49 54  	.byte	"ONITOR",TK_MONITOR; MONITOR(
       FF:12EB: 4F 52 A8 
   558 FF:12EE: 00           	.byte	$00
   559                        TAB_ASCN
   560                        LBB_NEW
   561 FF:12EF: 45 57 A2     	.byte	"EW",TK_NEW		; NEW
   562                        LBB_NEXT
   563 FF:12F2: 45 58 54 82  	.byte	"EXT",TK_NEXT		; NEXT
   564                        LBB_NOISE
   565 FF:12F6: 4F 49 53 45  	.byte	"OISE",TK_NOISE		; NOISE
       FF:12FA: BC 
   566                        LBB_NOT
   567 FF:12FB: 4F 54 C6     	.byte	"OT",TK_NOT		; NOT
   568                        LBB_NULL
   569 FF:12FE: 55 4C 4C 94  	.byte	"ULL",TK_NULL	; NULL
   570 FF:1302: 00           	.byte	$00
   571                        TAB_ASCO
   572                        LBB_OFF
   573 FF:1303: 46 46 CA     	.byte	"FF",TK_OFF		; OFF
   574                        LBB_ON
   575 FF:1306: 4E 93        	.byte	"N",TK_ON		; ON
   576                        LBB_OPEN
   577 FF:1308: 50 45 4E A9  	.byte	"PEN",TK_OPEN		; OPEN
   578                        LBB_OR
   579 FF:130C: 52 D2        	.byte	"R",TK_OR		; OR
   580 FF:130E: 00           	.byte	$00
   581                        TAB_ASCP
   582                        LBB_PATTERN
   583 FF:130F: 41 54 54 45  	.byte	"ATTERN",TK_PATTERN	; PATTERN
       FF:1313: 52 4E B9 
   584                        LBB_PEEK
   585 FF:1316: 45 45 4B 28  	.byte	"EEK(",TK_PEEK	; PEEK(
       FF:131A: E6 
   586                        LBB_PI
  Sun Nov 21 2021 15:13                                                                                                Page 22


   587 FF:131B: 49 F5        	.byte	"I",TK_PI		; PI
   588                        LBB_PLOT
   589 FF:131D: 4C 4F 54 B8  	.byte	"LOT",TK_PLOT		; PLOT
   590                        LBB_POKE
   591 FF:1321: 4F 4B 45 9A  	.byte	"OKE",TK_POKE	; POKE
   592                        LBB_POS
   593 FF:1325: 4F 53 28 DD  	.byte	"OS(",TK_POS	; POS(
   594                        LBB_PRINT
   595 FF:1329: 52 49 4E 54  	.byte	"RINT",TK_PRINT	; PRINT
       FF:132D: 9E 
   596                        LBB_PUTN
   597 FF:132E: 55 54 23 AD  	.byte	"UT#",TK_PUTN	; PUTN
   598 FF:1332: 00           	.byte	$00
   599                        TAB_ASCR
   600                        LBB_READ
   601 FF:1333: 45 41 44 88  	.byte	"EAD",TK_READ	; READ
   602                        LBB_REM
   603 FF:1337: 45 4D 91     	.byte	"EM",TK_REM		; REM
   604                        LBB_RESTORE
   605 FF:133A: 45 53 54 4F  	.byte	"ESTORE",TK_RESTORE
       FF:133E: 52 45 8E 
   606                        					; RESTORE
   607                        LBB_RETURN
   608 FF:1341: 45 54 55 52  	.byte	"ETURN",TK_RETURN	; RETURN
       FF:1345: 4E 90 
   609                        LBB_RIGHTS
   610 FF:1347: 49 47 48 54  	.byte	"IGHT$(",TK_RIGHTS
       FF:134B: 24 28 FA 
   611                        					; RIGHT$(
   612                        LBB_RND
   613 FF:134E: 4E 44 28 DF  	.byte	"ND(",TK_RND	; RND(
   614                        LBB_RUN
   615 FF:1352: 55 4E 8C     	.byte	"UN",TK_RUN		; RUN
   616 FF:1355: 00           	.byte	$00
   617                        TAB_ASCS
   618                        LBB_SADD
   619 FF:1356: 41 44 44 28  	.byte	"ADD(",TK_SADD	; SADD(
       FF:135A: E8 
   620                        LBB_SAVE
   621 FF:135B: 41 56 45 98  	.byte	"AVE",TK_SAVE	; SAVE
   622                        LBB_SCNCLR
   623 FF:135F: 43 4E 43 4C  	.BYTE 	"CNCLR",TK_SCNCLR ; SCNCLR
       FF:1363: 52 B0 
   624                        LBB_SCREEN
   625 FF:1365: 43 52 45 45  	.BYTE 	"CREEN",TK_SCREEN ; SCREEN
       FF:1369: 4E B4 
   626                        LBB_SGN
   627 FF:136B: 47 4E 28 D8  	.byte	"GN(",TK_SGN	; SGN(
   628                        LBB_SIN
   629 FF:136F: 49 4E 28 E3  	.byte	"IN(",TK_SIN	; SIN(
   630                        LBB_SOUND
   631 FF:1373: 4F 55 4E 44  	.byte	"OUND",TK_SOUND	; SOUND
       FF:1377: BB 
   632                        LBB_SPC
   633 FF:1378: 50 43 28 C4  	.byte	"PC(",TK_SPC	; SPC(
   634                        LBB_SPEEK
   635 FF:137C: 50 45 45 4B  	.byte	"PEEK(",TK_SPEEK	; SPEEK
  Sun Nov 21 2021 15:13                                                                                                Page 23


       FF:1380: 28 E7 
   636                        LBB_SPOKE
   637 FF:1382: 50 4F 4B 45  	.byte	"POKE",TK_SPOKE	; SPOKE
       FF:1386: B3 
   638                        LBB_SPRDEF
   639 FF:1387: 50 52 44 45  	.byte	"PRDEF",TK_SPRDEF	; SPRDEF
       FF:138B: 46 B6 
   640                        LBB_SPRITE
   641 FF:138D: 50 52 49 54  	.byte	"PRITE",TK_SPRITE	; SPRITE
       FF:1391: 45 B5 
   642                        LBB_SPRSIZE
   643 FF:1393: 50 52 53 49  	.byte	"PRSIZE",TK_SPRSIZE	; SPRSIZE
       FF:1397: 5A 45 B7 
   644                        LBB_SQR
   645 FF:139A: 51 52 28 DE  	.byte	"QR(",TK_SQR	; SQR(
   646                        LBB_STEP
   647 FF:139E: 54 45 50 C7  	.byte	"TEP",TK_STEP	; STEP
   648                        LBB_STOP
   649 FF:13A2: 54 4F 50 92  	.byte	"TOP",TK_STOP	; STOP
   650                        LBB_STRS
   651 FF:13A6: 54 52 24 28  	.byte	"TR$(",TK_STRS	; STR$(
       FF:13AA: EA 
   652                        LBB_SWAP
   653 FF:13AB: 57 41 50 A5  	.byte	"WAP",TK_SWAP	; SWAP
   654                        LBB_SYS
   655 FF:13AF: 59 53 BA     	.byte	"YS",TK_SYS	; SYS
   656 FF:13B2: 00           	.byte	$00
   657                        TAB_ASCT
   658                        LBB_TAB
   659 FF:13B3: 41 42 28 C0  	.byte	"AB(",TK_TAB	; TAB(
   660                        LBB_TAN
   661 FF:13B7: 41 4E 28 E4  	.byte	"AN(",TK_TAN	; TAN(
   662                        LBB_THEN
   663 FF:13BB: 48 45 4E C5  	.byte	"HEN",TK_THEN	; THEN
   664                        LBB_TONE
   665 FF:13BF: 4F 4E 45 BD  	.byte	"ONE",TK_TONE		; TONE
   666                        LBB_TO
   667 FF:13C3: 4F C2        	.byte	"O",TK_TO		; TO
   668 FF:13C5: 00           	.byte	$00
   669                        TAB_ASCU
   670                        LBB_UCASES
   671 FF:13C6: 43 41 53 45  	.byte	"CASE$(",TK_UCASES
       FF:13CA: 24 28 ED 
   672                        					; UCASE$(
   673                        LBB_UNTIL
   674 FF:13CD: 4E 54 49 4C  	.byte	"NTIL",TK_UNTIL	; UNTIL
       FF:13D1: C8 
   675                        LBB_USR
   676 FF:13D2: 53 52 28 DB  	.byte	"SR(",TK_USR	; USR(
   677 FF:13D6: 00           	.byte	$00
   678                        TAB_ASCV
   679                        LBB_VAL
   680 FF:13D7: 41 4C 28 EB  	.byte	"AL(",TK_VAL	; VAL(
   681                        LBB_VPTR
   682 FF:13DB: 41 52 50 54  	.byte	"ARPTR(",TK_VPTR	; VARPTR(
       FF:13DF: 52 28 F8 
   683                        LBB_VIDST
  Sun Nov 21 2021 15:13                                                                                                Page 24


   684 FF:13E2: 49 44 53 54  	.byte	"IDST",TK_VIDST		; VIDST
       FF:13E6: F7 
   685                        LBB_VOICE
   686 FF:13E7: 4F 49 43 45  	.byte	"OICE",TK_VOICE		; VOICE
       FF:13EB: BF 
   687                        LBB_VOLUME
   688 FF:13EC: 4F 4C 55 4D  	.byte	"OLUME",TK_VOLUME	; VOLUME
       FF:13F0: 45 BE 
   689                        
   690 FF:13F2: 00           	.byte	$00
   691                        TAB_ASCW
   692                        LBB_WAIT
   693 FF:13F3: 41 49 54 96  	.byte	"AIT",TK_WAIT	; WAIT
   694                        LBB_WHILE
   695 FF:13F7: 48 49 4C 45  	.byte	"HILE",TK_WHILE	; WHILE
       FF:13FB: C9 
   696                        LBB_WIDTH
   697 FF:13FC: 49 44 54 48  	.byte	"IDTH",TK_WIDTH	; WIDTH
       FF:1400: A3 
   698 FF:1401: 00           	.byte	$00
   699                        TAB_POWR
   700 FF:1402: CF 00        	.byte	TK_POWER,$00	; ^
   701                        
   702                        ; new decode table for LIST
   703                        ; Table is ..
   704                        ; byte - keyword length, keyword first character
   705                        ; word - pointer to rest of keyword from dictionary
   706                        
   707                        ; note if length is 1 then the pointer is ignored
   708                        
   709                        LAB_KEYT
   710 FF:1404: 03 45        	.byte	3,'E'
   711 FF:1406: 5E 12        	.word	LBB_END		; END
   712 FF:1408: 03 46        	.byte	3,'F'
   713 FF:140A: 6B 12        	.word	LBB_FOR		; FOR
   714 FF:140C: 04 4E        	.byte	4,'N'
   715 FF:140E: F2 12        	.word	LBB_NEXT		; NEXT
   716 FF:1410: 04 44        	.byte	4,'D'
   717 FF:1412: 30 12        	.word	LBB_DATA		; DATA
   718 FF:1414: 09 44        	.byte	9,'D'
   719 FF:1416: 3D 12        	.word	LBB_DIRECTORY		; DIRECTORY
   720 FF:1418: 0A 44        	.byte	10,'D'
   721 FF:141A: 4D 12        	.word	LBB_DISKSTATUS		; DISKSTATUS
   722 FF:141C: 05 49        	.byte	5,'I'
   723 FF:141E: A5 12        	.word	LBB_INPUT		; INPUT
   724 FF:1420: 03 44        	.byte	3,'D'
   725 FF:1422: 3A 12        	.word	LBB_DIM		; DIM
   726 FF:1424: 04 52        	.byte	4,'R'
   727 FF:1426: 33 13        	.word	LBB_READ		; READ
   728 FF:1428: 03 4C        	.byte	3,'L'
   729 FF:142A: C0 12        	.word	LBB_LET		; LET
   730 FF:142C: 03 44        	.byte	3,'D'
   731 FF:142E: 34 12        	.word	LBB_DEC		; DEC
   732 FF:1430: 04 47        	.byte	4,'G'
   733 FF:1432: 7F 12        	.word	LBB_GOTO		; GOTO
   734 FF:1434: 03 52        	.byte	3,'R'
   735 FF:1436: 52 13        	.word	LBB_RUN		; RUN
  Sun Nov 21 2021 15:13                                                                                                Page 25


   736 FF:1438: 02 49        	.byte	2,'I'
   737 FF:143A: A0 12        	.word	LBB_IF		; IF
   738 FF:143C: 07 52        	.byte	7,'R'
   739 FF:143E: 3A 13        	.word	LBB_RESTORE		; RESTORE
   740 FF:1440: 05 47        	.byte	5,'G'
   741 FF:1442: 7A 12        	.word	LBB_GOSUB		; GOSUB
   742 FF:1444: 06 52        	.byte	6,'R'
   743 FF:1446: 41 13        	.word	LBB_RETURN		; RETURN
   744 FF:1448: 03 52        	.byte	3,'R'
   745 FF:144A: 37 13        	.word	LBB_REM		; REM
   746 FF:144C: 04 53        	.byte	4,'S'
   747 FF:144E: A2 13        	.word	LBB_STOP		; STOP
   748 FF:1450: 02 4F        	.byte	2,'O'
   749 FF:1452: 06 13        	.word	LBB_ON		; ON
   750 FF:1454: 04 4E        	.byte	4,'N'
   751 FF:1456: FE 12        	.word	LBB_NULL		; NULL
   752 FF:1458: 03 49        	.byte	3,'I'
   753 FF:145A: A2 12        	.word	LBB_INC		; INC
   754 FF:145C: 04 57        	.byte	4,'W'
   755 FF:145E: F3 13        	.word	LBB_WAIT		; WAIT
   756 FF:1460: 04 4C        	.byte	4,'L'
   757 FF:1462: C7 12        	.word	LBB_LOAD		; LOAD
   758 FF:1464: 04 53        	.byte	4,'S'
   759 FF:1466: 5B 13        	.word	LBB_SAVE		; SAVE
   760 FF:1468: 03 44        	.byte	3,'D'
   761 FF:146A: 37 12        	.word	LBB_DEF		; DEF
   762 FF:146C: 04 50        	.byte	4,'P'
   763 FF:146E: 21 13        	.word	LBB_POKE		; POKE
   764 FF:1470: 04 43        	.byte	4,'C'
   765 FF:1472: 0B 12        	.word	LBB_CALL		; CALL
   766 FF:1474: 02 44        	.byte	2,'D'
   767 FF:1476: 57 12        	.word	LBB_DO		; DO
   768 FF:1478: 04 4C        	.byte	4,'L'
   769 FF:147A: D5 12        	.word	LBB_LOOP		; LOOP
   770 FF:147C: 05 50        	.byte	5,'P'
   771 FF:147E: 29 13        	.word	LBB_PRINT		; PRINT
   772 FF:1480: 04 43        	.byte	4,'C'
   773 FF:1482: 27 12        	.word	LBB_CONT		; CONT
   774 FF:1484: 04 4C        	.byte	4,'L'
   775 FF:1486: C3 12        	.word	LBB_LIST		; LIST
   776 FF:1488: 05 43        	.byte	5,'C'
   777 FF:148A: 14 12        	.word	LBB_CLEAR		; CLEAR
   778 FF:148C: 03 4E        	.byte	3,'N'
   779 FF:148E: EF 12        	.word	LBB_NEW		; NEW
   780 FF:1490: 05 57        	.byte	5,'W'
   781 FF:1492: FC 13        	.word	LBB_WIDTH		; WIDTH
   782 FF:1494: 03 47        	.byte	3,'G'
   783 FF:1496: 77 12        	.word	LBB_GET		; GET
   784 FF:1498: 04 53        	.byte	4,'S'
   785 FF:149A: AB 13        	.word	LBB_SWAP		; SWAP
   786 FF:149C: 06 42        	.byte	6,'B'
   787 FF:149E: FD 11        	.word	LBB_BITSET		; BITSET
   788 FF:14A0: 06 42        	.byte	6,'B'
   789 FF:14A2: F7 11        	.word	LBB_BITCLR		; BITCLR
   790 FF:14A4: 07 4D        	.byte	7,'M'
   791 FF:14A6: E7 12        	.word	LBB_MONITOR	; MONITOR
   792 FF:14A8: 04 4F        	.byte	4,'O'
  Sun Nov 21 2021 15:13                                                                                                Page 26


   793 FF:14AA: 08 13        	.word	LBB_OPEN	; OPEN
   794 FF:14AC: 05 43        	.byte	5,'C'
   795 FF:14AE: 19 12        	.word	LBB_CLOSE		; CLOSE
   796 FF:14B0: 08 49        	.byte	8,'I'
   797 FF:14B2: 8A 12        	.word	LBB_IECINPUT	; IECINPUT
   798 FF:14B4: 09 49        	.byte	9,'I'
   799 FF:14B6: 92 12        	.word	LBB_IECOUTPUT	; IECOUTPUT
   800 FF:14B8: 04 50        	.byte	4,'P'
   801 FF:14BA: 2E 13        	.word	LBB_PUTN		; PUTN
   802 FF:14BC: 04 47        	.byte	4,'G'
   803 FF:14BE: 73 12        	.word	LBB_GETN		; GETN
   804 FF:14C0: 07 44        	.byte	7,'D'
   805 FF:14C2: 46 12        	.word	LBB_DISKCMD		; DISKCMD
   806 FF:14C4: 06 53        	.BYTE 	6,'S'
   807 FF:14C6: 5F 13        	.WORD 	LBB_SCNCLR		; SCNCLR
   808 FF:14C8: 06 4C        	.BYTE 	6,'L'
   809 FF:14CA: CB 12        	.WORD 	LBB_LOCATE		; LOCATE
   810 FF:14CC: 05 43        	.BYTE 	5,'C'
   811 FF:14CE: 1E 12        	.WORD 	LBB_COLOR		; COLOR
   812 FF:14D0: 05 53        	.BYTE 	5,'S'
   813 FF:14D2: 82 13        	.WORD 	LBB_SPOKE		; SPOKE
   814 FF:14D4: 06 53        	.BYTE 	6,'S'
   815 FF:14D6: 65 13        	.WORD 	LBB_SCREEN		; SCREEN
   816 FF:14D8: 06 53        	.BYTE 	6,'S'
   817 FF:14DA: 8D 13        	.WORD 	LBB_SPRITE		; SPRITE
   818 FF:14DC: 06 53        	.BYTE 	6,'S'
   819 FF:14DE: 87 13        	.WORD 	LBB_SPRDEF		; SPRDEF
   820 FF:14E0: 07 53        	.BYTE 	7,'S'
   821 FF:14E2: 93 13        	.WORD 	LBB_SPRSIZE		; SPRSIZE
   822 FF:14E4: 04 50        	.BYTE 	4,'P'
   823 FF:14E6: 1D 13        	.WORD 	LBB_PLOT		; PLOT
   824 FF:14E8: 07 50        	.BYTE 	7,'P'
   825 FF:14EA: 0F 13        	.WORD 	LBB_PATTERN		; PATTERN
   826 FF:14EC: 03 53        	.BYTE 	3,'S'
   827 FF:14EE: AF 13        	.WORD 	LBB_SYS			; SYS
   828 FF:14F0: 05 53        	.BYTE 	5,'S'
   829 FF:14F2: 73 13        	.WORD 	LBB_SOUND		; SOUND
   830 FF:14F4: 05 4E        	.BYTE 	5,'N'
   831 FF:14F6: F6 12        	.WORD 	LBB_NOISE		; NOISE
   832 FF:14F8: 04 54        	.BYTE 	4,'T'
   833 FF:14FA: BF 13        	.WORD 	LBB_TONE		; TONE
   834 FF:14FC: 06 56        	.BYTE 	6,'V'
   835 FF:14FE: EC 13        	.WORD 	LBB_VOLUME		; VOLUME
   836 FF:1500: 05 56        	.BYTE 	5,'V'
   837 FF:1502: E7 13        	.WORD 	LBB_VOICE		; VOICE
   838                        
   839                        ; secondary commands (can't start a statement)
   840                        
   841 FF:1504: 04 54        	.byte	4,'T'
   842 FF:1506: B3 13        	.word	LBB_TAB		; TAB
   843 FF:1508: 04 45        	.byte	4,'E'
   844 FF:150A: 5A 12        	.word	LBB_ELSE		; ELSE
   845 FF:150C: 02 54        	.byte	2,'T'
   846 FF:150E: C3 13        	.word	LBB_TO		; TO
   847 FF:1510: 02 46        	.byte	2,'F'
   848 FF:1512: 69 12        	.word	LBB_FN		; FN
   849 FF:1514: 04 53        	.byte	4,'S'
  Sun Nov 21 2021 15:13                                                                                                Page 27


   850 FF:1516: 78 13        	.word	LBB_SPC		; SPC
   851 FF:1518: 04 54        	.byte	4,'T'
   852 FF:151A: BB 13        	.word	LBB_THEN		; THEN
   853 FF:151C: 03 4E        	.byte	3,'N'
   854 FF:151E: FB 12        	.word	LBB_NOT		; NOT
   855 FF:1520: 04 53        	.byte	4,'S'
   856 FF:1522: 9E 13        	.word	LBB_STEP		; STEP
   857 FF:1524: 05 55        	.byte	5,'U'
   858 FF:1526: CD 13        	.word	LBB_UNTIL		; UNTIL
   859 FF:1528: 05 57        	.byte	5,'W'
   860 FF:152A: F7 13        	.word	LBB_WHILE		; WHILE
   861 FF:152C: 03 4F        	.byte	3,'O'
   862 FF:152E: 03 13        	.word	LBB_OFF		; OFF
   863                        
   864                        ; opperators
   865                        
   866 FF:1530: 01 2B        	.byte	1,'+'
   867 FF:1532: 00 00        	.word	$0000			; +
   868 FF:1534: 01 2D        	.byte	1,'-'
   869 FF:1536: 00 00        	.word	$0000			; -
   870 FF:1538: 01 2A        	.byte	1,'*'
   871 FF:153A: 00 00        	.word	$0000			; *
   872 FF:153C: 01 2F        	.byte	1,'/'
   873 FF:153E: 00 00        	.word	$0000			; /
   874 FF:1540: 01 5E        	.byte	1,'^'
   875 FF:1542: 00 00        	.word	$0000			; ^
   876 FF:1544: 03 41        	.byte	3,'A'
   877 FF:1546: E6 11        	.word	LBB_AND		; AND
   878 FF:1548: 03 45        	.byte	3,'E'
   879 FF:154A: 61 12        	.word	LBB_EOR		; EOR
   880 FF:154C: 02 4F        	.byte	2,'O'
   881 FF:154E: 0C 13        	.word	LBB_OR		; OR
   882 FF:1550: 02 3E        	.byte	2,'>'
   883 FF:1552: DC 11        	.word	LBB_RSHIFT		; >>
   884 FF:1554: 02 3C        	.byte	2,'<'
   885 FF:1556: D6 11        	.word	LBB_LSHIFT		; <<
   886 FF:1558: 01 3E        	.byte	1,'>'
   887 FF:155A: 00 00        	.word	$0000			; >
   888 FF:155C: 01 3D        	.byte	1,'='
   889 FF:155E: 00 00        	.word	$0000			; =
   890 FF:1560: 01 3C        	.byte	1,'<'
   891 FF:1562: 00 00        	.word	$0000			; <
   892                        
   893                        ; functions
   894                        
   895 FF:1564: 04 53        	.byte	4,'S'			;
   896 FF:1566: 6B 13        	.word	LBB_SGN		; SGN
   897 FF:1568: 04 49        	.byte	4,'I'			;
   898 FF:156A: AA 12        	.word	LBB_INT		; INT
   899 FF:156C: 04 41        	.byte	4,'A'			;
   900 FF:156E: E2 11        	.word	LBB_ABS		; ABS
   901 FF:1570: 04 55        	.byte	4,'U'			;
   902 FF:1572: D2 13        	.word	LBB_USR		; USR
   903 FF:1574: 04 46        	.byte	4,'F'			;
   904 FF:1576: 6E 12        	.word	LBB_FRE		; FRE
   905 FF:1578: 04 50        	.byte	4,'P'			;
   906 FF:157A: 25 13        	.word	LBB_POS		; POS
  Sun Nov 21 2021 15:13                                                                                                Page 28


   907 FF:157C: 04 53        	.byte	4,'S'			;
   908 FF:157E: 9A 13        	.word	LBB_SQR		; SQR
   909 FF:1580: 04 52        	.byte	4,'R'			;
   910 FF:1582: 4E 13        	.word	LBB_RND		; RND
   911 FF:1584: 04 4C        	.byte	4,'L'			;
   912 FF:1586: D1 12        	.word	LBB_LOG		; LOG
   913 FF:1588: 04 45        	.byte	4,'E'			;
   914 FF:158A: 64 12        	.word	LBB_EXP		; EXP
   915 FF:158C: 04 43        	.byte	4,'C'			;
   916 FF:158E: 2B 12        	.word	LBB_COS		; COS
   917 FF:1590: 04 53        	.byte	4,'S'			;
   918 FF:1592: 6F 13        	.word	LBB_SIN		; SIN
   919 FF:1594: 04 54        	.byte	4,'T'			;
   920 FF:1596: B7 13        	.word	LBB_TAN		; TAN
   921 FF:1598: 04 41        	.byte	4,'A'			;
   922 FF:159A: ED 11        	.word	LBB_ATN		; ATN
   923 FF:159C: 05 50        	.byte	5,'P'			;
   924 FF:159E: 16 13        	.word	LBB_PEEK		; PEEK
   925 FF:15A0: 06 53        	.BYTE 	6,'S'
   926 FF:15A2: 7C 13        	.WORD 	LBB_SPEEK		; SPEEK
   927 FF:15A4: 05 53        	.byte	5,'S'			;
   928 FF:15A6: 56 13        	.word	LBB_SADD		; SADD
   929 FF:15A8: 04 4C        	.byte	4,'L'			;
   930 FF:15AA: BC 12        	.word	LBB_LEN		; LEN
   931 FF:15AC: 05 53        	.byte	5,'S'			;
   932 FF:15AE: A6 13        	.word	LBB_STRS		; STR$
   933 FF:15B0: 04 56        	.byte	4,'V'			;
   934 FF:15B2: D7 13        	.word	LBB_VAL		; VAL
   935 FF:15B4: 04 41        	.byte	4,'A'			;
   936 FF:15B6: E9 11        	.word	LBB_ASC		; ASC
   937 FF:15B8: 07 55        	.byte	7,'U'			;
   938 FF:15BA: C6 13        	.word	LBB_UCASES		; UCASE$
   939 FF:15BC: 07 4C        	.byte	7,'L'			;
   940 FF:15BE: AF 12        	.word	LBB_LCASES		; LCASE$
   941 FF:15C0: 05 43        	.byte	5,'C'			;
   942 FF:15C2: 0F 12        	.word	LBB_CHRS		; CHR$
   943 FF:15C4: 05 48        	.byte	5,'H'			;
   944 FF:15C6: 84 12        	.word	LBB_HEXS		; HEX$
   945 FF:15C8: 05 42        	.byte	5,'B'			;
   946 FF:15CA: F2 11        	.word	LBB_BINS		; BIN$
   947 FF:15CC: 07 42        	.byte	7,'B'			;
   948 FF:15CE: 03 12        	.word	LBB_BITTST		; BITTST
   949 FF:15D0: 04 4D        	.byte	4,'M'			;
   950 FF:15D2: DA 12        	.word	LBB_MAX			; MAX
   951 FF:15D4: 04 4D        	.byte	4,'M'			;
   952 FF:15D6: E3 12        	.word	LBB_MIN			; MIN
   953 FF:15D8: 02 50        	.byte	2,'P'			;
   954 FF:15DA: 1B 13        	.word	LBB_PI			; PI
   955 FF:15DC: 05 49        	.byte	5,'I'			;
   956 FF:15DE: 9B 12        	.word	LBB_IECST		; IECST
   957 FF:15E0: 07 56        	.byte	7,'V'			;
   958 FF:15E2: E2 13        	.word	LBB_VIDST		; VIDST
   959 FF:15E4: 05 56        	.byte	5,'V'			;
   960 FF:15E6: DB 13        	.word	LBB_VPTR		; VARPTR
   961 FF:15E8: 06 4C        	.byte	6,'L'			;
   962 FF:15EA: B6 12        	.word	LBB_LEFTS		; LEFT$
   963 FF:15EC: 07 52        	.byte	7,'R'			;
  Sun Nov 21 2021 15:13                                                                                                Page 29


   964 FF:15EE: 47 13        	.word	LBB_RIGHTS		; RIGHT$
   965 FF:15F0: 05 4D        	.byte	5,'M'			;
   966 FF:15F2: DE 12        	.word	LBB_MIDS		; MID$
   967 FF:15F4: 04 43        	.byte	4,'C'			;
   968 FF:15F6: 23 12        	.word	LBB_CON			; CON
    45                        
    46                        ; DEFINITIONS
    47                        	INCLUDE 'DEFINITIONS.ASM'
     1             000000FF   PROGRAMBANK	.EQU $FF		; BANK THAT THE INTREPRETER LIVES IN
     2             00000002   DATABANK	.EQU $02		; BANK THAT THE DATA LIVES IN
     3                        
     4             00001000   FNBUFFER    .EQU $001000    ; FILE NAME BUFFER, MUST BE IN ZERO BANK!
     5                        
     6                        
     7                        
     8                        ; offsets from a base of X or Y
     9                        
    10             00000000   PLUS_0		.EQU $00		; X or Y plus 0
    11             00000001   PLUS_1		.EQU $01		; X or Y plus 1
    12             00000002   PLUS_2		.EQU $02		; X or Y plus 2
    13             00000003   PLUS_3		.EQU $03		; X or Y plus 3
    14                        
    15             00004000   STACK_BOTTOM	.EQU $4000	; stack bottom, no offset
    16             00007FFF   STACK   		.EQU $7FFF	; stack top, no offset
    17                        
    18             00000200   ccflag		.EQU $000200	; BASIC CTRL-C flag, 00 = enabled, 01 = dis
    19             00000201   ccbyte		.EQU ccflag+1	; BASIC CTRL-C byte
    20             00000202   ccnull		.EQU ccbyte+1	; BASIC CTRL-C byte timeout
    21                        
    22             00000203   VEC_CC		.EQU ccnull+1	; ctrl c check vector
    23                        
    24                        
    25                        ; Ibuffs can now be anywhere in RAM AS LONG AS IT IS BEFORE RAM_BASE AND IS NOT PAGE ALIGNED!, ens
                    ure that the max length is < $80
    26                        
    27                            IF PROGRAMBANK=DATABANK
    28                        Ibuffs		.EQU  (ENDOFBASIC&$FF00)+$181
    29                            ELSE
    30             00002181   Ibuffs		.EQU  $2000+$181
    31             00022181   LIbuffs		.EQU  (DATABANK*$10000)+$2000+$181
    32                            ENDIF
    33             000021D1   Ibuffe		.EQU Ibuffs+80; end of input buffer
    34                        
    35             00002200   Ram_base	.EQU ((Ibuffe+1)&$FF00)+$100	    ; start of user RAM (set as needed, should be page a
                    ligned)
    36             0000FF00   Ram_top		.EQU $FF00						; end of user RAM+1 (set
                     as needed, should be page aligned)
    48                        
    49                        ; MESSAGES
    50                        	INCLUDE 'MESSAGES.ASM'
     1                        
     2                        LAB_CONMSG:
     3 FF:15F8: 80 80 80 83  	.byte	$80,$80,$80,$83,$84,$85,"  Werner Engineering 816",$0D
       FF:15FC: 84 85 20 20 
       FF:1600: 57 65 72 6E 
       FF:1604: 65 72 20 45 
       FF:1608: 6E 67 69 6E 
  Sun Nov 21 2021 15:13                                                                                                Page 30


       FF:160C: 65 65 72 69 
       FF:1610: 6E 67 20 38 
       FF:1614: 31 36 0D 
     4 FF:1617: 81 81 81 83  	.byte	$81,$81,$81,$83,$84,$85,"  Enhanced BASIC 65816 2.3",$0D
       FF:161B: 84 85 20 20 
       FF:161F: 45 6E 68 61 
       FF:1623: 6E 63 65 64 
       FF:1627: 20 42 41 53 
       FF:162B: 49 43 20 36 
       FF:162F: 35 38 31 36 
       FF:1633: 20 32 2E 33 
       FF:1637: 0D 
     5 FF:1638: 82 82 82 83  	.byte	$82,$82,$82,$83,$84,$85,00
       FF:163C: 84 85 00 
     6                        
     7                        LAB_SMSG:
     8 FF:163F: 20 42 79 74  	.byte	" Bytes free",$00
       FF:1643: 65 73 20 66 
       FF:1647: 72 65 65 00 
     9                        LAB_SMSG1
    10 FF:164B: 0D 0A 45 6E  	.byte	$0D,$0A,"Enhanced BASIC 65816 2.3",$00
       FF:164F: 68 61 6E 63 
       FF:1653: 65 64 20 42 
       FF:1657: 41 53 49 43 
       FF:165B: 20 36 35 38 
       FF:165F: 31 36 20 32 
       FF:1663: 2E 33 00 
    11 FF:1666: 0D 0A 44 45  	.byte	$0D,$0A,"DERIVED FROM ehBASIC BY LEE DAVIDSON",$00
       FF:166A: 52 49 56 45 
       FF:166E: 44 20 46 52 
       FF:1672: 4F 4D 20 65 
       FF:1676: 68 42 41 53 
       FF:167A: 49 43 20 42 
       FF:167E: 59 20 4C 45 
       FF:1682: 45 20 44 41 
       FF:1686: 56 49 44 53 
       FF:168A: 4F 4E 00 
    12                        
    13                        ; BASIC messages, mostly error messages
    14                        
    15                        LAB_BAER
    16 FF:168D: B1 16        	.word	ERR_NF		;$00 NEXT without FOR
    17 FF:168F: C2 16        	.word	ERR_SN		;$02 syntax
    18 FF:1691: C9 16        	.word	ERR_RG		;$04 RETURN without GOSUB
    19 FF:1693: DE 16        	.word	ERR_OD		;$06 out of data
    20 FF:1695: EA 16        	.word	ERR_FC		;$08 function call
    21 FF:1697: F8 16        	.word	ERR_OV		;$0A overflow
    22 FF:1699: 01 17        	.word	ERR_OM		;$0C out of memory
    23 FF:169B: 0F 17        	.word	ERR_US		;$0E undefined statement
    24 FF:169D: 23 17        	.word	ERR_BS		;$10 array bounds
    25 FF:169F: 30 17        	.word	ERR_DD		;$12 double dimension array
    26 FF:16A1: 41 17        	.word	ERR_D0		;$14 divide by 0
    27 FF:16A3: 50 17        	.word	ERR_ID		;$16 illegal direct
    28 FF:16A5: 5F 17        	.word	ERR_TM		;$18 type mismatch
    29 FF:16A7: 6D 17        	.word	ERR_LS		;$1A long string
    30 FF:16A9: 7D 17        	.word	ERR_ST		;$1C string too complex
    31 FF:16AB: 90 17        	.word	ERR_CN		;$1E continue error
  Sun Nov 21 2021 15:13                                                                                                Page 31


    32 FF:16AD: 9F 17        	.word	ERR_UF		;$20 undefined function
    33 FF:16AF: B2 17        	.word ERR_LD		;$22 LOOP without DO
    34                        
    35 FF:16B1: 4E 45 58 54  ERR_NF	.byte	"NEXT without FOR",$00
       FF:16B5: 20 77 69 74 
       FF:16B9: 68 6F 75 74 
       FF:16BD: 20 46 4F 52 
       FF:16C1: 00 
    36 FF:16C2: 53 79 6E 74  ERR_SN	.byte	"Syntax",$00
       FF:16C6: 61 78 00 
    37 FF:16C9: 52 45 54 55  ERR_RG	.byte	"RETURN without GOSUB",$00
       FF:16CD: 52 4E 20 77 
       FF:16D1: 69 74 68 6F 
       FF:16D5: 75 74 20 47 
       FF:16D9: 4F 53 55 42 
       FF:16DD: 00 
    38 FF:16DE: 4F 75 74 20  ERR_OD	.byte	"Out of DATA",$00
       FF:16E2: 6F 66 20 44 
       FF:16E6: 41 54 41 00 
    39 FF:16EA: 46 75 6E 63  ERR_FC	.byte	"Function call",$00
       FF:16EE: 74 69 6F 6E 
       FF:16F2: 20 63 61 6C 
       FF:16F6: 6C 00 
    40 FF:16F8: 4F 76 65 72  ERR_OV	.byte	"Overflow",$00
       FF:16FC: 66 6C 6F 77 
       FF:1700: 00 
    41 FF:1701: 4F 75 74 20  ERR_OM	.byte	"Out of memory",$00
       FF:1705: 6F 66 20 6D 
       FF:1709: 65 6D 6F 72 
       FF:170D: 79 00 
    42 FF:170F: 55 6E 64 65  ERR_US	.byte	"Undefined statement",$00
       FF:1713: 66 69 6E 65 
       FF:1717: 64 20 73 74 
       FF:171B: 61 74 65 6D 
       FF:171F: 65 6E 74 00 
    43 FF:1723: 41 72 72 61  ERR_BS	.byte	"Array bounds",$00
       FF:1727: 79 20 62 6F 
       FF:172B: 75 6E 64 73 
       FF:172F: 00 
    44 FF:1730: 44 6F 75 62  ERR_DD	.byte	"Double dimension",$00
       FF:1734: 6C 65 20 64 
       FF:1738: 69 6D 65 6E 
       FF:173C: 73 69 6F 6E 
       FF:1740: 00 
    45 FF:1741: 44 69 76 69  ERR_D0	.byte	"Divide by zero",$00
       FF:1745: 64 65 20 62 
       FF:1749: 79 20 7A 65 
       FF:174D: 72 6F 00 
    46 FF:1750: 49 6C 6C 65  ERR_ID	.byte	"Illegal direct",$00
       FF:1754: 67 61 6C 20 
       FF:1758: 64 69 72 65 
       FF:175C: 63 74 00 
    47 FF:175F: 54 79 70 65  ERR_TM	.byte	"Type mismatch",$00
       FF:1763: 20 6D 69 73 
       FF:1767: 6D 61 74 63 
       FF:176B: 68 00 
    48 FF:176D: 53 74 72 69  ERR_LS	.byte	"String too long",$00
  Sun Nov 21 2021 15:13                                                                                                Page 32


       FF:1771: 6E 67 20 74 
       FF:1775: 6F 6F 20 6C 
       FF:1779: 6F 6E 67 00 
    49 FF:177D: 53 74 72 69  ERR_ST	.byte	"String too complex",$00
       FF:1781: 6E 67 20 74 
       FF:1785: 6F 6F 20 63 
       FF:1789: 6F 6D 70 6C 
       FF:178D: 65 78 00 
    50 FF:1790: 43 61 6E 27  ERR_CN	.byte	"Can't continue",$00
       FF:1794: 74 20 63 6F 
       FF:1798: 6E 74 69 6E 
       FF:179C: 75 65 00 
    51 FF:179F: 55 6E 64 65  ERR_UF	.byte	"Undefined function",$00
       FF:17A3: 66 69 6E 65 
       FF:17A7: 64 20 66 75 
       FF:17AB: 6E 63 74 69 
       FF:17AF: 6F 6E 00 
    52 FF:17B2: 4C 4F 4F 50  ERR_LD	.byte	"LOOP without DO",$00
       FF:17B6: 20 77 69 74 
       FF:17BA: 68 6F 75 74 
       FF:17BE: 20 44 4F 00 
    53                        
    54 FF:17C2: 0D 0A 42 72  LAB_BMSG	.byte	$0D,$0A,"Break",$00
       FF:17C6: 65 61 6B 00 
    55 FF:17CA: 20 45 72 72  LAB_EMSG	.byte	" Error",$00
       FF:17CE: 6F 72 00 
    56 FF:17D1: 20 69 6E 20  LAB_LMSG	.byte	" in line ",$00
       FF:17D5: 6C 69 6E 65 
       FF:17D9: 20 00 
    57 FF:17DB: 0D 0A 52 65  LAB_RMSG	.byte	$0D,$0A,"Ready",$0D,$0A,$00
       FF:17DF: 61 64 79 0D 
       FF:17E3: 0A 00 
    58                        
    59 FF:17E5: 20 45 78 74  LAB_IMSG	.byte	" Extra ignored",$0D,$0A,$00
       FF:17E9: 72 61 20 69 
       FF:17ED: 67 6E 6F 72 
       FF:17F1: 65 64 0D 0A 
       FF:17F5: 00 
    60 FF:17F6: 20 52 65 64  LAB_REDO	.byte	" Redo from start",$0D,$0A,$00
       FF:17FA: 6F 20 66 72 
       FF:17FE: 6F 6D 20 73 
       FF:1802: 74 61 72 74 
       FF:1806: 0D 0A 00 
    61 FF:1809: 20 49 2F 4F  LAB_IOER	.byte	" I/O Error",$0D,$0A,$00
       FF:180D: 20 45 72 72 
       FF:1811: 6F 72 0D 0A 
       FF:1815: 00 
    51                        
    52                        ; NUMERIC CONSTANTS
    53                        	INCLUDE 'NUMCONST.ASM'
     1                        ; numeric constants and series
     2                        					; constants and series for LOG(n)
     3                        LAB_25A0
     4 FF:1816: 02           	.byte	$02			; counter
     5 FF:1817: 80 19 56 62  	.byte	$80,$19,$56,$62	; 0.59898
     6 FF:181B: 80 76 22 F3  	.byte	$80,$76,$22,$F3	; 0.96147
     7 FF:181F: 82 38 AA 40  	.byte	$82,$38,$AA,$40	; 2.88539
  Sun Nov 21 2021 15:13                                                                                                Page 33


     8                        
     9                        LAB_25AD
    10 FF:1823: 80 35 04 F3  	.byte	$80,$35,$04,$F3	; 0.70711	1/root 2
    11                        LAB_25B1
    12 FF:1827: 81 35 04 F3  	.byte	$81,$35,$04,$F3	; 1.41421	root 2
    13                        LAB_25B5
    14 FF:182B: 80 80 00 00  	.byte	$80,$80,$00,$00	; -0.5
    15                        LAB_25B9
    16 FF:182F: 80 31 72 18  	.byte	$80,$31,$72,$18	; 0.69315	LOG(2)
    17                        
    18                        					; numeric PRINT constants
    19                        LAB_2947
    20 FF:1833: 91 43 4F F8  	.byte	$91,$43,$4F,$F8	; 99999.9375 (max value with at least one decimal)
    21                        LAB_294B
    22 FF:1837: 94 74 23 F7  	.byte	$94,$74,$23,$F7	; 999999.4375 (max value before scientific notation)
    23                        LAB_294F
    24 FF:183B: 94 74 24 00  	.byte	$94,$74,$24,$00	; 1000000
    25                        
    26                        					; EXP(n) constants and series
    27                        LAB_2AFA
    28 FF:183F: 81 38 AA 3B  	.byte	$81,$38,$AA,$3B	; 1.4427	(1/LOG base 2 e)
    29                        LAB_2AFE
    30 FF:1843: 06           	.byte	$06			; counter
    31 FF:1844: 74 63 90 8C  	.byte	$74,$63,$90,$8C	; 2.17023e-4
    32 FF:1848: 77 23 0C AB  	.byte	$77,$23,$0C,$AB	; 0.00124
    33 FF:184C: 7A 1E 94 00  	.byte	$7A,$1E,$94,$00	; 0.00968
    34 FF:1850: 7C 63 42 80  	.byte	$7C,$63,$42,$80	; 0.05548
    35 FF:1854: 7E 75 FE D0  	.byte	$7E,$75,$FE,$D0	; 0.24023
    36 FF:1858: 80 31 72 15  	.byte	$80,$31,$72,$15	; 0.69315
    37 FF:185C: 81 00 00 00  	.byte	$81,$00,$00,$00	; 1.00000
    38                        
    39                        					; trigonometric constants and series
    40                        LAB_2C78
    41 FF:1860: 81 49 0F DB  	.byte	$81,$49,$0F,$DB	; 1.570796371 (pi/2) as floating #
    42                        LAB_2C84
    43 FF:1864: 04           	.byte	$04			; counter
    44 FF:1865: 86 1E D7 FB  	.byte	$86,$1E,$D7,$FB	; 39.7109
    45 FF:1869: 87 99 26 65  	.byte	$87,$99,$26,$65	;-76.575
    46 FF:186D: 87 23 34 58  	.byte	$87,$23,$34,$58	; 81.6022
    47 FF:1871: 86 A5 5D E1  	.byte	$86,$A5,$5D,$E1	;-41.3417
    48                        LAB_2C7C
    49 FF:1875: 83 49 0F DB  	.byte	$83,$49,$0F,$DB	; 6.28319 (2*pi) as floating #
    50                        
    51                        LAB_2CC9
    52 FF:1879: 08           	.byte	$08			; counter
    53 FF:187A: 78 3A C5 37  	.byte	$78,$3A,$C5,$37	; 0.00285
    54 FF:187E: 7B 83 A2 5C  	.byte	$7B,$83,$A2,$5C	;-0.0160686
    55 FF:1882: 7C 2E DD 4D  	.byte	$7C,$2E,$DD,$4D	; 0.0426915
    56 FF:1886: 7D 99 B0 1E  	.byte	$7D,$99,$B0,$1E	;-0.0750429
    57 FF:188A: 7D 59 ED 24  	.byte	$7D,$59,$ED,$24	; 0.106409
    58 FF:188E: 7E 91 72 00  	.byte	$7E,$91,$72,$00	;-0.142036
    59 FF:1892: 7E 4C B9 73  	.byte	$7E,$4C,$B9,$73	; 0.199926
    60 FF:1896: 7F AA AA 53  	.byte	$7F,$AA,$AA,$53	;-0.333331
    61                        
    62             00FF189B   LAB_1D96	.EQU *+1			; $00,$00 used for undefined variables
    63                        LAB_259C
    64 FF:189A: 81 00 00 00  	.byte	$81,$00,$00,$00	; 1.000000, used for INC
  Sun Nov 21 2021 15:13                                                                                                Page 34


    65                        LAB_2AFD
    66 FF:189E: 81 80 00 00  	.byte	$81,$80,$00,$00	; -1.00000, used for DEC. must be on the same page as +1.00
    67                        
    68                        					; misc constants
    69                        LAB_1DF7
    70 FF:18A2: 90           	.byte	$90			;-32768 (uses first three bytes from 0.5)
    71                        LAB_2A96
    72 FF:18A3: 80 00 00 00  	.byte	$80,$00,$00,$00	; 0.5
    73                        LAB_2C80
    74 FF:18A7: 7F 00 00 00  	.byte	$7F,$00,$00,$00	; 0.25
    75                        LAB_26B5
    76 FF:18AB: 84 20 00 00  	.byte	$84,$20,$00,$00	; 10.0000 divide by 10 constant
    77                        
    78                        ; This table is used in converting numbers to ASCII.
    79                        
    80                        LAB_2A9A
    81             00FF18B0   LAB_2A9B .EQU LAB_2A9A+1
    82             00FF18B1   LAB_2A9C .EQU LAB_2A9B+1
    83 FF:18AF: FE 79 60     	.byte	$FE,$79,$60		; -100000
    84 FF:18B2: 00 27 10     	.byte	$00,$27,$10		; 10000
    85 FF:18B5: FF FC 18     	.byte	$FF,$FC,$18		; -1000
    86 FF:18B8: 00 00 64     	.byte	$00,$00,$64		; 100
    87 FF:18BB: FF FF F6     	.byte	$FF,$FF,$F6		; -10
    88 FF:18BE: 00 00 01     	.byte	$00,$00,$01		; 1
    54                        
    55                        ; I/O VECTORS
    56                        	INCLUDE 'IOVECT.ASM'
     1                        ;__________________________________________________________
     2                        ;
     3                        ; BIOS JUMP TABLE (NATIVE)
     4                        ;__________________________________________________________
     5             0000FD00   LPRINTVEC        .EQU    $00FD00
     6             0000FD04   LINPVEC          .EQU    $00FD04
     7             0000FD08   LINPWVEC         .EQU    $00FD08
     8             0000FD0C   LSetXYVEC        .EQU    $00FD0C
     9             0000FD10   LCPYVVEC         .EQU    $00FD10
    10             0000FD14   LSrlUpVEC        .EQU    $00FD14
    11             0000FD18   LSetColorVEC     .EQU    $00FD18                        :
    12             0000FD1C   LCURSORVEC       .EQU    $00FD1C
    13             0000FD20   LUNCURSORVEC     .EQU    $00FD20
    14             0000FD24   LWRITERTC        .EQU    $00FD24
    15             0000FD28   LREADRTC         .EQU    $00FD28
    16             0000FD2C   LIECIN           .EQU    $00FD2C
    17             0000FD30   LIECOUT          .EQU    $00FD30
    18             0000FD34   LUNTALK          .EQU    $00FD34
    19             0000FD38   LUNLSTN          .EQU    $00FD38
    20             0000FD3C   LLISTEN          .EQU    $00FD3C
    21             0000FD40   LTALK            .EQU    $00FD40
    22             0000FD44   LSETLFS          .EQU    $00FD44
    23             0000FD48   LSETNAM          .EQU    $00FD48
    24             0000FD4C   LLOAD            .EQU    $00FD4C
    25             0000FD50   LSAVE            .EQU    $00FD50
    26             0000FD54   LIECINIT         .EQU    $00FD54
    27             0000FD58   LIECCLCH         .EQU    $00FD58                ; close input and output channels
    28             0000FD5C   LIECOUTC         .EQU    $00FD5C                ; open a channel for output
    29             0000FD60   LIECINPC         .EQU    $00FD60                ; open a channel for input
    30             0000FD64   LIECOPNLF        .EQU    $00FD64                ; open a logical file
  Sun Nov 21 2021 15:13                                                                                                Page 35


    31             0000FD68   LIECCLSLF        .EQU    $00FD68                ; close a specified logical file
    32             0000FD6C   LClearScrVec     .EQU    $00FD6C                ; clear the 9918 Screen
    33             0000FD70   LLOADFONTVec     .EQU    $00FD70                ; load the 9918 font
    34                        
    35                        
    36             00000330   CSRX           	.EQU $0330 			; CURRENT X POSITION
    37             00000331   CSRY           	.EQU $0331 			; CURRENT Y POSITION
    38             00000341   ConsoleDevice	.EQU    $0341		; Current Console Device
    39             00000343   VIDEOWIDTH	    .EQU    $0343
    40             00000344   SpriteAttrs	    .EQU    $0344
    41             00000345   SpritePatterns  .EQU    $0345
    42             00000317   IECSTW			.equ 	$000317
    43             0000031F   IECMSGM			.equ 	$00031F         ; message mode flag,
    44                        					        ; $C0 = both control and kernal messages,
    45                        					        ; $80 = control messages only,
    46                        					        ; $40 = kernal messages only,
    47                        					        ; $00 = neither control or kernal messages
    48             00000322   LOADBUFL		.equ 	$000322		; IEC buffer Pointer
    49             00000323   LOADBUFH		.equ 	LOADBUFL+1
    50             00000324   LOADBANK		.equ 	LOADBUFL+2	; BANK buffer Pointer
    51             0000031D   IECSTRTL		.equ 	$00031D		; IEC Start Address Pointer
    52             0000031E   IECSTRTH		.equ 	IECSTRTL+1
    53             000003D0   LINEFLGS        .EQU $03D0          		; 24 BYTES OF LINE POINTERS (3D0 - 3E9 , one ext
                    ra for scrolling)
    54                        
    55             0000FE0B   CMDP:			.EQU 	$FE0B 		; 	VDP COMMAND port
    56             0000FE0A   DATAP:			.EQU 	$FE0A 		; 	VDP Data port
    57                        
    58                        ;__________________________________________________________
    59                        
    60                        
    61                        
    62                        
    63                        ;___V_INPT_________________________________________________
    64                        ;
    65                        ; MAKE A BIOS CALL TO GET NON-BLOCKING CHARACTER INPUT
    66                        ; THIS COULD BE SERIAL OR KEYBOARD DEPENDING ON BIOS SETTING
    67                        ; RETURNS
    68                        ;   A: CHARACTER
    69                        ;      CARRY SET IF NO CHARACTER
    70                        ;
    71                        ;
    72                        ;   NOTE THAT BIOS IS IN BANK 0, SO A LONG BRANCH IS REQUIRED
    73                        ;__________________________________________________________
    74                        V_INPT:
    75 FF:18C1: 8B               PHB
    76 FF:18C2: 0B               PHD
    77 FF:18C3: DA               PHX
    78 FF:18C4: A2 00            LDX #$00
    79 FF:18C6: DA               PHX
    80 FF:18C7: AB               PLB
    81 FF:18C8: 22 04 FD 00  	JSL LINPVEC		; INCHAR
    82 FF:18CC: FA               PLX
    83 FF:18CD: 2B               PLD
    84 FF:18CE: AB               PLB
    85 FF:18CF: 60               RTS
    86                        
  Sun Nov 21 2021 15:13                                                                                                Page 36


    87                        ;___V_OUTP_________________________________________________
    88                        ;
    89                        ; MAKE A BIOS CALL TO SEND CHARACTER TO OUTPUT
    90                        ; THIS COULD BE SERIAL OR TMS9918 CHARACTER DISPLAY
    91                        ;
    92                        ;   A: CHARACTER
    93                        ;
    94                        ;
    95                        ;   NOTE THAT BIOS IS IN BANK 0, SO A LONG BRANCH IS REQUIRED
    96                        ;__________________________________________________________
    97                        
    98                        V_OUTP:				; send byte to output device
    99 FF:18D0: 8B               PHB
   100 FF:18D1: 0B               PHD
   101 FF:18D2: DA               PHX
   102 FF:18D3: A6 06            LDX <VIDEOMODE
   103 FF:18D5: E0 02            CPX #2
   104 FF:18D7: D0 08            BNE V_OUTP1
   105 FF:18D9: A2 00            LDX #$00
   106 FF:18DB: DA               PHX
   107 FF:18DC: AB               PLB
   108 FF:18DD: 22 00 FD 00  	JSL LPRINTVEC	; OUTCHAR
   109                        V_OUTP1:
   110 FF:18E1: FA               PLX
   111 FF:18E2: 2B               PLD
   112 FF:18E3: AB               PLB
   113 FF:18E4: 60               RTS
   114                        
   115                        
   116                                .include 'diskcmds.asm'
     1                        ;___V_SAVE_________________________________________________
     2                        ;
     3                        ; UTILIZE BIOS TO SAVE BASIC RAM
     4                        ;
     5                        ; STORE CONTENTS IN RAM FROM "Smeml/h" TO "Svarl/h"-1 IN BANK "DATABANK"
     6                        ;
     7                        ; BASIC COMMAND EXPECTS ONE STRING VAR (FILENAME) AND ONE NUMERIC VAR (DEVICE)
     8                        ; THIS IS NATIVE '816 CODE
     9                        ;__________________________________________________________
    10                        V_SAVE:					; save BASIC program
    11 FF:18E5: 20 02 34             jsr LAB_EVEX        ; GET THE FIRST PARAMETER
    12 FF:18E8: A5 5F                lda <Dtypef         ; IS IT A STRING?
    13 FF:18EA: D0 08                bne V_SAVE_GO       ; YES, CONTINUE ON
    14                        V_SAVE_ERR:
    15 FF:18EC: A2 02                ldx #$02            ; NOPE, SYNTAX ERROR
    16 FF:18EE: 20 C1 28             jsr LAB_XERR
    17 FF:18F1: 4C B2 29             JMP LAB_1319        ; RESET VARS, STACK AND RETURN CONTROL TO BASIC
    18                        V_SAVE_GO:
    19 FF:18F4: 22 54 FD 00          JSL LIECINIT        ; INIT IEC BUS
    20 FF:18F8: A9 C0                lda #$C0
    21 FF:18FA: 8F 1F 03 00          sta >IECMSGM
    22 FF:18FE: A0 00                ldy #$00
    23                        V_SAVE_1:
    24                                LDAINDIRECTY ssptr_l
+   24 FF:1900: 8B               PHB
+   24 FF:1901: DA           	PHX
+   24 FF:1902: A2 01            LDX #$01
  Sun Nov 21 2021 15:13                                                                                                Page 37


+   24 FF:1904: B5 B8            LDA <ssptr_l,X
+   24 FF:1906: C9 00            CMP #$00
+   24 FF:1908: D0 04            BNE *+6
+   24 FF:190A: A2 00        	LDX #00
+   24 FF:190C: DA           	PHX
+   24 FF:190D: AB           	PLB
+   24 FF:190E: FA               PLX
+   24 FF:190F: B1 B8        	LDA	(<ssptr_l),Y		;
+   24 FF:1911: 85 04            STA <TMPFLG
+   24 FF:1913: AB               PLB
+   24 FF:1914: A5 04            LDA <TMPFLG
    25 FF:1916: BB                   TYX
    26 FF:1917: 9F 00 10 00          STA >FNBUFFER,X
    27 FF:191B: C9 00                CMP #$00
    28 FF:191D: F0 07                beq V_SAVE_2
    29 FF:191F: C9 22                cmp #'"'
    30 FF:1921: F0 03                beq V_SAVE_2
    31 FF:1923: C8                   iny
    32 FF:1924: D0 DA                bne V_SAVE_1
    33                        V_SAVE_2:
    34 FF:1926: 98                   TYA             ; fn length
    35 FF:1927: A2 00                ldx #<FNBUFFER
    36 FF:1929: A0 10                ldy #>FNBUFFER
    37 FF:192B: 8B                   PHB
    38                                SETBANK 0
+   38 FF:192C: DA               PHX
+   38 FF:192D: A2 00        	LDX #0
+   38 FF:192F: DA           	PHX
+   38 FF:1930: AB           	PLB
+   38 FF:1931: FA               PLX
    39 FF:1932: 22 48 FD 00          JSL LSETNAM     ; setnam
    40 FF:1936: AB                   PLB
    41 FF:1937: 20 24 35             JSR	LAB_1C01    ; GET THE SECOND PARAMETER (AFTER ',') OR SYN ERR
    42 FF:193A: 20 9E 40             JSR	LAB_GTBY    ; GET THE SECOND PARAMETER, RETURN IN X
    43 FF:193D: A0 01                ldy#1           ; secondary address
    44 FF:193F: 8B                   PHB
    45                                SETBANK 0
+   45 FF:1940: DA               PHX
+   45 FF:1941: A2 00        	LDX #0
+   45 FF:1943: DA           	PHX
+   45 FF:1944: AB           	PLB
+   45 FF:1945: FA               PLX
    46 FF:1946: 22 44 FD 00          jsL LSETLFS
    47 FF:194A: A5 7A                lda <Smemh
    48 FF:194C: 8D 1E 03             sta IECSTRTH
    49 FF:194F: A5 79                lda <Smeml
    50 FF:1951: 8D 1D 03             sta IECSTRTL
    51 FF:1954: A5 7B                lda <Svarl
    52 FF:1956: 8D 22 03             sta LOADBUFL
    53 FF:1959: A5 7C                lda <Svarh
    54 FF:195B: 8D 23 03             sta LOADBUFH
    55 FF:195E: A9 02                lda #DATABANK
    56 FF:1960: 8D 24 03             sta LOADBANK
    57 FF:1963: 22 50 FD 00          jsL LSAVE
    58 FF:1967: AB                   PLB
    59 FF:1968: A9 DB                LDA	#<LAB_RMSG		; point to "Ready" message low byte
    60 FF:196A: A0 17                LDY	#>LAB_RMSG		; point to "Ready" message high byte
  Sun Nov 21 2021 15:13                                                                                                Page 38


    61 FF:196C: 20 85 31             JSR	LAB_18C3
    62 FF:196F: 4C B2 29             JMP LAB_1319        ; RESET VARS, STACK AND RETURN CONTROL TO BASIC
    63                        
    64                        
    65                        
    66                        
    67                        ;___V_LOAD_________________________________________________
    68                        ;
    69                        ; UTILIZE BIOS TO LOAD BASIC RAM
    70                        ;
    71                        ; LOAD CONTENTS TO RAM "Smeml/h" BANK "DATABANK"
    72                        ;
    73                        ; BASIC COMMAND EXPECTS ONE STRING VAR (FILENAME) AND ONE NUMERIC VAR (DEVICE)
    74                        ; THIS IS NATIVE '816 CODE
    75                        ;__________________________________________________________
    76                        V_LOAD:					; load BASIC program
    77 FF:1972: 20 02 34             jsr LAB_EVEX        ; GET THE FIRST PARAMETER
    78 FF:1975: A5 5F                lda <Dtypef         ; IS IT A STRING?
    79 FF:1977: D0 08                bne V_LOAD_GO       ; YES, CONTINUE ON
    80                        V_LOAD_ERR:
    81 FF:1979: A2 02                ldx #$02            ; NOPE, SYNTAX ERROR
    82 FF:197B: 20 C1 28             jsr LAB_XERR
    83 FF:197E: 4C B2 29             JMP LAB_1319        ; RESET VARS, STACK AND RETURN CONTROL TO BASIC
    84                        V_LOAD_GO:
    85 FF:1981: 22 54 FD 00          JSL LIECINIT        ; INIT IEC BUS
    86 FF:1985: A9 C0                lda #$C0
    87 FF:1987: 85 1F                sta <IECMSGM
    88 FF:1989: A0 00                ldy #$00
    89                        V_LOAD_1:
    90                                LDAINDIRECTY ssptr_l
+   90 FF:198B: 8B               PHB
+   90 FF:198C: DA           	PHX
+   90 FF:198D: A2 01            LDX #$01
+   90 FF:198F: B5 B8            LDA <ssptr_l,X
+   90 FF:1991: C9 00            CMP #$00
+   90 FF:1993: D0 04            BNE *+6
+   90 FF:1995: A2 00        	LDX #00
+   90 FF:1997: DA           	PHX
+   90 FF:1998: AB           	PLB
+   90 FF:1999: FA               PLX
+   90 FF:199A: B1 B8        	LDA	(<ssptr_l),Y		;
+   90 FF:199C: 85 04            STA <TMPFLG
+   90 FF:199E: AB               PLB
+   90 FF:199F: A5 04            LDA <TMPFLG
    91 FF:19A1: BB                   TYX
    92 FF:19A2: 9F 00 10 00          STA >FNBUFFER,X
    93 FF:19A6: C9 00                CMP #$00
    94 FF:19A8: F0 07                beq V_LOAD_2
    95 FF:19AA: C9 22                cmp #'"'
    96 FF:19AC: F0 03                beq V_LOAD_2
    97 FF:19AE: C8                   iny
    98 FF:19AF: D0 DA                bne V_LOAD_1
    99                        V_LOAD_2:
   100 FF:19B1: 98                   TYA             ; fn length
   101 FF:19B2: A2 00                ldx #<FNBUFFER
   102 FF:19B4: A0 10                ldy #>FNBUFFER
   103 FF:19B6: 8B                   PHB
  Sun Nov 21 2021 15:13                                                                                                Page 39


   104                                SETBANK 0
+  104 FF:19B7: DA               PHX
+  104 FF:19B8: A2 00        	LDX #0
+  104 FF:19BA: DA           	PHX
+  104 FF:19BB: AB           	PLB
+  104 FF:19BC: FA               PLX
   105 FF:19BD: 22 48 FD 00          JSL LSETNAM     ; setnam
   106 FF:19C1: AB                   PLB
   107 FF:19C2: 20 24 35             JSR	LAB_1C01    ; GET THE SECOND PARAMETER (AFTER ',') OR SYN ERR
   108 FF:19C5: 20 9E 40             JSR	LAB_GTBY    ; GET THE SECOND PARAMETER, RETURN IN X
   109 FF:19C8: A0 01                ldy#1           ; secondary address
   110 FF:19CA: 8B                   PHB
   111                                SETBANK 0
+  111 FF:19CB: DA               PHX
+  111 FF:19CC: A2 00        	LDX #0
+  111 FF:19CE: DA           	PHX
+  111 FF:19CF: AB           	PLB
+  111 FF:19D0: FA               PLX
   112 FF:19D1: 22 44 FD 00          jsL LSETLFS
   113 FF:19D5: A5 7A                lda <Smemh
   114 FF:19D7: 8D 23 03             sta LOADBUFH
   115 FF:19DA: A5 79                lda <Smeml
   116 FF:19DC: 8D 22 03             sta LOADBUFL
   117 FF:19DF: A9 02                lda #DATABANK
   118 FF:19E1: 8D 24 03             sta LOADBANK
   119 FF:19E4: 22 4C FD 00          jsL LLOAD
   120 FF:19E8: AD 23 03             LDA LOADBUFH
   121 FF:19EB: 85 7C                STA <Svarh
   122 FF:19ED: AD 22 03             LDA LOADBUFL
   123 FF:19F0: 85 7B                STA <Svarl
   124 FF:19F2: AB                   PLB
   125 FF:19F3: A9 DB                LDA	#<LAB_RMSG		; point to "Ready" message low byte
   126 FF:19F5: A0 17                LDY	#>LAB_RMSG		; point to "Ready" message high byte
   127 FF:19F7: 20 85 31             JSR	LAB_18C3
   128 FF:19FA: 4C B2 29             JMP LAB_1319        ; RESET VARS, STACK AND RETURN CONTROL TO BASIC
   129                        
   130                        
   131                        ;___V_ERR___________________________________________________
   132                        ;
   133                        ; UTILIZE BIOS TO REPORT IEC IO CHANNEL STATUS
   134                        ;
   135                        ;
   136                        ; BASIC COMMAND EXPECTS ONE NUMERIC VAR (DEVICE)
   137                        ; THIS IS NATIVE '816 CODE
   138                        ;__________________________________________________________
   139                        V_ERR:
   140 FF:19FD: 22 54 FD 00          JSL LIECINIT        ; INIT IEC BUS
   141 FF:1A01: A9 C0                lda #$C0
   142 FF:1A03: 8F 1F 03 00          sta >IECMSGM
   143 FF:1A07: A0 00                ldy #$00
   144 FF:1A09: 20 9E 40             JSR	LAB_GTBY    ; GET THE SECOND PARAMETER, RETURN IN X
   145                        GETIECSTATUS:
   146 FF:1A0C: 8B                   PHB
   147 FF:1A0D: DA                   PHX
   148                                SETBANK 0
+  148 FF:1A0E: DA               PHX
+  148 FF:1A0F: A2 00        	LDX #0
  Sun Nov 21 2021 15:13                                                                                                Page 40


+  148 FF:1A11: DA           	PHX
+  148 FF:1A12: AB           	PLB
+  148 FF:1A13: FA               PLX
   149 FF:1A14: A9 0D                LDA     #13
   150 FF:1A16: 22 00 FD 00          JSL LPRINTVEC	; OUTCHAR
   151 FF:1A1A: A9 0A                LDA     #10
   152 FF:1A1C: 22 00 FD 00          JSL LPRINTVEC	; OUTCHAR
   153 FF:1A20: A9 00                lda     #0      ; fn length
   154 FF:1A22: A2 00                ldx     #0
   155 FF:1A24: A0 00                ldy     #0
   156 FF:1A26: 22 48 FD 00          JSL     LSETNAM  ; setnam
   157 FF:1A2A: FA                   PLX             ; Device Number
   158 FF:1A2B: A0 0F                ldy     #15     ; secondary address
   159 FF:1A2D: A9 0F                LDA     #15     ; LFN NUMBER
   160 FF:1A2F: 22 44 FD 00          JSL     LSETLFS  ;setlfs
   161 FF:1A33: 22 64 FD 00          JSL     LIECOPNLF
   162 FF:1A37: B0 1E                BCS     IECERROR
   163 FF:1A39: A2 0F                LDX     #15
   164 FF:1A3B: 22 60 FD 00          JSL     LIECINPC
   165 FF:1A3F: B0 16                BCS     IECERROR
   166                        GETIECSTATUS_1:
   167 FF:1A41: 22 2C FD 00  	    JSL	LIECIN 		; input a byte from the serial bus
   168 FF:1A45: B0 10                BCS     IECERROR
   169 FF:1A47: C9 0D                CMP #13
   170 FF:1A49: F0 0C                BEQ     IECERROR
   171 FF:1A4B: 22 00 FD 00          JSL LPRINTVEC	; OUTCHAR
   172 FF:1A4F: AF 17 03 00  	LDA	>IECSTW		        ; get serial status byte
   173 FF:1A53: 4A           	LSR				; shift time out read ..
   174 FF:1A54: 4A           	LSR				; .. into carry bit
   175 FF:1A55: 90 EA        	BCC	GETIECSTATUS_1		; all ok, do another
   176                        IECERROR:
   177 FF:1A57: 22 58 FD 00          JSL     LIECCLCH         ; close input and output channels
   178 FF:1A5B: A9 0F                lda     #15
   179 FF:1A5D: 22 68 FD 00          JSL     LIECCLSLF        ; close a specified logical file
   180 FF:1A61: A9 0D                LDA     #13
   181 FF:1A63: 22 00 FD 00          JSL LPRINTVEC	; OUTCHAR
   182 FF:1A67: A9 0A                LDA     #10
   183 FF:1A69: 22 00 FD 00          JSL LPRINTVEC	; OUTCHAR
   184 FF:1A6D: AB                   PLB
   185 FF:1A6E: A9 DB                LDA	#<LAB_RMSG		; point to "Ready" message low byte
   186 FF:1A70: A0 17                LDY	#>LAB_RMSG		; point to "Ready" message high byte
   187 FF:1A72: 20 85 31             JSR	LAB_18C3
   188 FF:1A75: 4C B2 29             JMP LAB_1319        ; RESET VARS, STACK AND RETURN CONTROL TO BASIC
   189                        
   190                        
   191                        
   192                        ;___V_DIR___________________________________________________
   193                        ;
   194                        ; UTILIZE BIOS TO DISPLAY DISK DIRECTORY
   195                        ;
   196                        ;
   197                        ; BASIC COMMAND EXPECTS ONE NUMERIC VAR (DEVICE)
   198                        ; THIS IS NATIVE '816 CODE
   199                        ;__________________________________________________________
   200                        V_DIR:
   201 FF:1A78: 22 54 FD 00          JSL LIECINIT        ; INIT IEC BUS
   202 FF:1A7C: A9 C0                lda #$C0
  Sun Nov 21 2021 15:13                                                                                                Page 41


   203 FF:1A7E: 8F 1F 03 00          sta >IECMSGM
   204 FF:1A82: A0 00                ldy #$00
   205 FF:1A84: 20 9E 40             JSR	LAB_GTBY    ; GET THE SECOND PARAMETER, RETURN IN X
   206 FF:1A87: 8B                   PHB
   207 FF:1A88: DA                   PHX
   208 FF:1A89: A9 24                LDA     #'$'
   209 FF:1A8B: 8F 00 10 00          STA     >FNBUFFER
   210                                SETBANK 0
+  210 FF:1A8F: DA               PHX
+  210 FF:1A90: A2 00        	LDX #0
+  210 FF:1A92: DA           	PHX
+  210 FF:1A93: AB           	PLB
+  210 FF:1A94: FA               PLX
   211 FF:1A95: A9 0D                LDA     #13
   212 FF:1A97: 22 00 FD 00          JSL     LPRINTVEC
   213 FF:1A9B: A9 0A                LDA     #10
   214 FF:1A9D: 22 00 FD 00          JSL     LPRINTVEC
   215 FF:1AA1: A9 01                lda     #1      ; fn length
   216 FF:1AA3: A2 00                ldx     #<FNBUFFER
   217 FF:1AA5: A0 10                ldy     #>FNBUFFER
   218 FF:1AA7: 22 48 FD 00          JSL     LSETNAM  ; setnam
   219 FF:1AAB: FA                   PLX             ; Device Number
   220 FF:1AAC: A0 00                ldy     #0      ; secondary address
   221 FF:1AAE: A9 0F                LDA     #15     ; LFN NUMBER
   222 FF:1AB0: 22 44 FD 00          JSL     LSETLFS  ;setlfs
   223 FF:1AB4: 22 64 FD 00          JSL     LIECOPNLF
   224 FF:1AB8: B0 9D                BCS     IECERROR
   225 FF:1ABA: A2 0F                LDX     #15
   226 FF:1ABC: 22 60 FD 00          JSL     LIECINPC
   227 FF:1AC0: B0 95                BCS     IECERROR
   228 FF:1AC2: 22 2C FD 00         	JSL	LIECIN 		; input a byte from the serial bus
   229                        GETIECDIRECTORY_1:
   230 FF:1AC6: 22 2C FD 00          JSL	LIECIN 		; input a byte from the serial bus
   231 FF:1ACA: 22 2C FD 00          JSL	LIECIN 		; input a byte from the serial bus
   232 FF:1ACE: 48                   PHA
   233 FF:1ACF: 22 2C FD 00          JSL	LIECIN 		; input a byte from the serial bus
   234 FF:1AD3: FA                   PLX
   235 FF:1AD4: AB                   PLB
   236 FF:1AD5: 8B                   PHB
   237 FF:1AD6: 20 A3 48             JSR	LAB_295E		; print XA as unsigned integer (bytes free)
   238                                SETBANK 0
+  238 FF:1AD9: DA               PHX
+  238 FF:1ADA: A2 00        	LDX #0
+  238 FF:1ADC: DA           	PHX
+  238 FF:1ADD: AB           	PLB
+  238 FF:1ADE: FA               PLX
   239 FF:1ADF: A9 20                LDA     #' '
   240 FF:1AE1: 22 00 FD 00          JSL     LPRINTVEC
   241 FF:1AE5: A9 20                LDA     #' '
   242 FF:1AE7: 22 00 FD 00          JSL     LPRINTVEC
   243 FF:1AEB: 22 2C FD 00          JSL	LIECIN
   244 FF:1AEF: C9 00                CMP     #$00
   245 FF:1AF1: F0 04                BEQ     GETIECDIRECTORY_2A
   246 FF:1AF3: 22 00 FD 00          JSL     LPRINTVEC
   247                        GETIECDIRECTORY_2A:
   248 FF:1AF7: 22 2C FD 00          JSL	LIECIN
   249 FF:1AFB: C9 00                CMP     #$00
  Sun Nov 21 2021 15:13                                                                                                Page 42


   250 FF:1AFD: F0 04                BEQ     GETIECDIRECTORY_2
   251 FF:1AFF: 22 00 FD 00          JSL     LPRINTVEC
   252                        GETIECDIRECTORY_2:
   253 FF:1B03: 22 2C FD 00          JSL	LIECIN 		; input ENTRY TEXT byte from the serial bus
   254 FF:1B07: 22 00 FD 00          JSL     LPRINTVEC
   255 FF:1B0B: C9 00                CMP     #$00
   256 FF:1B0D: F0 29                BEQ     GETIECDIRECTORY_3       ; END ENTRY
   257                        
   258 FF:1B0F: AF 17 03 00   	LDA	>IECSTW		        ; get serial status byte
   259 FF:1B13: 4A           	LSR				; shift time out read ..
   260 FF:1B14: 4A           	LSR				; .. into carry bit
   261 FF:1B15: 90 EC        	BCC	GETIECDIRECTORY_2		; all ok, do another
   262                        GETIECDIRECTORY_END:
   263 FF:1B17: 22 58 FD 00          JSL     LIECCLCH         ; close input and output channels
   264 FF:1B1B: A9 0F                lda     #15
   265 FF:1B1D: 22 68 FD 00          JSL     LIECCLSLF        ; close a specified logical file
   266 FF:1B21: A9 0D                LDA     #13
   267 FF:1B23: 22 00 FD 00          JSL     LPRINTVEC
   268 FF:1B27: A9 0A                LDA     #10
   269 FF:1B29: 22 00 FD 00          JSL     LPRINTVEC
   270 FF:1B2D: AB                   PLB
   271 FF:1B2E: A9 DB                LDA	#<LAB_RMSG		; point to "Ready" message low byte
   272 FF:1B30: A0 17                LDY	#>LAB_RMSG		; point to "Ready" message high byte
   273 FF:1B32: 20 85 31             JSR	LAB_18C3
   274 FF:1B35: 4C B2 29             JMP     LAB_1319        ; RESET VARS, STACK AND RETURN CONTROL TO BASIC
   275                        
   276                        GETIECDIRECTORY_3:
   277 FF:1B38: A9 0D                LDA     #13
   278 FF:1B3A: 22 00 FD 00          JSL     LPRINTVEC
   279 FF:1B3E: A9 0A                LDA     #10
   280 FF:1B40: 22 00 FD 00          JSL     LPRINTVEC
   281 FF:1B44: 22 2C FD 00         	JSL	LIECIN 		; input a byte from the serial bus
   282 FF:1B48: C9 01                CMP     #$01
   283 FF:1B4A: D0 CB                BNE     GETIECDIRECTORY_END
   284 FF:1B4C: 4C C6 1A             JMP     GETIECDIRECTORY_1
   285                        
   286                        
   287                        ;___V_DISKCMD______________________________________________
   288                        ;
   289                        ; UTILIZE BIOS TO SEND A DISK COMMAND
   290                        ;
   291                        ;
   292                        ; BASIC COMMAND EXPECTS ONE STRING VAR (COMMAND) AND ONE NUMERIC VAR (DEVICE)
   293                        ; THIS IS NATIVE '816 CODE
   294                        ;__________________________________________________________
   295                        V_DISKCMD:					; save BASIC program
   296 FF:1B4F: 20 02 34             jsr LAB_EVEX        ; GET THE FIRST PARAMETER
   297 FF:1B52: A5 5F                lda <Dtypef         ; IS IT A STRING?
   298 FF:1B54: D0 08                bne V_DISKCMD_GO       ; YES, CONTINUE ON
   299                        V_DISKCMD_ERR:
   300 FF:1B56: A2 02                ldx #$02            ; NOPE, SYNTAX ERROR
   301 FF:1B58: 20 C1 28             jsr LAB_XERR
   302 FF:1B5B: 4C B2 29             JMP LAB_1319        ; RESET VARS, STACK AND RETURN CONTROL TO BASIC
   303                        V_DISKCMD_GO:
   304 FF:1B5E: 22 54 FD 00          JSL LIECINIT        ; INIT IEC BUS
   305 FF:1B62: A9 C0                lda #$C0
   306 FF:1B64: 8F 1F 03 00          sta >IECMSGM
  Sun Nov 21 2021 15:13                                                                                                Page 43


   307 FF:1B68: 20 15 3E             JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
   308                                                    ; space returns with A = length, X=$71=pointer low byte,
   309                              					    ; Y=$72=pointer high byte
   310 FF:1B6B: 86 B8                STX <ssptr_l
   311 FF:1B6D: 84 B9                STY <ssptr_h
   312 FF:1B6F: AA                   TAX
   313 FF:1B70: A0 00                ldy #$00
   314                        V_DISKCMD_1:
   315                                LDAINDIRECTY ssptr_l
+  315 FF:1B72: 8B               PHB
+  315 FF:1B73: DA           	PHX
+  315 FF:1B74: A2 01            LDX #$01
+  315 FF:1B76: B5 B8            LDA <ssptr_l,X
+  315 FF:1B78: C9 00            CMP #$00
+  315 FF:1B7A: D0 04            BNE *+6
+  315 FF:1B7C: A2 00        	LDX #00
+  315 FF:1B7E: DA           	PHX
+  315 FF:1B7F: AB           	PLB
+  315 FF:1B80: FA               PLX
+  315 FF:1B81: B1 B8        	LDA	(<ssptr_l),Y		;
+  315 FF:1B83: 85 04            STA <TMPFLG
+  315 FF:1B85: AB               PLB
+  315 FF:1B86: A5 04            LDA <TMPFLG
   316 FF:1B88: DA                   PHX
   317 FF:1B89: BB                   TYX
   318 FF:1B8A: 9F 00 10 00          STA >FNBUFFER,X
   319 FF:1B8E: FA                   PLX
   320 FF:1B8F: CA                   DEX
   321 FF:1B90: E0 00                CPX #$00
   322 FF:1B92: F0 03                beq V_DISKCMD_2
   323 FF:1B94: C8                   iny
   324 FF:1B95: D0 DB                bne V_DISKCMD_1
   325                        V_DISKCMD_2:
   326 FF:1B97: BB                   TYX
   327 FF:1B98: A9 00                LDA #0
   328 FF:1B9A: 9F 01 10 00          STA >FNBUFFER+1,X
   329 FF:1B9E: 8B                   PHB
   330                                SETBANK 0
+  330 FF:1B9F: DA               PHX
+  330 FF:1BA0: A2 00        	LDX #0
+  330 FF:1BA2: DA           	PHX
+  330 FF:1BA3: AB           	PLB
+  330 FF:1BA4: FA               PLX
   331 FF:1BA5: A9 00                lda     #0      ; fn length
   332 FF:1BA7: A2 00                ldx     #0
   333 FF:1BA9: A0 00                ldy     #0
   334 FF:1BAB: 22 48 FD 00          JSL     LSETNAM  ; setnam
   335 FF:1BAF: AB                   PLB
   336 FF:1BB0: 20 24 35             JSR	LAB_1C01    ; GET THE SECOND PARAMETER (AFTER ',') OR SYN ERR
   337 FF:1BB3: 20 9E 40             JSR	LAB_GTBY    ; GET THE SECOND PARAMETER (DEVICE NUMBER), RETURN IN X
   338 FF:1BB6: 8B                   PHB
   339                                SETBANK 0
+  339 FF:1BB7: DA               PHX
+  339 FF:1BB8: A2 00        	LDX #0
+  339 FF:1BBA: DA           	PHX
+  339 FF:1BBB: AB           	PLB
+  339 FF:1BBC: FA               PLX
  Sun Nov 21 2021 15:13                                                                                                Page 44


   340 FF:1BBD: A0 0F                ldy     #15     ; secondary address
   341 FF:1BBF: A9 0F                LDA     #15     ; LFN NUMBER
   342 FF:1BC1: 22 44 FD 00          JSL     LSETLFS  ;setlfs
   343 FF:1BC5: 22 64 FD 00          JSL     LIECOPNLF
   344 FF:1BC9: B0 27                BCS     V_DISKCMD_ERR1
   345 FF:1BCB: A2 0F                LDX     #15
   346 FF:1BCD: 22 5C FD 00          JSL     LIECOUTC
   347 FF:1BD1: A2 00                LDX     #$00
   348                        V_DISKCMD_3:
   349 FF:1BD3: BF 00 10 00          LDA >FNBUFFER,X
   350 FF:1BD7: C9 00                CMP #$00
   351 FF:1BD9: F0 09                BEQ V_DISKCMD_4
   352 FF:1BDB: 22 30 FD 00  	    JSL	LIECOUT 		; OUTPUT a byte To the serial bus
   353 FF:1BDF: B0 11                BCS V_DISKCMD_ERR1
   354                        
   355 FF:1BE1: E8                   INX
   356 FF:1BE2: 80 EF                BRA V_DISKCMD_3
   357                        V_DISKCMD_4:
   358 FF:1BE4: A9 0F                lda     #15
   359 FF:1BE6: 22 38 FD 00          JSL     LUNLSTN
   360 FF:1BEA: A9 0F                lda     #15
   361 FF:1BEC: 22 68 FD 00          JSL     LIECCLSLF        ; close a specified logical file
   362 FF:1BF0: AB                   PLB
   363 FF:1BF1: 60                   RTS
   364                        V_DISKCMD_ERR1:
   365 FF:1BF2: 22 58 FD 00          JSL     LIECCLCH         ; close input and output channels
   366 FF:1BF6: A9 0F                lda     #15
   367 FF:1BF8: 22 68 FD 00          JSL     LIECCLSLF        ; close a specified logical file
   368 FF:1BFC: A9 0D                LDA     #13
   369 FF:1BFE: 22 00 FD 00          JSL LPRINTVEC	; OUTCHAR
   370 FF:1C02: A9 0A                LDA     #10
   371 FF:1C04: 22 00 FD 00          JSL LPRINTVEC	; OUTCHAR
   372 FF:1C08: AB                   PLB
   373 FF:1C09: A9 DB                LDA	#<LAB_RMSG		; point to "Ready" message low byte
   374 FF:1C0B: A0 17                LDY	#>LAB_RMSG		; point to "Ready" message high byte
   375 FF:1C0D: 20 85 31             JSR	LAB_18C3
   376 FF:1C10: 4C B2 29             JMP LAB_1319        ; RESET VARS, STACK AND RETURN CONTROL TO BASIC
   377                        
   378                        
   379                        
   380                        ;___V_OPEN__________________________________________________
   381                        ;
   382                        ; UTILIZE BIOS TO OPEN AN IEC IO CHANNEL
   383                        ;
   384                        ;
   385                        ; BASIC COMMAND EXPECTS THREE NUMERIC VARS, AND ONE STRING
   386                        ; VAR
   387                        ; FILE#, DEVICE, SECONDARY ADDRESS, FILENAME
   388                        ; THIS IS NATIVE '816 CODE
   389                        ;__________________________________________________________
   390                        V_OPEN:
   391 FF:1C13: 8B                   PHB
   392 FF:1C14: 22 54 FD 00          JSL LIECINIT        ; INIT IEC BUS
   393 FF:1C18: A9 C0                lda #$C0
   394 FF:1C1A: 8F 1F 03 00          sta >IECMSGM
   395 FF:1C1E: A0 00                ldy #$00
   396 FF:1C20: 20 9E 40             JSR	LAB_GTBY    ; GET THE FIRST PARAMETER, RETURN IN X (FILE#)
  Sun Nov 21 2021 15:13                                                                                                Page 45


   397 FF:1C23: DA                   phx
   398 FF:1C24: 20 24 35             JSR	LAB_1C01    ; (AFTER ',') OR SYN ERR
   399 FF:1C27: 20 9E 40             JSR	LAB_GTBY    ; GET THE SECOND PARAMETER, RETURN IN X (DEVICE)
   400 FF:1C2A: DA                   PHX
   401 FF:1C2B: 20 24 35             JSR	LAB_1C01    ; (AFTER ',') OR SYN ERR
   402 FF:1C2E: 20 9E 40             JSR	LAB_GTBY    ; GET THE THIRD PARAMETER, RETURN IN X (SECONDARY ADDRESS)
   403 FF:1C31: DA                   PHX
   404 FF:1C32: 20 24 35             JSR	LAB_1C01    ; (AFTER ',') OR SYN ERR
   405 FF:1C35: 20 02 34             jsr LAB_EVEX        ; GET THE FOURTH PARAMETER
   406 FF:1C38: A5 5F                lda <Dtypef         ; IS IT A STRING?
   407 FF:1C3A: D0 08                bne V_OPEN_GO       ; YES, CONTINUE ON
   408 FF:1C3C: A2 02                ldx #$02            ; NOPE, SYNTAX ERROR
   409 FF:1C3E: 20 C1 28             jsr LAB_XERR
   410 FF:1C41: 4C B2 29             JMP LAB_1319        ; RESET VARS, STACK AND RETURN CONTROL TO BASIC
   411                        V_OPEN_GO:
   412 FF:1C44: 20 15 3E             JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
   413                                                    ; space returns with A = length, X=$71=pointer low byte,
   414                              					    ; Y=$72=pointer high byte
   415 FF:1C47: 86 B8                STX <ssptr_l
   416 FF:1C49: 84 B9                STY <ssptr_h
   417 FF:1C4B: AA                   TAX
   418 FF:1C4C: A0 00                ldy #$00
   419                        V_OPEN_1:
   420                                LDAINDIRECTY ssptr_l
+  420 FF:1C4E: 8B               PHB
+  420 FF:1C4F: DA           	PHX
+  420 FF:1C50: A2 01            LDX #$01
+  420 FF:1C52: B5 B8            LDA <ssptr_l,X
+  420 FF:1C54: C9 00            CMP #$00
+  420 FF:1C56: D0 04            BNE *+6
+  420 FF:1C58: A2 00        	LDX #00
+  420 FF:1C5A: DA           	PHX
+  420 FF:1C5B: AB           	PLB
+  420 FF:1C5C: FA               PLX
+  420 FF:1C5D: B1 B8        	LDA	(<ssptr_l),Y		;
+  420 FF:1C5F: 85 04            STA <TMPFLG
+  420 FF:1C61: AB               PLB
+  420 FF:1C62: A5 04            LDA <TMPFLG
   421 FF:1C64: DA                   PHX
   422 FF:1C65: BB                   TYX
   423 FF:1C66: 9F 00 10 00          STA >FNBUFFER,X
   424 FF:1C6A: FA                   PLX
   425 FF:1C6B: CA                   DEX
   426 FF:1C6C: E0 00                CPX #$00
   427 FF:1C6E: F0 03                beq V_OPEN_2
   428 FF:1C70: C8                   iny
   429 FF:1C71: D0 DB                bne V_OPEN_1
   430                        V_OPEN_2:
   431 FF:1C73: C8                   INY
   432 FF:1C74: 98                   TYA             ; fn length
   433 FF:1C75: A2 00                ldx #<FNBUFFER
   434 FF:1C77: A0 10                ldy #>FNBUFFER
   435                                SETBANK 0
+  435 FF:1C79: DA               PHX
+  435 FF:1C7A: A2 00        	LDX #0
+  435 FF:1C7C: DA           	PHX
+  435 FF:1C7D: AB           	PLB
  Sun Nov 21 2021 15:13                                                                                                Page 46


+  435 FF:1C7E: FA               PLX
   436 FF:1C7F: 22 48 FD 00          JSL LSETNAM     ; setnam
   437 FF:1C83: FA                   PLX
   438 FF:1C84: 9B                   TXY             ; secondary address
   439 FF:1C85: FA                   PLX             ; DEVICE NUMBER
   440 FF:1C86: 68                   PLA             ; LFN NUMBER
   441 FF:1C87: 22 44 FD 00          JSL     LSETLFS  ;setlfs
   442 FF:1C8B: 22 64 FD 00          JSL     LIECOPNLF
   443 FF:1C8F: B0 02                BCS     V_OPEN_IECERROR
   444 FF:1C91: AB                   PLB
   445 FF:1C92: 60                   RTS
   446                         V_OPEN_IECERROR:
   447 FF:1C93: 4C 57 1A             JMP  IECERROR
   448                        
   449                        ;___V_CLOSE________________________________________________
   450                        ;
   451                        ; UTILIZE BIOS TO CLOSE AN IEC IO CHANNEL
   452                        ;
   453                        ;
   454                        ; THIS IS NATIVE '816 CODE
   455                        ;__________________________________________________________
   456                        V_CLOSE:
   457 FF:1C96: 8B                   PHB
   458 FF:1C97: 20 9E 40             JSR	LAB_GTBY    ; GET THE FIRST PARAMETER, RETURN IN X (FILE#)
   459                                SETBANK 0
+  459 FF:1C9A: DA               PHX
+  459 FF:1C9B: A2 00        	LDX #0
+  459 FF:1C9D: DA           	PHX
+  459 FF:1C9E: AB           	PLB
+  459 FF:1C9F: FA               PLX
   460 FF:1CA0: 8A                   TXA
   461 FF:1CA1: 22 68 FD 00          JSL     LIECCLSLF        ; close a specified logical file
   462 FF:1CA5: AB                   PLB
   463 FF:1CA6: 60                   RTS
   464                        
   465                        ;___V_IECINPUT_______________________________________________
   466                        ;
   467                        ; UTILIZE BIOS TO USE OPEN AN IEC CHANNEL AS INPUT
   468                        ;
   469                        ;
   470                        ; BASIC COMMAND EXPECTS ONE NUMERIC VARS, FILE#
   471                        ; THIS IS NATIVE '816 CODE
   472                        ;__________________________________________________________
   473                        V_IECINPUT:
   474 FF:1CA7: 8B                   PHB
   475 FF:1CA8: 20 9E 40             JSR	LAB_GTBY    ; GET THE FIRST PARAMETER, RETURN IN X (FILE#)
   476                                SETBANK 0
+  476 FF:1CAB: DA               PHX
+  476 FF:1CAC: A2 00        	LDX #0
+  476 FF:1CAE: DA           	PHX
+  476 FF:1CAF: AB           	PLB
+  476 FF:1CB0: FA               PLX
   477 FF:1CB1: 22 60 FD 00          JSL     LIECINPC
   478 FF:1CB5: B0 02                BCS     V_IECINPUT_IECERROR
   479 FF:1CB7: AB                   PLB
   480 FF:1CB8: 60                   RTS
   481                         V_IECINPUT_IECERROR:
  Sun Nov 21 2021 15:13                                                                                                Page 47


   482 FF:1CB9: AB                   PLB
   483 FF:1CBA: 4C 57 1A             JMP  IECERROR
   484                        
   485                        ;___V_IECOUTPUT______________________________________________
   486                        ;
   487                        ; UTILIZE BIOS TO USE OPEN AN IEC CHANNEL AS OUTPUT
   488                        ;
   489                        ;
   490                        ; BASIC COMMAND EXPECTS ONE NUMERIC VARS, FILE#
   491                        ; THIS IS NATIVE '816 CODE
   492                        ;__________________________________________________________
   493                        V_IECOUTPUT:
   494 FF:1CBD: 8B                   PHB
   495 FF:1CBE: 20 9E 40             JSR	LAB_GTBY    ; GET THE FIRST PARAMETER, RETURN IN X (FILE#)
   496                                SETBANK 0
+  496 FF:1CC1: DA               PHX
+  496 FF:1CC2: A2 00        	LDX #0
+  496 FF:1CC4: DA           	PHX
+  496 FF:1CC5: AB           	PLB
+  496 FF:1CC6: FA               PLX
   497 FF:1CC7: 22 5C FD 00          JSL     LIECOUTC
   498 FF:1CCB: B0 02                BCS     V_IECOUTPUT_IECERROR
   499 FF:1CCD: AB                   PLB
   500 FF:1CCE: 60                   RTS
   501                         V_IECOUTPUT_IECERROR:
   502 FF:1CCF: AB                   PLB
   503 FF:1CD0: 4C 57 1A             JMP  IECERROR
   504                        
   505                        
   506                        ;___V_PUTN__________________________________________________
   507                        ;
   508                        ; UTILIZE BIOS TO PRINT TO AN IEC IO CHANNEL
   509                        ;
   510                        ; STARTING WITH FILE#, OUTPUT STRING
   511                        ; THIS IS NATIVE '816 CODE
   512                        ;__________________________________________________________
   513                        V_PUTN:
   514 FF:1CD3: 20 9E 40             JSR	LAB_GTBY    ; GET THE FIRST PARAMETER, RETURN IN X (FILE#)
   515 FF:1CD6: 86 04                STX <TMPFLG
   516 FF:1CD8: 20 24 35             JSR	LAB_1C01    ; (AFTER ',') OR SYN ERR
   517                        
   518 FF:1CDB: 20 02 34             jsr LAB_EVEX        ; GET THE FIRST PARAMETER
   519 FF:1CDE: A5 5F                lda <Dtypef         ; IS IT A STRING?
   520 FF:1CE0: D0 08                bne V_PUTN_GO       ; YES, CONTINUE ON
   521                        V_PUTN_ERR:
   522 FF:1CE2: A2 02                ldx #$02            ; NOPE, SYNTAX ERROR
   523 FF:1CE4: 20 C1 28             jsr LAB_XERR
   524 FF:1CE7: 4C B2 29             JMP LAB_1319        ; RESET VARS, STACK AND RETURN CONTROL TO BASIC
   525                        V_PUTN_GO:
   526 FF:1CEA: 20 15 3E             JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
   527                                                    ; space returns with A = length, X=$71=pointer low byte,
   528                              					    ; Y=$72=pointer high byte
   529 FF:1CED: 86 B8                STX <ssptr_l
   530 FF:1CEF: 84 B9                STY <ssptr_h
   531 FF:1CF1: AA                   TAX
   532 FF:1CF2: A0 00                LDY #$00
   533                        V_PUTN_1:
  Sun Nov 21 2021 15:13                                                                                                Page 48


   534                                LDAINDIRECTY ssptr_l
+  534 FF:1CF4: 8B               PHB
+  534 FF:1CF5: DA           	PHX
+  534 FF:1CF6: A2 01            LDX #$01
+  534 FF:1CF8: B5 B8            LDA <ssptr_l,X
+  534 FF:1CFA: C9 00            CMP #$00
+  534 FF:1CFC: D0 04            BNE *+6
+  534 FF:1CFE: A2 00        	LDX #00
+  534 FF:1D00: DA           	PHX
+  534 FF:1D01: AB           	PLB
+  534 FF:1D02: FA               PLX
+  534 FF:1D03: B1 B8        	LDA	(<ssptr_l),Y		;
+  534 FF:1D05: 85 04            STA <TMPFLG
+  534 FF:1D07: AB               PLB
+  534 FF:1D08: A5 04            LDA <TMPFLG
   535 FF:1D0A: DA                   PHX
   536 FF:1D0B: 5A                   PHY
   537 FF:1D0C: 8B                   PHB
   538                                SETBANK 0
+  538 FF:1D0D: DA               PHX
+  538 FF:1D0E: A2 00        	LDX #0
+  538 FF:1D10: DA           	PHX
+  538 FF:1D11: AB           	PLB
+  538 FF:1D12: FA               PLX
   539 FF:1D13: A6 04                LDX <TMPFLG
   540 FF:1D15: 48                   PHA
   541 FF:1D16: 22 30 FD 00          JSL LIECOUT
   542 FF:1D1A: 68                   PLA
   543 FF:1D1B: 22 00 FD 00          JSL LPRINTVEC
   544 FF:1D1F: AB                   PLB
   545 FF:1D20: 7A                   PLY
   546 FF:1D21: FA                   PLX
   547 FF:1D22: CA                   DEX
   548 FF:1D23: E0 00                cpx #00
   549 FF:1D25: F0 03                beq V_PUTN_2
   550 FF:1D27: C8                   iny
   551 FF:1D28: D0 CA                bne V_PUTN_1
   552                        V_PUTN_2:
   553 FF:1D2A: 60                   RTS
   554                        
   555                        
   556                        
   557                        ;___LAB_IECST_______________________________________________
   558                        ;
   559                        ; RETURN IEC STATUS BYTE
   560                        ;
   561                        ; THIS IS NATIVE '816 CODE
   562                        ;__________________________________________________________
   563                        LAB_IECST
   564 FF:1D2B: 48               PHA
   565 FF:1D2C: AF 17 03 00      LDA >IECSTW     ; get IECSTW into low byte
   566 FF:1D30: A8               TAY
   567 FF:1D31: 68               PLA
   568 FF:1D32: A9 00           	LDA	#0		    ; NO high byte
   569 FF:1D34: 20 BD 39        	JSR	LAB_AYFC
   570 FF:1D37: 60               RTS
   571                        LAB_PIECST
  Sun Nov 21 2021 15:13                                                                                                Page 49


   572 FF:1D38: 46 5F        	LSR	<Dtypef		; clear data type flag, $FF=string, $00=numeric
   573 FF:1D3A: 22 BC 00 00  	JSL	LAB_IGBY		; increment and scan memory then do function
   574 FF:1D3E: 60           	RTS
   575                        
   576                        ;___V_GETN_________________________________________________
   577                        ;
   578                        ; UTILIZE BIOS TO INPUT FROM AN IEC IO CHANNEL
   579                        ;
   580                        ; LOTS OF PARAMETERS :)  STARTING WITH FILE#
   581                        ; THIS IS NATIVE '816 CODE
   582                        ;__________________________________________________________
   583                        V_GETN:
   584 FF:1D3F: 20 9E 40             JSR	LAB_GTBY            ; GET THE FIRST PARAMETER, RETURN IN X (FILE#)
   585 FF:1D42: DA                   PHX                     ; STORE DEVICE NUMBER
   586 FF:1D43: 20 24 35             JSR	LAB_1C01            ; (AFTER ',') OR SYN ERR
   587 FF:1D46: 20 FF 36         	JSR	LAB_GVAR		    ; get var address
   588 FF:1D49: 85 97            	STA	<Lvarpl		        ; save var address low byte
   589 FF:1D4B: 84 98            	STY	<Lvarph		        ; save var address high byte
   590 FF:1D4D: FA                   PLX
   591 FF:1D4E: 8B                   PHB
   592                                SETBANK 0
+  592 FF:1D4F: DA               PHX
+  592 FF:1D50: A2 00        	LDX #0
+  592 FF:1D52: DA           	PHX
+  592 FF:1D53: AB           	PLB
+  592 FF:1D54: FA               PLX
   593 FF:1D55: A6 04                LDX <TMPFLG
   594 FF:1D57: 22 2C FD 00      	JSL	LIECIN              ; get input byte
   595 FF:1D5B: AB                   PLB
   596                        
   597 FF:1D5C: A6 5F            	LDX	<Dtypef		        ; get data type flag, $FF=string, $00=numeric
   598 FF:1D5E: 30 07            	BMI	LAB_GETNS		    ; go get string character
   599                                					    ; was numeric get
   600 FF:1D60: A8               	TAY				        ; copy character to Y
   601 FF:1D61: 20 CA 39         	JSR	LAB_1FD0		    ; convert Y to byte in FAC1
   602 FF:1D64: 4C F2 45         	JMP	LAB_PFAC		    ; pack FAC1 into variable (<Lvarpl) and return
   603                        LAB_GETNS
   604 FF:1D67: 48                   PHA
   605 FF:1D68: A9 01                LDA #$01
   606 FF:1D6A: 20 2E 3B         	JSR	LAB_MSSP		    ; make string space A bytes long A=$AC=length,
   607                        					            ; X=$AD=<Sutill=ptr low byte, Y=$AE=<Sutilh=ptr high
                     byte
   608 FF:1D6D: 68               	PLA				        ; get character back
   609 FF:1D6E: A0 00            	LDY	#$00			    ; clear index
   610                            	STAINDIRECTY str_pl		; save byte in string (byte IS string!)
+  610 FF:1D70: 8B               PHB
+  610 FF:1D71: DA           	PHX
+  610 FF:1D72: 48               PHA
+  610 FF:1D73: A2 01            LDX #$01
+  610 FF:1D75: B5 AD            LDA <str_pl,X
+  610 FF:1D77: C9 00            CMP #$00
+  610 FF:1D79: D0 04            BNE *+6
+  610 FF:1D7B: A2 00        	LDX #00
+  610 FF:1D7D: DA           	PHX
+  610 FF:1D7E: AB           	PLB
+  610 FF:1D7F: 68               PLA
+  610 FF:1D80: FA               PLX
  Sun Nov 21 2021 15:13                                                                                                Page 50


+  610 FF:1D81: 91 AD        	STA	(<str_pl),Y		;
+  610 FF:1D83: AB           	PLB
+  610 FF:1D84: 85 04            STA <TMPFLG
   611 FF:1D86: 20 91 3B         	JSR	LAB_RTST		    ; check for space on descriptor stack then put addre
                    ss
   612                        					            ; and length on descriptor stack and update stack po
                    inters
   613 FF:1D89: 4C 9C 2F         	JMP	LAB_17D5		    ; do string LET and return
   117                                .include 'screencmds.asm'
     1                        ;___SCNCLR_________________________________________________
     2                        ;
     3                        ; UTILIZE BIOS TO CLEAR SCREEN
     4                        ;
     5                        ;
     6                        ; THIS IS NATIVE '816 CODE
     7                        ;__________________________________________________________
     8                        V_SCNCLR:
     9 FF:1D8C: 8B                   PHB
    10                                SETBANK 0
+   10 FF:1D8D: DA               PHX
+   10 FF:1D8E: A2 00        	LDX #0
+   10 FF:1D90: DA           	PHX
+   10 FF:1D91: AB           	PLB
+   10 FF:1D92: FA               PLX
    11 FF:1D93: 22 6C FD 00          JSL LClearScrVec
    12 FF:1D97: AB                   PLB
    13 FF:1D98: 60                   RTS
    14                        
    15                        ;___LOCATE_________________________________________________
    16                        ;
    17                        ; UTILIZE BIOS TO LOCATE CURSOR
    18                        ;
    19                        ;  TAKES TWO PARAMETERS X,Y
    20                        ;
    21                        ; THIS IS NATIVE '816 CODE
    22                        ;__________________________________________________________
    23                        V_LOCATE:
    24 FF:1D99: 20 9E 40             JSR	LAB_GTBY    ; GET THE FIRST PARAMETER, RETURN IN X (FILE#)
    25 FF:1D9C: DA                   phx
    26 FF:1D9D: 20 24 35             JSR	LAB_1C01    ; (AFTER ',') OR SYN ERR
    27 FF:1DA0: 20 9E 40             JSR	LAB_GTBY    ; GET THE SECOND PARAMETER, RETURN IN X (DEVICE)
    28 FF:1DA3: 7A                   PLY
    29 FF:1DA4: 8B                   PHB
    30                                SETBANK 0
+   30 FF:1DA5: DA               PHX
+   30 FF:1DA6: A2 00        	LDX #0
+   30 FF:1DA8: DA           	PHX
+   30 FF:1DA9: AB           	PLB
+   30 FF:1DAA: FA               PLX
    31 FF:1DAB: 22 0C FD 00          JSL LSetXYVEC
    32 FF:1DAF: AB                   PLB
    33 FF:1DB0: 60                   RTS
    34                        
    35                        ;___COLOR_________________________________________________
    36                        ;
    37                        ; UTILIZE BIOS TO SET COLORS
    38                        ;
  Sun Nov 21 2021 15:13                                                                                                Page 51


    39                        ;  TAKES TWO PARAMETERS BACKGROUND,FOREGROUND
    40                        ;
    41                        ; THIS IS NATIVE '816 CODE
    42                        ;__________________________________________________________
    43                        V_COLOR:
    44 FF:1DB1: 20 9E 40             JSR	LAB_GTBY    ; GET THE FIRST PARAMETER, RETURN IN X (FILE#)
    45 FF:1DB4: 8A                   TXA
    46 FF:1DB5: 29 0F                AND     #$0F
    47 FF:1DB7: 48                   PHA
    48 FF:1DB8: 20 24 35             JSR	LAB_1C01    ; (AFTER ',') OR SYN ERR
    49 FF:1DBB: 20 9E 40             JSR	LAB_GTBY    ; GET THE SECOND PARAMETER, RETURN IN X (DEVICE)
    50 FF:1DBE: 8A                   TXA
    51 FF:1DBF: 29 0F                AND     #$0F
    52 FF:1DC1: 18                   CLC
    53 FF:1DC2: 0A                   ASL
    54 FF:1DC3: 0A                   ASL
    55 FF:1DC4: 0A                   ASL
    56 FF:1DC5: 0A                   ASL
    57 FF:1DC6: 85 04                STA <TMPFLG
    58 FF:1DC8: 68                   pla
    59 FF:1DC9: 05 04                ORA <TMPFLG
    60 FF:1DCB: 8B                   PHB
    61                                SETBANK 0
+   61 FF:1DCC: DA               PHX
+   61 FF:1DCD: A2 00        	LDX #0
+   61 FF:1DCF: DA           	PHX
+   61 FF:1DD0: AB           	PLB
+   61 FF:1DD1: FA               PLX
    62 FF:1DD2: 22 18 FD 00          JSL LSetColorVEC
    63 FF:1DD6: AB                   PLB
    64 FF:1DD7: 60                   RTS
    65                        
    66                        ;___V_SPEEK()______________________________________________
    67                        ;
    68                        ; GET VALUE FROM SCREEN MEMORY
    69                        ;
    70                        ;  TAKES ONE PARAMETER (ADDRESS), RETURNS VALUE
    71                        ;
    72                        ; THIS IS NATIVE '816 CODE
    73                        ;__________________________________________________________
    74                        V_SPEEK:
    75 FF:1DD8: 20 42 41     	JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
    76                        
    77 FF:1DDB: 8B                  	PHB
    78                                setbank 0
+   78 FF:1DDC: DA               PHX
+   78 FF:1DDD: A2 00        	LDX #0
+   78 FF:1DDF: DA           	PHX
+   78 FF:1DE0: AB           	PLB
+   78 FF:1DE1: FA               PLX
    79 FF:1DE2: A2 00        	LDX	#$00			; clear index
    80 FF:1DE4: 20 EC 1D             JSR SPEEK_1
    81 FF:1DE7: AB                   plb
    82 FF:1DE8: A8           	TAY				; copy byte to Y
    83 FF:1DE9: 4C CA 39     	JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
    84                        
    85                        SPEEK_1:
  Sun Nov 21 2021 15:13                                                                                                Page 52


    86 FF:1DEC: A5 11        	LDA	<Itempl
    87 FF:1DEE: 8F 0B FE 00  	sta	>CMDP
    88 FF:1DF2: 20 22 23             jsr     DELAY9918
    89 FF:1DF5: A5 12                LDA 	<Itemph
    90 FF:1DF7: 09 40                ORA	#$40
    91 FF:1DF9: 29 7F        	AND	#$7F
    92 FF:1DFB: 8F 0B FE 00  	sta	>CMDP
    93 FF:1DFF: 20 22 23             jsr     DELAY9918
    94 FF:1E02: AF 0A FE 00          LDA     >DATAP
    95                        ;       REPEATING THE READ FOR RELIABILITY (SOMETIMES ONE READ DOES NOT WORK, IF THE 9918 IS EVER 
                    REPLACED WITH A v99x8 THIS CAN BE REMOVED)
    96 FF:1E06: A5 11        	LDA	<Itempl
    97 FF:1E08: 8F 0B FE 00  	sta	>CMDP
    98 FF:1E0C: 20 22 23             jsr     DELAY9918
    99 FF:1E0F: A5 12                LDA 	<Itemph
   100 FF:1E11: 09 40                ORA	#$40
   101 FF:1E13: 29 7F        	AND	#$7F
   102 FF:1E15: 8F 0B FE 00  	sta	>CMDP
   103 FF:1E19: 20 22 23             jsr     DELAY9918
   104 FF:1E1C: AF 0A FE 00          LDA     >DATAP
   105 FF:1E20: 60           	RTS
   106                        
   107                        ;___V_SPOKE_________________________________________________
   108                        ;
   109                        ; PUT VALUE IN SCREEN MEMORY
   110                        ;
   111                        ;  TAKES TWO PARAMETERS ADDRESS,VALUE
   112                        ;
   113                        ; THIS IS NATIVE '816 CODE
   114                        ;__________________________________________________________
   115                        V_SPOKE:
   116 FF:1E21: 20 29 41     	JSR	LAB_GADB		; get two parameters for POKE or WAIT
   117 FF:1E24: 8B                   PHB
   118 FF:1E25: DA           	PHX				; SAVE byte argument
   119                                SETBANK 0
+  119 FF:1E26: DA               PHX
+  119 FF:1E27: A2 00        	LDX #0
+  119 FF:1E29: DA           	PHX
+  119 FF:1E2A: AB           	PLB
+  119 FF:1E2B: FA               PLX
   120                                ; Let's set VDP write address to Itemp
   121 FF:1E2C: A5 11        	LDA	<Itempl
   122 FF:1E2E: 8D 0B FE     	sta	CMDP
   123 FF:1E31: 20 22 23             jsr     DELAY9918
   124 FF:1E34: A5 12                LDA 	<Itemph
   125 FF:1E36: 29 7F        	AND	#$7F
   126 FF:1E38: 09 40                ORA	#$40
   127 FF:1E3A: 8D 0B FE     	sta	CMDP
   128 FF:1E3D: 20 22 23             jsr     DELAY9918
   129 FF:1E40: 68                   PLA
   130 FF:1E41: 8D 0A FE     	STA	DATAP
   131 FF:1E44: AB                   PLB
   132 FF:1E45: 60           	RTS
   133                        
   134                        ;___V_SCREEN_________________________________________________
   135                        ;
   136                        ;  SET SCREEN MODE
  Sun Nov 21 2021 15:13                                                                                                Page 53


   137                        ;
   138                        ;  TAKES ONE PARAMETER,  SCREEN MODE
   139                        ;  0=GRAPHICS MODE (32X24)
   140                        ;  1=MULTICOLOR (64X48 BLOCKS)
   141                        ;  2=TEXT MODE (40X24)
   142                        ;  4=GRAPHICS MODE 2 (32X24 MULTICOLOR)
   143                        ; THIS IS NATIVE '816 CODE
   144                        ;__________________________________________________________
   145                        V_SCREEN:
   146 FF:1E46: 20 CE 39             JSR	LAB_CKRN    ; check not Direct, back here if ok
   147 FF:1E49: 20 9E 40             JSR	LAB_GTBY    ; GET THE FIRST PARAMETER, RETURN IN X (MODE)
   148                        V_SCREEN1:
   149 FF:1E4C: 86 06                STX     <VIDEOMODE
   150 FF:1E4E: E0 00                CPX     #00
   151 FF:1E50: D0 03                BNE     *+5
   152 FF:1E52: 4C 7A 1E             JMP     SETUPMODE0
   153 FF:1E55: E0 01                CPX     #01
   154 FF:1E57: D0 03                BNE     *+5
   155 FF:1E59: 4C A4 1E             JMP     SETUPMODE1
   156 FF:1E5C: E0 02                CPX     #02
   157 FF:1E5E: D0 03                BNE     *+5
   158 FF:1E60: 4C 23 1F             JMP     SETUPMODE2
   159 FF:1E63: E0 03                CPX     #03
   160 FF:1E65: D0 03                BNE     *+5
   161 FF:1E67: 4C 41 1F             JMP     SETUPMODE3
   162 FF:1E6A: E0 04                CPX     #04
   163 FF:1E6C: D0 03                BNE     *+5
   164 FF:1E6E: 4C 6B 1F             JMP     SETUPMODE4
   165                        
   166 FF:1E71: A2 02                ldx #$02            ; SYNTAX ERROR
   167 FF:1E73: 20 C1 28             jsr LAB_XERR
   168 FF:1E76: 4C B2 29             JMP LAB_1319        ; RESET VARS, STACK AND RETURN CONTROL TO BASIC
   169                        
   170 FF:1E79: 60                   RTS
   171                        
   172                        SETUPMODE0:
   173 FF:1E7A: A9 BF               	LDA	#<Mode0Parameters	; point to Parameters for Mode 4
   174 FF:1E7C: A0 1F           	LDY	#>Mode0Parameters
   175 FF:1E7E: 20 F1 1F             jsr     Set9918Parms
   176                         ;       CLEAR RAM
   177                                INDEX16
+  177 FF:1E81: C2 10        		REP #$10 		; 16 bit Index registers
+  177                        		LONGI ON
   178 FF:1E83: A2 00 00             LDX     #$0000
   179 FF:1E86: 86 07                STX     <LOCALWORK
   180                                INDEX8
+  180 FF:1E88: E2 10        		SEP #$10 		; 8 bit Index registers
+  180                        		LONGI OFF
   181 FF:1E8A: 20 2F 20             JSR     SET9918ADDRESS
   182                                INDEX16
+  182 FF:1E8D: C2 10        		REP #$10 		; 16 bit Index registers
+  182                        		LONGI ON
   183 FF:1E8F: A2 00 40             LDX     #$4000
   184 FF:1E92: A9 00                LDA     #$00
   185                        SETUPMODE0_1:
   186 FF:1E94: 20 22 23             JSR     DELAY9918
   187 FF:1E97: 8F 0A FE 00          STA     >DATAP
  Sun Nov 21 2021 15:13                                                                                                Page 54


   188 FF:1E9B: CA                   DEX
   189 FF:1E9C: E0 00 00             CPX     #$0000
   190 FF:1E9F: D0 F3                BNE     SETUPMODE0_1
   191                                INDEX8
+  191 FF:1EA1: E2 10        		SEP #$10 		; 8 bit Index registers
+  191                        		LONGI OFF
   192 FF:1EA3: 60                   rts
   193                        SETUPMODE1:
   194 FF:1EA4: A9 C9               	LDA	#<Mode1Parameters	; point to Parameters for Mode 4
   195 FF:1EA6: A0 1F           	LDY	#>Mode1Parameters
   196 FF:1EA8: 20 F1 1F             jsr     Set9918Parms
   197 FF:1EAB: 8B                   PHB
   198                                setbank 0
+  198 FF:1EAC: DA               PHX
+  198 FF:1EAD: A2 00        	LDX #0
+  198 FF:1EAF: DA           	PHX
+  198 FF:1EB0: AB           	PLB
+  198 FF:1EB1: FA               PLX
   199 FF:1EB2: A0 00                ldy #$00
   200                        SETUPMODE1_1:
   201                                ACCUMULATOR16
+  201 FF:1EB4: C2 20        		REP #$20 		; 16 bit Index registers
+  201                        		LONGA ON
   202 FF:1EB6: 98                   TYA
   203 FF:1EB7: 29 FF 00             and #$00FF
   204 FF:1EBA: 18                   CLC
   205 FF:1EBB: 0A                   ASL     ; a=y*32
   206 FF:1EBC: 0A                   ASL
   207 FF:1EBD: 0A                   ASL
   208 FF:1EBE: 0A                   ASL
   209 FF:1EBF: 0A                   ASL
   210 FF:1EC0: 18                   CLC
   211 FF:1EC1: 69 00 04             ADC #1024
   212 FF:1EC4: 85 07                sta <LOCALWORK
   213                                ACCUMULATOR8
+  213 FF:1EC6: E2 20        		SEP #$20 		; 8 bit Index registers
+  213                        		LONGA OFF
   214 FF:1EC8: A5 07        	LDA <LOCALWORK
   215 FF:1ECA: 8D 0B FE     	sta CMDP
   216 FF:1ECD: 20 22 23             jsr     DELAY9918
   217 FF:1ED0: A5 08        	LDA <LOCALWORK+1
   218 FF:1ED2: 09 40        	ORA #$40
   219 FF:1ED4: 29 7F        	AND #$7F
   220 FF:1ED6: 8D 0B FE     	sta CMDP
   221 FF:1ED9: 98                   TYA
   222 FF:1EDA: 29 FC                and #$FC
   223 FF:1EDC: 18                   CLC
   224 FF:1EDD: 0A                   ASL
   225 FF:1EDE: 0A                   ASL
   226 FF:1EDF: 0A                   ASL
   227 FF:1EE0: 85 11                sta <Itempl
   228 FF:1EE2: A2 00                ldx #$00
   229                        SETUPMODE1_2:
   230 FF:1EE4: A5 11                lda <Itempl
   231 FF:1EE6: 8D 0A FE             sta DATAP
   232 FF:1EE9: 20 22 23             jsr     DELAY9918
   233 FF:1EEC: E6 11                inc <Itempl
  Sun Nov 21 2021 15:13                                                                                                Page 55


   234 FF:1EEE: E8                   inx
   235 FF:1EEF: E0 20                cpx #32
   236 FF:1EF1: D0 F1                bne SETUPMODE1_2
   237 FF:1EF3: C8                   iny
   238 FF:1EF4: C0 18                cpy #24
   239 FF:1EF6: D0 BC                bne SETUPMODE1_1
   240                        ; CLEAR SCREEN
   241                                INDEX16
+  241 FF:1EF8: C2 10        		REP #$10 		; 16 bit Index registers
+  241                        		LONGI ON
   242 FF:1EFA: 20 22 23             jsr     DELAY9918
   243 FF:1EFD: A9 00                LDA #$00
   244 FF:1EFF: 8D 0B FE     	sta CMDP
   245 FF:1F02: 20 22 23             jsr     DELAY9918
   246 FF:1F05: A2 00 00             LDX #$0000
   247 FF:1F08: A9 08        	LDA #$08
   248 FF:1F0A: 09 40        	ORA #$40
   249 FF:1F0C: 29 7F        	AND #$7F
   250 FF:1F0E: 8D 0B FE     	sta CMDP
   251 FF:1F11: A9 00                LDA #$00
   252                        SETUPMODE1_3:
   253 FF:1F13: 20 22 23             jsr     DELAY9918
   254 FF:1F16: 8D 0A FE             STA DATAP
   255 FF:1F19: E8                   inx
   256 FF:1F1A: E0 01 06             CPX #$0601
   257 FF:1F1D: D0 F4                BNE SETUPMODE1_3
   258                                INDEX8
+  258 FF:1F1F: E2 10        		SEP #$10 		; 8 bit Index registers
+  258                        		LONGI OFF
   259 FF:1F21: AB                   plb
   260 FF:1F22: 60                   RTS
   261                        SETUPMODE2:
   262 FF:1F23: A9 28                LDA     #40
   263 FF:1F25: 8F 43 03 00          STA     >VIDEOWIDTH
   264 FF:1F29: A9 D3               	LDA	#<Mode2Parameters	; point to Parameters for Mode 4
   265 FF:1F2B: A0 1F           	LDY	#>Mode2Parameters
   266 FF:1F2D: 20 F1 1F             jsr     Set9918Parms
   267 FF:1F30: 8B                   PHB
   268                                SETBANK 0
+  268 FF:1F31: DA               PHX
+  268 FF:1F32: A2 00        	LDX #0
+  268 FF:1F34: DA           	PHX
+  268 FF:1F35: AB           	PLB
+  268 FF:1F36: FA               PLX
   269 FF:1F37: 22 70 FD 00          JSL LLOADFONTVec
   270 FF:1F3B: 22 6C FD 00          JSL LClearScrVec
   271 FF:1F3F: AB                   PLB
   272 FF:1F40: 60                   RTS
   273                        SETUPMODE3:
   274 FF:1F41: A9 DD               	LDA	#<Mode3Parameters	; point to Parameters for Mode 4
   275 FF:1F43: A0 1F           	LDY	#>Mode3Parameters
   276 FF:1F45: 20 F1 1F             jsr     Set9918Parms
   277                         ;       CLEAR RAM
   278                                INDEX16
+  278 FF:1F48: C2 10        		REP #$10 		; 16 bit Index registers
+  278                        		LONGI ON
   279 FF:1F4A: A2 00 00             LDX     #$0000
  Sun Nov 21 2021 15:13                                                                                                Page 56


   280 FF:1F4D: 86 07                STX     <LOCALWORK
   281                                INDEX8
+  281 FF:1F4F: E2 10        		SEP #$10 		; 8 bit Index registers
+  281                        		LONGI OFF
   282 FF:1F51: 20 2F 20             JSR     SET9918ADDRESS
   283                                INDEX16
+  283 FF:1F54: C2 10        		REP #$10 		; 16 bit Index registers
+  283                        		LONGI ON
   284 FF:1F56: A2 00 40             LDX     #$4000
   285 FF:1F59: A9 00                LDA     #$00
   286                        SETUPMODE3_1:
   287 FF:1F5B: 20 22 23             JSR     DELAY9918
   288 FF:1F5E: 8F 0A FE 00          STA     >DATAP
   289 FF:1F62: CA                   DEX
   290 FF:1F63: E0 00 00             CPX     #$0000
   291 FF:1F66: D0 F3                BNE     SETUPMODE3_1
   292                                INDEX8
+  292 FF:1F68: E2 10        		SEP #$10 		; 8 bit Index registers
+  292                        		LONGI OFF
   293 FF:1F6A: 60                   rts
   294                        
   295                        SETUPMODE4:
   296 FF:1F6B: A9 E7               	LDA	#<Mode4Parameters	; point to Parameters for Mode 4
   297 FF:1F6D: A0 1F           	LDY	#>Mode4Parameters
   298 FF:1F6F: 20 F1 1F             jsr     Set9918Parms
   299 FF:1F72: 8B                   PHB
   300                                SETBANK 0
+  300 FF:1F73: DA               PHX
+  300 FF:1F74: A2 00        	LDX #0
+  300 FF:1F76: DA           	PHX
+  300 FF:1F77: AB           	PLB
+  300 FF:1F78: FA               PLX
   301                                ;       CLEAR RAM
   302                                INDEX16
+  302 FF:1F79: C2 10        		REP #$10 		; 16 bit Index registers
+  302                        		LONGI ON
   303 FF:1F7B: A2 00 00             LDX     #$0000
   304 FF:1F7E: 86 07                STX     <LOCALWORK
   305                                INDEX8
+  305 FF:1F80: E2 10        		SEP #$10 		; 8 bit Index registers
+  305                        		LONGI OFF
   306 FF:1F82: 20 2F 20             JSR     SET9918ADDRESS
   307                                INDEX16
+  307 FF:1F85: C2 10        		REP #$10 		; 16 bit Index registers
+  307                        		LONGI ON
   308 FF:1F87: A2 00 40             LDX     #$4000
   309 FF:1F8A: A9 00                LDA     #$00
   310                        SETUPMODE4_1:
   311 FF:1F8C: 20 22 23             JSR     DELAY9918
   312 FF:1F8F: 8F 0A FE 00          STA     >DATAP
   313 FF:1F93: CA                   DEX
   314 FF:1F94: E0 00 00             CPX     #$0000
   315 FF:1F97: D0 F3                BNE     SETUPMODE4_1
   316 FF:1F99: 20 22 23             JSR     DELAY9918
   317                                ;       POPULATE NAME TABLE
   318 FF:1F9C: A2 00 38             LDX     #$3800
   319 FF:1F9F: 86 07                STX     <LOCALWORK
  Sun Nov 21 2021 15:13                                                                                                Page 57


   320                                INDEX8
+  320 FF:1FA1: E2 10        		SEP #$10 		; 8 bit Index registers
+  320                        		LONGI OFF
   321 FF:1FA3: 20 2F 20             JSR     SET9918ADDRESS
   322                                INDEX16
+  322 FF:1FA6: C2 10        		REP #$10 		; 16 bit Index registers
+  322                        		LONGI ON
   323 FF:1FA8: A2 00 03             LDX     #$0300
   324 FF:1FAB: A9 00                LDA     #$00
   325                        SETUPMODE4_2:
   326 FF:1FAD: 20 22 23             JSR     DELAY9918
   327 FF:1FB0: 8F 0A FE 00          STA     >DATAP
   328 FF:1FB4: 1A                   INC
   329 FF:1FB5: CA                   DEX
   330 FF:1FB6: E0 00 00             CPX     #$0000
   331 FF:1FB9: D0 F2                BNE     SETUPMODE4_2
   332                                INDEX8
+  332 FF:1FBB: E2 10        		SEP #$10 		; 8 bit Index registers
+  332                        		LONGI OFF
   333 FF:1FBD: AB                   PLB
   334 FF:1FBE: 60                   rts
   335                        
   336                        Mode0Parameters:
   337 FF:1FBF: 00 C0 05 80          .db     $00,$C0,$05,$80,$01,$20,$00,$01
       FF:1FC3: 01 20 00 01 
   338 FF:1FC7: 10                   .dB     $10                   ; Sprite attribute table
   339 FF:1FC8: 00                   .dB     $00                   ; Sprite Pattern Table
   340                        
   341                        Mode1Parameters:
   342 FF:1FC9: 00 CB 01 80          .db    $00,$CB,$01,$80,$01,$0E,$00,$F1
       FF:1FCD: 01 0E 00 F1 
   343 FF:1FD1: 07                   .dB    $07                   ; Sprite attribute table
   344 FF:1FD2: 00                   .dB    $00                   ; Sprite Pattern Table
   345                        
   346                        Mode2Parameters:
   347 FF:1FD3: 00 D0 01 80          .db    $00,$D0,$01,$80,$01,$0E,$00,$F4
       FF:1FD7: 01 0E 00 F4 
   348 FF:1FDB: 07                   .dB    $07                   ; Sprite attribute table
   349 FF:1FDC: 00                   .dB    $00                   ; Sprite Pattern Table
   350                        
   351                        Mode3Parameters:
   352 FF:1FDD: 02 C2 0E 9F          .db    $02,$C2,$0E,$9F,$00,$76,$03,$F0
       FF:1FE1: 00 76 03 F0 
   353 FF:1FE5: 3B                   .dB    $3b                   ; Sprite attribute table
   354 FF:1FE6: 18                   .dB    $18                   ; Sprite Pattern Table
   355                        
   356                        Mode4Parameters:
   357 FF:1FE7: 02 C2 0E FF          .db    $02,$C2,$0E,$FF,$03,$76,$03,$F0
       FF:1FEB: 03 76 03 F0 
   358 FF:1FEF: 3B                   .dB    $3b                   ; Sprite attribute table
   359 FF:1FF0: 18                   .dB    $18                   ; Sprite Pattern Table
   360                        
   361                        Set9918Parms:
   362                                ; copy parms and set sprite table vectors
   363 FF:1FF1: 85 07                sta     <LOCALWORK
   364 FF:1FF3: 84 08                sty     <LOCALWORK+1
   365 FF:1FF5: A0 00                ldy     #$00
  Sun Nov 21 2021 15:13                                                                                                Page 58


   366                        Set9918Parms1:
   367 FF:1FF7: 8B                   PHB
   368                                SETBANK PROGRAMBANK
+  368 FF:1FF8: DA               PHX
+  368 FF:1FF9: A2 FF        	LDX #PROGRAMBANK
+  368 FF:1FFB: DA           	PHX
+  368 FF:1FFC: AB           	PLB
+  368 FF:1FFD: FA               PLX
   369 FF:1FFE: B1 07                lda (<LOCALWORK),Y
   370                                setbank 0
+  370 FF:2000: DA               PHX
+  370 FF:2001: A2 00        	LDX #0
+  370 FF:2003: DA           	PHX
+  370 FF:2004: AB           	PLB
+  370 FF:2005: FA               PLX
   371 FF:2006: 8F 0B FE 00          sta >CMDP
   372 FF:200A: 98                   TYA
   373 FF:200B: 18                   CLC
   374 FF:200C: 69 80                adc #$80
   375 FF:200E: 8F 0B FE 00          sta >CMDP
   376 FF:2012: AB                   plb
   377 FF:2013: C8                   iny
   378 FF:2014: C0 08                cpy #$08
   379 FF:2016: D0 DF                bne Set9918Parms1
   380 FF:2018: 18                   CLC
   381 FF:2019: 8B                   PHB
   382                                SETBANK PROGRAMBANK
+  382 FF:201A: DA               PHX
+  382 FF:201B: A2 FF        	LDX #PROGRAMBANK
+  382 FF:201D: DA           	PHX
+  382 FF:201E: AB           	PLB
+  382 FF:201F: FA               PLX
   383 FF:2020: B1 07                lda (<LOCALWORK),Y
   384 FF:2022: 8F 44 03 00          sta >SpriteAttrs
   385 FF:2026: C8                   iny
   386 FF:2027: B1 07                lda (<LOCALWORK),Y
   387 FF:2029: 8F 45 03 00          sta >SpritePatterns
   388 FF:202D: AB                   PLB
   389 FF:202E: 60                   rts
   390                        
   391                        SET9918ADDRESS:
   392 FF:202F: A5 07                LDA <LOCALWORK
   393 FF:2031: 8F 0B FE 00  	sta >CMDP
   394 FF:2035: 20 22 23             JSR DELAY9918
   395 FF:2038: A5 08        	LDA <LOCALWORK+1
   396 FF:203A: 09 40        	ORA #$40
   397 FF:203C: 29 7F        	AND #$7F
   398 FF:203E: 8F 0B FE 00  	sta >CMDP
   399 FF:2042: 60                   RTS
   400                        
   401                        
   402                        ;___V_SPRITE________________________________________________
   403                        ;
   404                        ;  SET SPRITE PARAMETERS
   405                        ;
   406                        ;  TAKES SIX PARAMETERS
   407                        ;       SPRITE NUM (0-32)
  Sun Nov 21 2021 15:13                                                                                                Page 59


   408                        ;       SPRITE PATTERN (0-255)
   409                        ;       X CORD (0-255)
   410                        ;       Y CORD (0-255)
   411                        ;       COLOR  (0-15)
   412                        ;       LEFT SHIFT BIT (0/1)
   413                        ; THIS IS NATIVE '816 CODE
   414                        ;__________________________________________________________
   415                        V_SPRITE:
   416 FF:2043: 8B                   PHB
   417 FF:2044: 20 9E 40             JSR	LAB_GTBY    ; GET THE FIRST PARAMETER, RETURN IN X (SPRITE#)
   418 FF:2047: 8A                   TXA
   419 FF:2048: 29 1F                AND     #$1F
   420 FF:204A: 18                   CLC
   421 FF:204B: 0A                   ASL                 ; A=A*4
   422 FF:204C: 0A                   ASL
   423 FF:204D: 85 07                STA     <LOCALWORK
   424 FF:204F: 20 24 35             JSR	LAB_1C01    ; GET THE SECOND PARAMETER (AFTER ',') OR SYN ERR
   425 FF:2052: 20 9E 40             JSR	LAB_GTBY    ; GET THE SECOND PARAMETER, RETURN IN X (PATTERN)
   426 FF:2055: DA                   PHX
   427 FF:2056: 20 24 35             JSR	LAB_1C01    ; GET THE THIRD PARAMETER (AFTER ',') OR SYN ERR
   428 FF:2059: 20 9E 40             JSR	LAB_GTBY    ; GET THE THIRD PARAMETER, RETURN IN X (X CORD)
   429 FF:205C: DA                   PHX
   430 FF:205D: 20 24 35             JSR	LAB_1C01    ; GET THE FOURTH PARAMETER (AFTER ',') OR SYN ERR
   431 FF:2060: 20 9E 40             JSR	LAB_GTBY    ; GET THE FOURTH PARAMETER, RETURN IN X (Y CORD)
   432 FF:2063: DA                   PHX
   433 FF:2064: 20 24 35             JSR	LAB_1C01    ; GET THE FIFTH PARAMETER (AFTER ',') OR SYN ERR
   434 FF:2067: 20 9E 40             JSR	LAB_GTBY    ; GET THE FIFTH PARAMETER, RETURN IN X (COLOR)
   435 FF:206A: 8A                   TXA
   436 FF:206B: 29 0F                AND     #$0F
   437 FF:206D: 48                   PHA
   438 FF:206E: 20 24 35             JSR	LAB_1C01    ; GET THE SIXTH PARAMETER (AFTER ',') OR SYN ERR
   439 FF:2071: 20 9E 40             JSR	LAB_GTBY    ; GET THE SIXTH PARAMETER, RETURN IN X (EARLY CLOCK)
   440 FF:2074: 8A                   TXA
   441 FF:2075: 29 01                AND    #01
   442 FF:2077: C9 00                CMP     #$00
   443 FF:2079: F0 04                BEQ   NOSHIFT
   444 FF:207B: 68                   PLA
   445 FF:207C: 09 80                ORA  #$80
   446 FF:207E: 48                   PHA
   447                        NOSHIFT:
   448                                SETBANK 0
+  448 FF:207F: DA               PHX
+  448 FF:2080: A2 00        	LDX #0
+  448 FF:2082: DA           	PHX
+  448 FF:2083: AB           	PLB
+  448 FF:2084: FA               PLX
   449 FF:2085: A5 07                LDA     <LOCALWORK
   450 FF:2087: 8D 0B FE     	sta	CMDP
   451 FF:208A: 20 22 23             jsr     DELAY9918
   452 FF:208D: AD 44 03             LDA     SpriteAttrs
   453 FF:2090: 09 40                ORA 	#$40
   454 FF:2092: 8D 0B FE     	sta	CMDP
   455 FF:2095: 68                   PLA                     ; COLOR
   456 FF:2096: 85 07                STA     <LOCALWORK
   457 FF:2098: 7A                   PLY                     ; VERTICAL POSITION
   458 FF:2099: FA                   PLX                     ; HORIZONTAL POSITION
   459 FF:209A: 68                   PLA                     ; NAME TABLE LOCATION
  Sun Nov 21 2021 15:13                                                                                                Page 60


   460 FF:209B: 20 22 23             jsr     DELAY9918
   461 FF:209E: 8C 0A FE             STY     DATAP
   462 FF:20A1: 20 22 23             jsr     DELAY9918
   463 FF:20A4: 8E 0A FE             STX     DATAP
   464 FF:20A7: 20 22 23             jsr     DELAY9918
   465 FF:20AA: 8D 0A FE             STA     DATAP
   466 FF:20AD: 20 22 23             jsr     DELAY9918
   467 FF:20B0: A5 07                LDA     <LOCALWORK
   468 FF:20B2: 8D 0A FE             STA     DATAP
   469 FF:20B5: AB                   plb
   470 FF:20B6: 60                   RTS
   471                        
   472                        
   473                        ;___V_SPRDEF________________________________________________
   474                        ;
   475                        ;  DEFINE SPRITE PATTERN
   476                        ;
   477                        ;  TAKES 9 OR 17 PARAMETERS
   478                        ;       SPRITE NUM (0-32)
   479                        ;       SPRITE PATTERN DATA (8 BYTES OR 16 BYTES)
   480                        ; THIS IS NATIVE '816 CODE
   481                        ;__________________________________________________________
   482                        V_SPRDEF:
   483 FF:20B7: 20 9E 40             JSR	LAB_GTBY    ; GET THE FIRST PARAMETER, RETURN IN X (SPRITE#)
   484 FF:20BA: 8A                   TXA
   485                                ACCUMULATOR16
+  485 FF:20BB: C2 20        		REP #$20 		; 16 bit Index registers
+  485                        		LONGA ON
   486 FF:20BD: 29 1F 00             AND     #$001F
   487 FF:20C0: 18                   CLC
   488 FF:20C1: 0A                   ASL                 ; A=A*8
   489 FF:20C2: 0A                   ASL
   490 FF:20C3: 0A                   ASL
   491 FF:20C4: 85 07                STA     <LOCALWORK
   492                                ACCUMULATOR8
+  492 FF:20C6: E2 20        		SEP #$20 		; 8 bit Index registers
+  492                        		LONGA OFF
   493 FF:20C8: 8B                   PHB
   494                                SETBANK 0
+  494 FF:20C9: DA               PHX
+  494 FF:20CA: A2 00        	LDX #0
+  494 FF:20CC: DA           	PHX
+  494 FF:20CD: AB           	PLB
+  494 FF:20CE: FA               PLX
   495 FF:20CF: A5 07                LDA     <LOCALWORK
   496 FF:20D1: 8D 0B FE     	sta	CMDP
   497 FF:20D4: 20 22 23             jsr     DELAY9918
   498 FF:20D7: AD 45 03             LDA     SpritePatterns
   499 FF:20DA: 18                   CLC
   500 FF:20DB: 65 08                ADC     <LOCALWORK+1
   501 FF:20DD: 09 40                ORA 	#$40
   502 FF:20DF: 8D 0B FE     	sta	CMDP
   503 FF:20E2: AB                   PLB
   504                        SPRDEF_PLOOP:
   505 FF:20E3: A9 2C        	LDA	#$2C			; load A with ","
   506 FF:20E5: A0 00               	LDY	#$00			; clear index
   507 FF:20E7: D1 C3        	CMP (<Bpntrl),Y		        ; check next byte is ','
  Sun Nov 21 2021 15:13                                                                                                Page 61


   508 FF:20E9: D0 14        	BNE	SPRDEF_EXIT	        ; if not EXIT
   509 FF:20EB: 22 BC 00 00  	JSL	LAB_IGBY		; increment
   510 FF:20EF: 20 9E 40             JSR	LAB_GTBY                ; GET SPRITE DATA
   511 FF:20F2: 8B                   PHB
   512                                SETBANK 0
+  512 FF:20F3: DA               PHX
+  512 FF:20F4: A2 00        	LDX #0
+  512 FF:20F6: DA           	PHX
+  512 FF:20F7: AB           	PLB
+  512 FF:20F8: FA               PLX
   513 FF:20F9: 8E 0A FE             STX     DATAP
   514 FF:20FC: AB                   PLB
   515 FF:20FD: 80 E4                BRA     SPRDEF_PLOOP
   516                        SPRDEF_EXIT:
   517 FF:20FF: 60                   RTS
   518                        
   519                        
   520                        ;___LAB_VIDST_______________________________________________
   521                        ;
   522                        ; RETURN VIDEO STATUS BYTE
   523                        ;
   524                        ; THIS IS NATIVE '816 CODE
   525                        ;__________________________________________________________
   526                        LAB_VIDST
   527 FF:2100: 8B                   PHB
   528                                SETBANK 0
+  528 FF:2101: DA               PHX
+  528 FF:2102: A2 00        	LDX #0
+  528 FF:2104: DA           	PHX
+  528 FF:2105: AB           	PLB
+  528 FF:2106: FA               PLX
   529 FF:2107: AD 0B FE             LDA CMDP     ; get VIDEO ST into low byte
   530 FF:210A: A8                   TAY
   531 FF:210B: AB                   PLB
   532 FF:210C: A9 00                LDA	#0		    ; NO high byte
   533 FF:210E: 20 BD 39             JSR	LAB_AYFC
   534 FF:2111: 60                   RTS
   535 FF:2112: 46 5F                LSR	<Dtypef		    ; clear data type flag, $FF=string, $00=numeric
   536 FF:2114: 22 BC 00 00          JSL	LAB_IGBY	    ; increment and scan memory then do function
   537 FF:2118: 60                   RTS
   538                        LAB_PVIDST
   539 FF:2119: 46 5F        	LSR	<Dtypef		; clear data type flag, $FF=string, $00=numeric
   540 FF:211B: 22 BC 00 00  	JSL	LAB_IGBY		; increment and scan memory then do function
   541 FF:211F: 60           	RTS
   542                        
   543                        
   544                        ;___SPRSIZE_________________________________________________
   545                        ;
   546                        ; SET SPRITE SIZE AND MAGNIFICATION
   547                        ;
   548                        ;  TAKES ONE PARAMETER
   549                        ;
   550                        ; 0= 8X8 SPRITES, 1x DISPLAY
   551                        ; 1= 8X8 SPRITES, 2X DISPLAY
   552                        ; 2= 16X16 SPRITES, 1X DISPLAY
   553                        ; 3= 16X16 SPRITES, 2X DISPLAY
   554                        ;
  Sun Nov 21 2021 15:13                                                                                                Page 62


   555                        ; THIS IS NATIVE '816 CODE
   556                        ;__________________________________________________________
   557                        V_SPRSIZE:
   558 FF:2120: 20 9E 40             JSR	LAB_GTBY    ; GET THE FIRST PARAMETER, RETURN IN X (MODE)
   559 FF:2123: DA                   PHX
   560 FF:2124: A6 06                LDX     <VIDEOMODE
   561 FF:2126: 8A                   TXA
   562 FF:2127: 29 03                AND     #$03
   563 FF:2129: 18                   CLC
   564 FF:212A: 0A                   ASL
   565 FF:212B: 0A                   ASL
   566 FF:212C: 0A                   ASL
   567 FF:212D: 09 C0                ORA     #$C0
   568 FF:212F: 29 D8                AND     #$D8
   569 FF:2131: 85 04                STA     <TMPFLG
   570 FF:2133: 68                   PLA
   571 FF:2134: 29 03                AND     #$03
   572 FF:2136: 18                   CLC
   573 FF:2137: 65 04                ADC     <TMPFLG
   574 FF:2139: 8B                   PHB
   575 FF:213A: 48                   PHA
   576                                SETBANK 0
+  576 FF:213B: DA               PHX
+  576 FF:213C: A2 00        	LDX #0
+  576 FF:213E: DA           	PHX
+  576 FF:213F: AB           	PLB
+  576 FF:2140: FA               PLX
   577                        ;       SET Register 1
   578 FF:2141: 68                   PLA
   579 FF:2142: 8D 0B FE             STA	CMDP
   580 FF:2145: 20 22 23             jsr     DELAY9918
   581 FF:2148: A9 81                LDA     #$81
   582 FF:214A: 8D 0B FE     	STA	CMDP
   583 FF:214D: AB                   PLB
   584 FF:214E: 60                   RTS
   585                        
   586                        
   587                        
   588                        ;___V_PLOT__________________________________________________
   589                        ;
   590                        ;  PLOT ON SCREEN
   591                        ;         VM= 1     TAKES THREE PARAMETERS,  X,Y,COLOR
   592                        ;         VM= 4     TAKES FOUR PARAMETERS,  X,Y,PRIORITY,COLOR
   593                        ;         VM= 0 AND 3     TAKES THREE PARAMETERS,  X,Y,PATTERN
   594                        ;
   595                        ;  0=GRAPHICS MODE (32X24)
   596                        ;  1=MULTICOLOR MODE (64X48 BLOCKS)
   597                        ;  2=TEXT MODE (40X24)
   598                        ;  3=GRAPHICS MODE 0, WITH MODE 2 COLOR (32X24 MULTICOLOR)
   599                        ;  4=GRAPHICS MODE 2 (32X24 MULTICOLOR)
   600                        ; THIS IS NATIVE '816 CODE
   601                        ;__________________________________________________________
   602                        V_PLOT:
   603 FF:214F: A5 06                LDA     <VIDEOMODE
   604 FF:2151: C9 01                CMP     #01
   605 FF:2153: D0 03                BNE     *+5
   606 FF:2155: 4C 75 21             JMP     PLOT_MULTICOLOR
  Sun Nov 21 2021 15:13                                                                                                Page 63


   607 FF:2158: C9 04                CMP     #04
   608 FF:215A: D0 03                BNE     *+5
   609 FF:215C: 4C FA 21             JMP     PLOT_GRII
   610 FF:215F: C9 00                CMP     #00
   611 FF:2161: D0 03                BNE     *+5
   612 FF:2163: 4C C7 22             JMP     PLOT_GRI
   613 FF:2166: C9 03                CMP     #03
   614 FF:2168: D0 03                BNE     *+5
   615 FF:216A: 4C C7 22             JMP     PLOT_GRI
   616                        
   617                        V_PLOT_ERR:
   618 FF:216D: A2 02                ldx #$02            ; SYNTAX ERROR
   619 FF:216F: 20 C1 28             jsr LAB_XERR
   620 FF:2172: 4C B2 29             JMP LAB_1319        ; RESET VARS, STACK AND RETURN CONTROL TO BASIC
   621                        PLOT_MULTICOLOR:
   622 FF:2175: 20 9E 40             JSR	LAB_GTBY    ; GET THE FIRST PARAMETER, RETURN IN X (X)
   623 FF:2178: DA                   PHX
   624 FF:2179: 20 24 35             JSR	LAB_1C01    ; GET THE SECOND PARAMETER (AFTER ',') OR SYN ERR
   625 FF:217C: 20 9E 40             JSR	LAB_GTBY    ; GET THE SECOND PARAMETER, RETURN IN X (Y)
   626 FF:217F: DA                   PHX
   627 FF:2180: 20 24 35             JSR	LAB_1C01    ; GET THE SECOND PARAMETER (AFTER ',') OR SYN ERR
   628 FF:2183: 20 9E 40             JSR	LAB_GTBY    ; GET THE SECOND PARAMETER, RETURN IN X (COLOR)
   629 FF:2186: 8A                   TXA                     ; GET COLOR
   630 FF:2187: 7A                   PLY                     ; GET Y COORD
   631 FF:2188: FA                   PLX                     ; GET X COORD
   632 FF:2189: 8B                   PHB                     ; STASH BANK
   633 FF:218A: 48                   PHA                     ; STASH COLOR
   634 FF:218B: 5A                   PHY                     ; STASH Y COORD
   635                                SETBANK 0
+  635 FF:218C: DA               PHX
+  635 FF:218D: A2 00        	LDX #0
+  635 FF:218F: DA           	PHX
+  635 FF:2190: AB           	PLB
+  635 FF:2191: FA               PLX
   636                                ACCUMULATOR16
+  636 FF:2192: C2 20        		REP #$20 		; 16 bit Index registers
+  636                        		LONGA ON
   637                                                        ; SET Y CORD = Y/8 * 32
   638 FF:2194: 98                   TYA
   639 FF:2195: 29 F8 00             AND #$00F8
   640 FF:2198: 18                   CLC
   641 FF:2199: 0A                   ASL
   642 FF:219A: 0A                   ASL
   643 FF:219B: 0A                   ASL
   644 FF:219C: 0A                   ASL
   645 FF:219D: 0A                   ASL
   646 FF:219E: 85 07                STA <LOCALWORK
   647 FF:21A0: 7A                   PLY
   648 FF:21A1: 98                   TYA
   649 FF:21A2: 29 07 00             AND #$0007              ; GET REMAINDER
   650 FF:21A5: 18                   CLC
   651 FF:21A6: 65 07                ADC <LOCALWORK
   652 FF:21A8: 85 07                STA <LOCALWORK          ; STASH Y PART OF ADDRESS
   653 FF:21AA: 8A                   TXA
   654 FF:21AB: 29 FE 00             AND #$00FE              ;
   655 FF:21AE: 18                   CLC
   656 FF:21AF: 0A                   ASL
  Sun Nov 21 2021 15:13                                                                                                Page 64


   657 FF:21B0: 0A                   ASL
   658 FF:21B1: 65 07                ADC <LOCALWORK
   659 FF:21B3: 69 00 08             ADC #2048
   660 FF:21B6: 85 07                STA <LOCALWORK
   661 FF:21B8: 85 11                STA <Itempl
   662                                ACCUMULATOR8
+  662 FF:21BA: E2 20        		SEP #$20 		; 8 bit Index registers
+  662                        		LONGA OFF
   663 FF:21BC: 20 EC 1D             JSR SPEEK_1
   664 FF:21BF: 20 22 23             jsr     DELAY9918
   665 FF:21C2: 48                   pha
   666 FF:21C3: A5 07                LDA <LOCALWORK
   667 FF:21C5: 8D 0B FE     	sta CMDP
   668 FF:21C8: 20 22 23             jsr     DELAY9918
   669 FF:21CB: A5 08                LDA <LOCALWORK+1
   670 FF:21CD: 09 40        	ORA #$40
   671 FF:21CF: 29 7F        	AND #$7F
   672 FF:21D1: 8D 0B FE     	sta CMDP
   673 FF:21D4: 8A                   TXA
   674 FF:21D5: 29 01                AND #$01
   675 FF:21D7: C9 01                CMP #$01
   676 FF:21D9: D0 0C                BNE PLOTMODE2_HB
   677 FF:21DB: 68                   PLA
   678 FF:21DC: 29 F0                AND #$F0
   679 FF:21DE: 85 07                STA <LOCALWORK
   680 FF:21E0: 68                   PLA
   681 FF:21E1: 29 0F                AND #$0F
   682 FF:21E3: 05 07                ORA <LOCALWORK
   683 FF:21E5: 80 0E                BRA PLOTMODE2_GO
   684                        PLOTMODE2_HB:
   685 FF:21E7: 68                   PLA
   686 FF:21E8: 29 0F                AND #$0F
   687 FF:21EA: 85 07                STA <LOCALWORK
   688 FF:21EC: 68                   PLA
   689 FF:21ED: 29 0F                AND #$0F
   690 FF:21EF: 0A                   ASL
   691 FF:21F0: 0A                   ASL
   692 FF:21F1: 0A                   ASL
   693 FF:21F2: 0A                   ASL
   694 FF:21F3: 05 07                ORA <LOCALWORK
   695                        PLOTMODE2_GO:
   696 FF:21F5: 8D 0A FE             STA DATAP
   697 FF:21F8: AB                   PLB
   698 FF:21F9: 60                   RTS
   699                        PLOT_GRII:
   700 FF:21FA: 20 9E 40             JSR	LAB_GTBY    ; GET THE FIRST PARAMETER, RETURN IN X (X)
   701 FF:21FD: DA                   PHX
   702 FF:21FE: 20 24 35             JSR	LAB_1C01    ; GET THE SECOND PARAMETER (AFTER ',') OR SYN ERR
   703 FF:2201: 20 9E 40             JSR	LAB_GTBY    ; GET THE SECOND PARAMETER, RETURN IN X (Y)
   704 FF:2204: DA                   PHX
   705 FF:2205: 20 24 35             JSR	LAB_1C01    ; GET THE THIRD PARAMETER (AFTER ',') OR SYN ERR
   706 FF:2208: 20 9E 40             JSR	LAB_GTBY    ; GET THE THIRD PARAMETER, RETURN IN X (FG/BG)
   707 FF:220B: DA                   PHX
   708 FF:220C: 20 24 35             JSR	LAB_1C01    ; GET THE THIRD PARAMETER (AFTER ',') OR SYN ERR
   709 FF:220F: 20 9E 40             JSR	LAB_GTBY    ; GET THE THIRD PARAMETER, RETURN IN X (COLOR)
   710 FF:2212: 86 11                STX     <Itempl     ; STASH COLOR INFO HERE
   711 FF:2214: FA                   PLX
  Sun Nov 21 2021 15:13                                                                                                Page 65


   712 FF:2215: 86 12                STX     <Itemph     ; STASH PRIORITY HERE
   713 FF:2217: 7A                   PLY                 ; GET Y COORD
   714 FF:2218: FA                   PLX                 ; GET X COORD
   715                                ACCUMULATOR16
+  715 FF:2219: C2 20        		REP #$20 		; 16 bit Index registers
+  715                        		LONGA ON
   716 FF:221B: 98                   TYA
   717 FF:221C: 29 F8 00             AND #$00F8
   718 FF:221F: 18                   CLC
   719 FF:2220: 0A                   ASL                     ; Y COORD
   720 FF:2221: 0A                   ASL
   721 FF:2222: 0A                   ASL
   722 FF:2223: 0A                   ASL
   723 FF:2224: 0A                   ASL
   724 FF:2225: 85 07                STA <LOCALWORK
   725 FF:2227: 98                   TYA
   726 FF:2228: 29 07 00             AND #$0007
   727 FF:222B: 18                   CLC
   728 FF:222C: 65 07                ADC <LOCALWORK
   729 FF:222E: 85 07                STA <LOCALWORK
   730 FF:2230: 8A                   TXA
   731 FF:2231: 29 F8 00             AND #$00F8
   732 FF:2234: 18                   CLC
   733 FF:2235: 65 07                ADC <LOCALWORK
   734 FF:2237: 85 07                STA <LOCALWORK          ; BYTE OFFSET FOR COLOR AND PATTERN NOW IN LOCAL WORK
   735                                                        ; FIND PATTERN
   736 FF:2239: 8A                   TXA
   737 FF:223A: 29 07 00             AND     #$0007
   738 FF:223D: 18                   CLC
   739 FF:223E: 69 BF 22             ADC     #BITPATTERN
   740 FF:2241: 8B                   PHB
   741                                setbank PROGRAMBANK
+  741 FF:2242: DA               PHX
+  741 FF:2243: A2 FF        	LDX #PROGRAMBANK
+  741 FF:2245: DA           	PHX
+  741 FF:2246: AB           	PLB
+  741 FF:2247: FA               PLX
   742                                INDEX16
+  742 FF:2248: C2 10        		REP #$10 		; 16 bit Index registers
+  742                        		LONGI ON
   743 FF:224A: AA                   TAX
   744                                ACCUMULATOR8
+  744 FF:224B: E2 20        		SEP #$20 		; 8 bit Index registers
+  744                        		LONGA OFF
   745 FF:224D: BD 00 00             LDA     0,x
   746 FF:2250: AB                   plb
   747 FF:2251: 85 71                STA <Temp_2            ; Temp_2 NOW CONTAINS THE MASK
   748                                Index8
+  748 FF:2253: E2 10        		SEP #$10 		; 8 bit Index registers
+  748                        		LONGI OFF
   749                                                       ; FIGURE PRIORITY - ZERO CLEARS BIT, NONZERO SETS BIT
   750 FF:2255: A5 11                LDA     <Itempl        ; PUT COLOR ON STACK
   751 FF:2257: 48                   PHA
   752 FF:2258: A5 12                LDA     <Itemph         ; PUT PRIORITY ON STACK
   753 FF:225A: 48                   PHA
   754                                                        ; GET EXISTING VALUE
   755                                ACCUMULATOR16
  Sun Nov 21 2021 15:13                                                                                                Page 66


+  755 FF:225B: C2 20        		REP #$20 		; 16 bit Index registers
+  755                        		LONGA ON
   756 FF:225D: A5 07                LDA     <LOCALWORK
   757 FF:225F: 85 11                STA     <Itempl
   758                                ACCUMULATOR8
+  758 FF:2261: E2 20        		SEP #$20 		; 8 bit Index registers
+  758                        		LONGA OFF
   759 FF:2263: 20 EC 1D             JSR SPEEK_1
   760 FF:2266: 85 11                STA     <Itempl        ; STASH VALUE HERE
   761 FF:2268: 68                   PLA                    ; GET PRIORITY
   762 FF:2269: C9 00                CMP     #$00
   763 FF:226B: D0 09                BNE    PLOT_GRII_SET
   764                        ; CLEAR BIT
   765 FF:226D: A5 71                LDA <Temp_2             ; GET MASK
   766 FF:226F: 49 FF                EOR #$FF
   767 FF:2271: 25 11                AND <Itempl             ; VALUE TO STORE IS NOW IN A
   768 FF:2273: 48                   PHA                     ; PLACE IT ON STACK
   769 FF:2274: 80 05                BRA PLOT_GRII_2
   770                        ;SET BIT
   771                        PLOT_GRII_SET:
   772 FF:2276: A5 71                LDA <Temp_2             ; GET MASK
   773 FF:2278: 05 11                ORA <Itempl             ; VALUE TO STORE IS NOW IN A
   774 FF:227A: 48                   PHA                     ; PLACE IT ON STACK
   775                        PLOT_GRII_2:
   776 FF:227B: A5 07                LDA <LOCALWORK          ; SET WRITE ADDRESS
   777 FF:227D: 8F 0B FE 00  	sta >CMDP
   778 FF:2281: 20 22 23             JSR DELAY9918
   779 FF:2284: A5 08                LDA <LOCALWORK+1
   780 FF:2286: 09 40        	ORA #$40
   781 FF:2288: 29 7F        	AND #$7F
   782 FF:228A: 8F 0B FE 00  	sta >CMDP
   783 FF:228E: 20 22 23             JSR DELAY9918
   784 FF:2291: 68                   PLA                     ; GET MASK
   785 FF:2292: 8F 0A FE 00          STA >DATAP
   786 FF:2296: 20 22 23             JSR DELAY9918
   787                        ;; NOW DO COLOR
   788                                ACCUMULATOR16
+  788 FF:2299: C2 20        		REP #$20 		; 16 bit Index registers
+  788                        		LONGA ON
   789 FF:229B: A9 00 20             LDA #$2000
   790 FF:229E: 18                   CLC
   791 FF:229F: 65 07                ADC <LOCALWORK
   792 FF:22A1: 85 07                STA <LOCALWORK
   793                                ACCUMULATOR8
+  793 FF:22A3: E2 20        		SEP #$20 		; 8 bit Index registers
+  793                        		LONGA OFF
   794 FF:22A5: A5 07                LDA <LOCALWORK          ; SET WRITE ADDRESS
   795 FF:22A7: 8F 0B FE 00  	sta >CMDP
   796 FF:22AB: 20 22 23             JSR DELAY9918
   797 FF:22AE: A5 08                LDA <LOCALWORK+1
   798 FF:22B0: 09 40        	ORA #$40
   799 FF:22B2: 8F 0B FE 00  	sta >CMDP
   800 FF:22B6: 20 22 23             JSR DELAY9918
   801 FF:22B9: 68                   PLA                     ; GET COLOR
   802 FF:22BA: 8F 0A FE 00          STA >DATAP               ; STORE COLOR
   803 FF:22BE: 60                   RTS
   804                        BITPATTERN:
  Sun Nov 21 2021 15:13                                                                                                Page 67


   805 FF:22BF: 80 40 20 10          .DB     $80,$40,$20,$10,$08,$04,$02,$01
       FF:22C3: 08 04 02 01 
   806                                ; GR-1 && 3 Plot
   807                        PLOT_GRI:
   808 FF:22C7: 20 9E 40             JSR	LAB_GTBY    ; GET THE FIRST PARAMETER, RETURN IN X (X)
   809 FF:22CA: DA                   PHX
   810 FF:22CB: 20 24 35             JSR	LAB_1C01    ; GET THE SECOND PARAMETER (AFTER ',') OR SYN ERR
   811 FF:22CE: 20 9E 40             JSR	LAB_GTBY    ; GET THE SECOND PARAMETER, RETURN IN X (Y)
   812 FF:22D1: DA                   PHX
   813 FF:22D2: 20 24 35             JSR	LAB_1C01    ; GET THE THIRD PARAMETER (AFTER ',') OR SYN ERR
   814 FF:22D5: 20 9E 40             JSR	LAB_GTBY    ; GET THE THIRD PARAMETER, RETURN IN X (PATTERN#)
   815 FF:22D8: 86 12                STX     <Itemph     ; STASH PATTERN HERE
   816 FF:22DA: 7A                   PLY                 ; GET Y COORD
   817 FF:22DB: FA                   PLX                 ; GET X COORD
   818                                ACCUMULATOR16
+  818 FF:22DC: C2 20        		REP #$20 		; 16 bit Index registers
+  818                        		LONGA ON
   819 FF:22DE: 98                   TYA
   820 FF:22DF: 29 FF 00             AND #$00FF
   821 FF:22E2: 18                   CLC
   822 FF:22E3: 0A                   ASL                     ; Y COORD *32
   823 FF:22E4: 0A                   ASL
   824 FF:22E5: 0A                   ASL
   825 FF:22E6: 0A                   ASL
   826 FF:22E7: 0A                   ASL
   827 FF:22E8: 85 07                STA <LOCALWORK
   828 FF:22EA: 8A                   TXA
   829 FF:22EB: 29 FF 00             AND #$00FF
   830 FF:22EE: 18                   CLC
   831 FF:22EF: 65 07                ADC <LOCALWORK
   832 FF:22F1: A6 06                LDX <VIDEOMODE
   833 FF:22F3: E0 00                CPX #$00
   834 FF:22F5: F0 06                BEQ PLOT_GRI_A
   835 FF:22F7: 18                   CLC
   836 FF:22F8: 69 00 38             ADC #$3800           ; LOCALWORK CONTAINS NAMETABLE ADDRESS VM=3
   837 FF:22FB: 80 04                BRA PLOT_GRI_B
   838                        PLOT_GRI_A:
   839 FF:22FD: 18                   CLC
   840 FF:22FE: 69 00 14             ADC #$1400           ; LOCALWORK CONTAINS NAMETABLE ADDRESS VM=0
   841                        PLOT_GRI_B:
   842 FF:2301: 85 07                STA <LOCALWORK
   843                                ACCUMULATOR8
+  843 FF:2303: E2 20        		SEP #$20 		; 8 bit Index registers
+  843                        		LONGA OFF
   844 FF:2305: A5 07                LDA <LOCALWORK          ; SET PATTERN WRITE ADDRESS
   845 FF:2307: 8F 0B FE 00  	sta >CMDP
   846 FF:230B: 20 22 23             JSR DELAY9918
   847 FF:230E: A5 08                LDA <LOCALWORK+1
   848 FF:2310: 09 40        	ORA #$40
   849 FF:2312: 29 7F        	AND #$7F
   850 FF:2314: 8F 0B FE 00  	sta >CMDP
   851 FF:2318: 20 22 23             JSR DELAY9918
   852 FF:231B: A5 12                LDA <Itemph             ; GET PATTERN
   853 FF:231D: 8F 0A FE 00          STA >DATAP              ; STORE PATTERN
   854 FF:2321: 60                   RTS
   855                        
   856                        DELAY9918:
  Sun Nov 21 2021 15:13                                                                                                Page 68


   857 FF:2322: 48                   PHA
   858 FF:2323: 48                   PHA             ; MIGHT BE POSSIBLE TO REDUCE DELAY
   859 FF:2324: 68                   PLA
   860 FF:2325: 48                   PHA
   861 FF:2326: 68                   PLA
   862 FF:2327: 48                   PHA
   863 FF:2328: 68                   PLA
   864 FF:2329: 48                   PHA
   865 FF:232A: 68                   PLA
   866 FF:232B: 48                   PHA
   867 FF:232C: 68                   PLA
   868 FF:232D: 48                   PHA
   869 FF:232E: 68                   PLA
   870 FF:232F: 48                   PHA
   871 FF:2330: 68                   PLA
   872 FF:2331: 68                   PLA
   873 FF:2332: 60                   RTS
   874                        
   875                        ;___V_PATTERN________________________________________________
   876                        ;
   877                        ;  DEFINE GGRAPHICS PATTERN
   878                        ;
   879                        ;  TAKES 10 PARAMETERS
   880                        ;       PATTERN NUM (0-255)
   881                        ;       COLOR NUM (0-255)
   882                        ;       PATTERN DATA (8 BYTES)
   883                        ; THIS IS NATIVE '816 CODE
   884                        ;__________________________________________________________
   885                        V_PATTERN:
   886 FF:2333: A5 06                LDA     <VIDEOMODE
   887 FF:2335: C9 03                CMP     #03
   888 FF:2337: F0 7B                BEQ     V_PATTERN3GO
   889 FF:2339: C9 00                CMP     #00
   890 FF:233B: F0 08                BEQ     V_PATTERNGO
   891                                                        ; IF NOT IN MODE 0 OR MODE 3, SYNTAX ERROR
   892 FF:233D: A2 02                ldx #$02                ; SYNTAX ERROR
   893 FF:233F: 20 C1 28             jsr LAB_XERR            ;
   894 FF:2342: 4C B2 29             JMP LAB_1319            ; RESET VARS, STACK AND RETURN CONTROL TO BASIC
   895                                                        ;
   896                        V_PATTERNGO:
   897 FF:2345: 20 9E 40             JSR	LAB_GTBY    ; GET THE FIRST PARAMETER, RETURN IN X (PATTERN#)
   898 FF:2348: 8A                   TXA
   899                                ACCUMULATOR16
+  899 FF:2349: C2 20        		REP #$20 		; 16 bit Index registers
+  899                        		LONGA ON
   900 FF:234B: 29 FF 00             AND     #$00FF
   901 FF:234E: 48                   PHA
   902 FF:234F: 18                   CLC
   903 FF:2350: 0A                   ASL                 ; A=A*8
   904 FF:2351: 0A                   ASL
   905 FF:2352: 0A                   ASL
   906 FF:2353: 18                   CLC
   907 FF:2354: 69 00 08             ADC     #$0800
   908 FF:2357: 85 07                STA     <LOCALWORK
   909                                ACCUMULATOR8
+  909 FF:2359: E2 20        		SEP #$20 		; 8 bit Index registers
+  909                        		LONGA OFF
  Sun Nov 21 2021 15:13                                                                                                Page 69


   910 FF:235B: 20 24 35             JSR	LAB_1C01    ; GET THE SECOND PARAMETER (AFTER ',') OR SYN ERR
   911 FF:235E: 20 9E 40             JSR	LAB_GTBY    ; GET THE SECOND PARAMETER, RETURN IN X (COLOR)
   912 FF:2361: DA                   PHX
   913 FF:2362: A5 07                LDA     <LOCALWORK
   914 FF:2364: 8F 0B FE 00  	sta	>CMDP
   915 FF:2368: 20 22 23             JSR     DELAY9918
   916 FF:236B: A5 08                lda     <LOCALWORK+1
   917 FF:236D: 09 40                ORA 	#$40
   918 FF:236F: 8F 0B FE 00  	sta	>CMDP
   919                        V_PATTERN_PLOOP:
   920 FF:2373: A9 2C        	LDA	#$2C			; load A with ","
   921 FF:2375: A0 00               	LDY	#$00			; clear index
   922 FF:2377: D1 C3        	CMP     (<Bpntrl),Y	        ; check next byte is ','
   923 FF:2379: D0 0E        	BNE	V_PATTERN_EXIT	        ; if not EXIT
   924 FF:237B: 22 BC 00 00  	JSL	LAB_IGBY		; increment
   925 FF:237F: 20 9E 40             JSR	LAB_GTBY                ; GET PATTERN DATA
   926 FF:2382: 8A                   TXA
   927 FF:2383: 8F 0A FE 00          STA     >DATAP
   928 FF:2387: 80 EA                BRA     V_PATTERN_PLOOP
   929                        V_PATTERN_EXIT:
   930                        ; DO COLOR
   931 FF:2389: FA                   PLX
   932                                ACCUMULATOR16
+  932 FF:238A: C2 20        		REP #$20 		; 16 bit Index registers
+  932                        		LONGA ON
   933 FF:238C: 68                   PLA
   934 FF:238D: 4A                   LSR
   935 FF:238E: 4A                   LSR
   936 FF:238F: 4A                   LSR
   937 FF:2390: 4A                   LSR
   938 FF:2391: 4A                   LSR
   939 FF:2392: 18                   CLC
   940 FF:2393: 69 00 20             ADC   #$2000
   941 FF:2396: 85 07                STA   <LOCALWORK
   942                                ACCUMULATOR8
+  942 FF:2398: E2 20        		SEP #$20 		; 8 bit Index registers
+  942                        		LONGA OFF
   943 FF:239A: A5 07                LDA     <LOCALWORK
   944 FF:239C: 8F 0B FE 00  	sta	>CMDP
   945 FF:23A0: 20 22 23             JSR     DELAY9918
   946 FF:23A3: A5 08                LDA     <LOCALWORK+1
   947 FF:23A5: 09 40                ORA 	#$40
   948 FF:23A7: 8F 0B FE 00  	sta	>CMDP
   949 FF:23AB: 20 22 23             JSR     DELAY9918
   950 FF:23AE: 8A                   TXA
   951 FF:23AF: 8F 0A FE 00          STA     >DATAP
   952 FF:23B3: 60                   RTS
   953                        
   954                        
   955                        V_PATTERN3GO:
   956 FF:23B4: 20 9E 40             JSR	LAB_GTBY    ; GET THE FIRST PARAMETER, RETURN IN X (PATTERN#)
   957 FF:23B7: 8A                   TXA
   958                                ACCUMULATOR16
+  958 FF:23B8: C2 20        		REP #$20 		; 16 bit Index registers
+  958                        		LONGA ON
   959 FF:23BA: 29 FF 00             AND     #$00FF
   960 FF:23BD: 18                   CLC
  Sun Nov 21 2021 15:13                                                                                                Page 70


   961 FF:23BE: 0A                   ASL                 ; A=A*8
   962 FF:23BF: 0A                   ASL
   963 FF:23C0: 0A                   ASL
   964 FF:23C1: 85 07                STA     <LOCALWORK
   965                                ACCUMULATOR8
+  965 FF:23C3: E2 20        		SEP #$20 		; 8 bit Index registers
+  965                        		LONGA OFF
   966 FF:23C5: A5 07                lda     <LOCALWORK
   967 FF:23C7: 8F 0B FE 00          sta	>CMDP
   968 FF:23CB: 20 22 23             jsr     DELAY9918
   969 FF:23CE: A5 08                lda     <LOCALWORK+1
   970 FF:23D0: 09 40                ORA 	#$40
   971 FF:23D2: 8F 0B FE 00  	sta	>CMDP
   972 FF:23D6: A0 08                ldy     #$08
   973                        V_PATTERN3_PLOOP:
   974 FF:23D8: C0 00                cpy     #$00
   975 FF:23DA: F0 10                beq     V_PATTERN3_EXIT
   976 FF:23DC: 88                   dey
   977 FF:23DD: 5A                   phy
   978 FF:23DE: 20 24 35             JSR	LAB_1C01    ; GET THE SECOND PARAMETER (AFTER ',') OR SYN ERR
   979 FF:23E1: 20 9E 40             JSR	LAB_GTBY    ; GET THE FIRST PARAMETER, RETURN IN X (PATTERN#)
   980 FF:23E4: 7A                   PLY
   981 FF:23E5: 8A                   TXA
   982 FF:23E6: 8F 0A FE 00          STA     >DATAP
   983 FF:23EA: 80 EC                BRA     V_PATTERN3_PLOOP
   984                        V_PATTERN3_EXIT:
   985                        ; DO COLOR
   986 FF:23EC: A5 07                lda     <LOCALWORK
   987 FF:23EE: 8F 0B FE 00          sta	>CMDP
   988 FF:23F2: 20 22 23             jsr     DELAY9918
   989 FF:23F5: A5 08                lda     <LOCALWORK+1
   990 FF:23F7: 18                   CLC
   991 FF:23F8: 69 20                adc     #$20
   992 FF:23FA: 09 40                ORA 	#$40
   993 FF:23FC: 8F 0B FE 00  	sta	>CMDP
   994 FF:2400: A0 08                ldy     #$08
   995                        V_PATTERN3a_PLOOP:
   996 FF:2402: C0 00                cpy     #$00
   997 FF:2404: F0 10                beq     V_PATTERN3a_EXIT
   998 FF:2406: 88                   dey
   999 FF:2407: 5A                   phy
  1000 FF:2408: 20 24 35             JSR	LAB_1C01    ; GET THE SECOND PARAMETER (AFTER ',') OR SYN ERR
  1001 FF:240B: 20 9E 40             JSR	LAB_GTBY    ; GET THE FIRST PARAMETER, RETURN IN X (PATTERN#)
  1002 FF:240E: 7A                   PLY
  1003 FF:240F: 8A                   TXA
  1004 FF:2410: 8F 0A FE 00          STA     >DATAP
  1005 FF:2414: 80 EC                BRA     V_PATTERN3a_PLOOP
  1006                        V_PATTERN3a_EXIT:
  1007 FF:2416: 60                   RTS
   118                                .include 'ay38910.asm'
     1             0000FE10   via1regb	.equ	$FE10		; Register
     2             0000FE11   via1rega	.equ	$FE11		; Register
     3             0000FE12   via1ddrb	.equ	$FE12		; Register
     4             0000FE13   via1ddra	.equ	$FE13		; Register
     5             0000FE14   via1t1cl	.equ	$FE14		; Register
     6             0000FE15   via1t1ch	.equ	$FE15		; Register
     7             0000FE16   via1t1ll	.equ	$FE16		; Register
  Sun Nov 21 2021 15:13                                                                                                Page 71


     8             0000FE17   via1t1lh	.equ	$FE17		; Register
     9             0000FE18   via1t2cl	.equ	$FE18		; Register
    10             0000FE19   via1t2ch	.equ	$FE19		; Register
    11             0000FE1A   via1sr  	.equ	$FE1A		; Register
    12             0000FE1B   via1acr 	.equ	$FE1B		; Register
    13             0000FE1C   via1pcr 	.equ	$FE1C		; Register
    14             0000FE1D   via1ifr 	.equ	$FE1D		; Register
    15             0000FE1E   via1ier 	.equ	$FE1E		; Register
    16             0000FE1F   via1ora 	.equ	$FE1F		; Register
    17                        
    18                        
    19                        
    20                        ;___SOUND__________________________________________________
    21                        ;
    22                        ; PLAY SOUND
    23                        ;
    24                        ;  TAKES TWO PARAMETERS CHANNEL,FREQUENCY
    25                        ;
    26                        ; THIS IS NATIVE '816 CODE
    27                        ;__________________________________________________________
    28                        V_SOUND:
    29 FF:2417: 20 9E 40             JSR	LAB_GTBY    ; GET THE FIRST PARAMETER, RETURN IN X (CHANNEL)
    30 FF:241A: DA                   phx
    31 FF:241B: 20 24 35             JSR	LAB_1C01    ; (AFTER ',') OR SYN ERR
    32 FF:241E: 20 EE 33     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
    33                        					; else do type mismatch
    34 FF:2421: 20 42 41     	JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
    35                        
    36 FF:2424: 68           	PLA				; LIMIT THE CHANNELS TO <3
    37 FF:2425: 29 03        	AND 	#$03
    38 FF:2427: 18           	CLC
    39 FF:2428: 0A           	ASL				; = *2
    40 FF:2429: 48           	PHA
    41 FF:242A: A4 11        	LDY	<Itempl
    42 FF:242C: 20 51 25     	JSR 	psgwr			; SET LOW BYTE
    43 FF:242F: 68           	PLA
    44 FF:2430: 1A           	INC 	A
    45 FF:2431: A4 12        	LDY	<Itemph
    46 FF:2433: 20 51 25     	JSR 	psgwr			; SET HIGH BYTE
    47 FF:2436: 60           	RTS
    48                        
    49                        ;___VOLUME__________________________________________________
    50                        ;
    51                        ; SET VOLUME
    52                        ;
    53                        ;  TAKES TWO PARAMETERS CHANNEL,VOLUME
    54                        ;
    55                        ; THIS IS NATIVE '816 CODE
    56                        ;__________________________________________________________
    57                        V_VOLUME:
    58 FF:2437: 20 9E 40             JSR	LAB_GTBY    ; GET THE FIRST PARAMETER, RETURN IN X (CHANNEL)
    59 FF:243A: DA                   phx
    60 FF:243B: 20 24 35             JSR	LAB_1C01    ; (AFTER ',') OR SYN ERR
    61 FF:243E: 20 9E 40     	JSR	LAB_GTBY    ; GET THE SECOND PARAMETER, RETURN IN X (VOLUME)
    62 FF:2441: 9B           	TXY
    63 FF:2442: 68           	PLA				; LIMIT THE CHANNELS TO <3
    64 FF:2443: 29 03        	AND 	#$03
  Sun Nov 21 2021 15:13                                                                                                Page 72


    65                        
    66 FF:2445: 18           	clc
    67 FF:2446: 69 08        	ADC 	#08
    68 FF:2448: 20 51 25     	JSR 	psgwr
    69 FF:244B: 60           	RTS
    70                        
    71                        
    72                        ;___VOICE__________________________________________________
    73                        ;
    74                        ; SET VOICE
    75                        ;
    76                        ;  TAKES TWO PARAMETERS VOICE, ENVELOPE
    77                        ;
    78                        ; THIS IS NATIVE '816 CODE
    79                        ;__________________________________________________________
    80                        V_VOICE:
    81 FF:244C: 20 9E 40             JSR	LAB_GTBY    ; GET THE FIRST PARAMETER, RETURN IN X (CHANNEL)
    82 FF:244F: DA                   phx
    83 FF:2450: 20 24 35             JSR	LAB_1C01    ; (AFTER ',') OR SYN ERR
    84 FF:2453: 20 EE 33     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
    85                        					; else do type mismatch
    86 FF:2456: 20 42 41     	JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
    87 FF:2459: 7A           	PLY
    88 FF:245A: A9 0D        	LDA 	#13
    89 FF:245C: 20 51 25     	JSR 	psgwr
    90                        
    91 FF:245F: A9 0B        	LDA 	#11
    92 FF:2461: A4 11        	LDY	<Itempl
    93 FF:2463: 20 51 25     	JSR 	psgwr			; SET LOW BYTE
    94 FF:2466: A9 0C        	LDA 	#12
    95 FF:2468: A4 12        	LDY	<Itemph			; SET HIGH BYTE
    96 FF:246A: 20 51 25     	JSR 	psgwr
    97                        
    98 FF:246D: 60           	RTS
    99                        
   100                        
   101                        
   102                        
   103                        
   104                        ;___NOISE__________________________________________________
   105                        ;
   106                        ; SELECT NOISE CHANNEL
   107                        ;
   108                        ;  TAKES TWO PARAMETERS CHANNEL,FREQUENCY
   109                        ;
   110                        ; THIS IS NATIVE '816 CODE
   111                        ;__________________________________________________________
   112                        V_NOISE:
   113 FF:246E: 20 9E 40             JSR	LAB_GTBY    ; GET THE FIRST PARAMETER, RETURN IN X (CHANNEL)
   114 FF:2471: DA                   phx
   115 FF:2472: 20 24 35             JSR	LAB_1C01    ; (AFTER ',') OR SYN ERR
   116 FF:2475: 20 9E 40     	JSR	LAB_GTBY    ; GET THE SECOND PARAMETER, RETURN IN X (FREQ)
   117 FF:2478: 68           	PLA				; LIMIT THE CHANNELS TO <3
   118 FF:2479: DA           	PHX
   119 FF:247A: AA           	tAX
   120                        
   121 FF:247B: 29 1F        	AND 	#%00011111
  Sun Nov 21 2021 15:13                                                                                                Page 73


   122 FF:247D: A8           	TAY
   123 FF:247E: A9 06        	LDA 	#$06
   124 FF:2480: 20 51 25     	JSR 	psgwr			; SET NOISE FREQ
   125                        
   126 FF:2483: A9 07        	LDA 	#$07
   127 FF:2485: 20 0F 25     	JSR 	psgrd			; GET CONFIG
   128 FF:2488: 68           	PLA
   129 FF:2489: 5A           	PHY
   130 FF:248A: 29 03        	AND 	#$03
   131 FF:248C: AA           	TAX				; A=CONFIG, X=CHANNEL
   132 FF:248D: 68           	PLA
   133 FF:248E: E0 00        	CPX 	#$00
   134 FF:2490: D0 06        	BNE 	NOISE_1
   135 FF:2492: 29 37        	AND 	#%00110111
   136 FF:2494: 09 01        	ORA 	#%00000001
   137 FF:2496: 80 0E        	BRA 	NOISE_3
   138                        NOISE_1:
   139 FF:2498: E0 01        	CPX 	#$01
   140 FF:249A: D0 06        	BNE 	NOISE_2
   141 FF:249C: 29 2F        	AND 	#%00101111
   142 FF:249E: 09 02        	ORA 	#%00000010
   143 FF:24A0: 80 04        	BRA 	NOISE_3
   144                        NOISE_2:
   145 FF:24A2: 29 1F        	AND 	#%00011111
   146 FF:24A4: 09 04        	ORA 	#%00000100
   147                        NOISE_3:
   148 FF:24A6: A8           	TAY
   149 FF:24A7: A9 07        	LDA 	#$07
   150 FF:24A9: 20 51 25     	JSR 	psgwr			; SET LOW BYTE
   151 FF:24AC: 60           	RTS
   152                        
   153                        ;___TONE___________________________________________________
   154                        ;
   155                        ; SELECT TONE CHANNEL
   156                        ;
   157                        ;  TAKES ONE PARAMETER CHANNEL
   158                        ;
   159                        ; THIS IS NATIVE '816 CODE
   160                        ;__________________________________________________________
   161                        V_TONE:
   162 FF:24AD: 20 9E 40             JSR	LAB_GTBY    ; GET THE FIRST PARAMETER, RETURN IN X (CHANNEL)
   163 FF:24B0: DA           	PHX
   164                        
   165 FF:24B1: A9 07        	LDA 	#$07
   166 FF:24B3: 20 0F 25     	JSR 	psgrd			; GET CONFIG
   167 FF:24B6: 68           	PLA
   168 FF:24B7: 5A           	PHY
   169 FF:24B8: 29 03        	AND 	#$03
   170 FF:24BA: AA           	TAX				; A=CONFIG, X=CHANNEL
   171 FF:24BB: 68           	PLA
   172 FF:24BC: E0 00        	CPX 	#$00
   173 FF:24BE: D0 06        	BNE 	TONE_1
   174 FF:24C0: 29 3E        	AND 	#%00111110
   175 FF:24C2: 09 08        	ORA 	#%00001000
   176 FF:24C4: 80 0E        	BRA 	TONE_3
   177                        TONE_1:
   178 FF:24C6: E0 01        	CPX 	#$01
  Sun Nov 21 2021 15:13                                                                                                Page 74


   179 FF:24C8: D0 06        	BNE 	TONE_2
   180 FF:24CA: 29 3D        	AND 	#%00111101
   181 FF:24CC: 09 10        	ORA 	#%00010000
   182 FF:24CE: 80 04        	BRA 	TONE_3
   183                        TONE_2:
   184 FF:24D0: 29 3B        	AND 	#%00111011
   185 FF:24D2: 09 20        	ORA 	#%00100000
   186                        TONE_3:
   187 FF:24D4: A8           	TAY
   188 FF:24D5: A9 07        	LDA 	#$07
   189 FF:24D7: 20 51 25     	JSR 	psgwr			; SET LOW BYTE
   190 FF:24DA: 60           	RTS
   191                        
   192                        
   193                        ;___CONTROLLER_______________________________________________
   194                        ;
   195                        ; GET JOYTICK STATUS
   196                        ;
   197                        ;  TAKES ONE PARAMETERS JOYSTICK#, RETURNS STATUS
   198                        ;
   199                        ; THIS IS NATIVE '816 CODE
   200                        ;__________________________________________________________
   201                        LAB_CON:
   202 FF:24DB: 20 42 41     	JSR	LAB_F2FX	; GET THE PARAMETER, RETURN IN X (controller#)
   203 FF:24DE: A5 11        	LDA	<Itempl
   204 FF:24E0: 29 01        	and 	#$01
   205 FF:24E2: 18           	clc
   206 FF:24E3: 69 0E        	adc 	#14
   207 FF:24E5: 20 0F 25     	jsr 	psgrd	   	; return value in y
   208 FF:24E8: 4C CA 39     	JMP	LAB_1FD0	; convert Y to byte in FAC1 and return
   209                        
   210                        
   211                        
   212                        
   213                        ;___utility functions____________________________________________
   214                        psginit:
   215 FF:24EB: A9 9C        	LDA	#%10011100
   216 FF:24ED: 8F 13 FE 00  	STA	>via1ddra
   217 FF:24F1: A9 10        	LDA 	#%00010000
   218 FF:24F3: 8F 11 FE 00  	STA 	>via1rega
   219 FF:24F7: A9 FF        	LDA 	#$FF
   220 FF:24F9: 8F 12 FE 00  	STA	>via1ddrb
   221 FF:24FD: A9 00        	LDA 	#$00
   222 FF:24FF: 8F 10 FE 00  	STA 	>via1regb
   223 FF:2503: 60           	RTS
   224 FF:2504: 20 93 25     	JSR 	clrpsg
   225                        
   226 FF:2507: A9 07        	LDA 	#7
   227 FF:2509: A0 3F        	LDY 	#$3F
   228 FF:250B: 20 51 25     	JSR 	psgwr
   229 FF:250E: 60           	RTS
   230                        
   231                        psgrd:
   232 FF:250F: 8F 10 FE 00  	STA 	>via1regb	; select register
   233 FF:2513: A9 1C        	LDA 	#%00011100	; latch address
   234 FF:2515: 8F 11 FE 00  	STA	>via1rega
   235                        
  Sun Nov 21 2021 15:13                                                                                                Page 75


   236 FF:2519: 8F 11 FE 00  	STA	>via1rega
   237 FF:251D: 8F 11 FE 00  	STA	>via1rega
   238                        
   239 FF:2521: A9 10        	LDA 	#%00010000	; inact
   240 FF:2523: 8F 11 FE 00  	STA	>via1rega
   241                        
   242 FF:2527: 8F 11 FE 00  	STA	>via1rega
   243                        
   244 FF:252B: A9 00        	LDA 	#$00
   245 FF:252D: 8F 12 FE 00  	STA	>via1ddrb
   246 FF:2531: A9 18        	LDA 	#%00011000	; latch data
   247 FF:2533: 8F 11 FE 00  	STA	>via1rega
   248                        
   249 FF:2537: 8F 11 FE 00  	STA	>via1rega
   250 FF:253B: 8F 11 FE 00  	STA	>via1rega
   251                        
   252 FF:253F: AF 10 FE 00  	LDA 	>via1regb	; get data
   253 FF:2543: A8           	TAY
   254 FF:2544: A9 FF        	LDA 	#$FF
   255 FF:2546: 8F 12 FE 00  	STA	>via1ddrb
   256 FF:254A: A9 10        	LDA 	#%00010000	; inact
   257 FF:254C: 8F 11 FE 00  	STA	>via1rega
   258 FF:2550: 60           	RTS
   259                        
   260                        
   261                        psgwr:
   262 FF:2551: 8F 10 FE 00  	STA 	>via1regb	; select register
   263 FF:2555: A9 1C        	LDA 	#%00011100	; latch address
   264 FF:2557: 8F 11 FE 00  	STA	>via1rega
   265                        
   266 FF:255B: 8F 11 FE 00  	STA	>via1rega
   267 FF:255F: 8F 11 FE 00  	STA	>via1rega
   268                        
   269 FF:2563: A9 10        	LDA 	#%00010000	; inact
   270 FF:2565: 8F 11 FE 00  	STA	>via1rega
   271                        
   272 FF:2569: 8F 11 FE 00  	STA	>via1rega
   273 FF:256D: 8F 11 FE 00  	STA	>via1rega
   274 FF:2571: 98           	TYA
   275 FF:2572: 8F 10 FE 00  	STA 	>via1regb	; store data
   276                        
   277 FF:2576: 8F 10 FE 00  	STA 	>via1regb	; store data
   278 FF:257A: 8F 10 FE 00  	STA 	>via1regb	; store data
   279                        
   280 FF:257E: A9 14        	LDA 	#%00010100	; latch data
   281 FF:2580: 8F 11 FE 00  	STA	>via1rega
   282                        
   283 FF:2584: 8F 11 FE 00  	STA	>via1rega
   284 FF:2588: 8F 11 FE 00  	STA	>via1rega
   285                        
   286 FF:258C: A9 10        	LDA 	#%00010000	; inact
   287 FF:258E: 8F 11 FE 00  	STA	>via1rega
   288 FF:2592: 60           	RTS
   289                        
   290                        ;
   291                        ; Clear PSG registers to default
   292                        ;
  Sun Nov 21 2021 15:13                                                                                                Page 76


   293                        clrpsg:
   294                        	StoreContext
+  294 FF:2593: DA                   PHX
+  294 FF:2594: 5A                   phy
+  294 FF:2595: 48                   pha
+  294 FF:2596: 08                   php
   295                        	AccumulatorIndex8
+  295 FF:2597: E2 30        		SEP #$30 		; 8 bit Index registers
+  295                        		LONGA OFF
+  295                                LONGI OFF
   296 FF:2599: A2 00        	ldx	#00
   297 FF:259B: A0 00        	ldy	#00
   298                        clrpsg1:
   299 FF:259D: 8A           	txa
   300 FF:259E: 20 51 25     	jsr 	psgwr	; set register X to 0
   301 FF:25A1: E8           	inx
   302 FF:25A2: E0 11        	cpx 	#17
   303 FF:25A4: D0 F7        	bne	clrpsg1
   304                        	RestoreContext
+  304 FF:25A6: 28                   plp
+  304 FF:25A7: 68                   pla
+  304 FF:25A8: 7A                   ply
+  304 FF:25A9: FA                   plx
   305 FF:25AA: 60           	rts
   119                        
   120                        
   121                        
   122                        ;___TitleScreen_____________________________________________
   123                        ;
   124                        ; Basic Title Screen
   125                        ;
   126                        ; THIS IS NATIVE '816 CODE
   127                        ;__________________________________________________________
   128                        TitleScreen:
   129 FF:25AB: 20 EB 24             JSR psginit
   130 FF:25AE: A9 28                LDA #40
   131 FF:25B0: 8F 43 03 00          STA >VIDEOWIDTH
   132 FF:25B4: A9 02                LDA #2
   133 FF:25B6: 85 06                STA <VIDEOMODE
   134 FF:25B8: AF 41 03 00          lda >ConsoleDevice
   135 FF:25BC: C9 00                cmp #$00
   136 FF:25BE: D0 08                bne TitleScreen_1
   137 FF:25C0: A9 4B               	LDA	#<LAB_SMSG1		; point to sign-on message (low addr)
   138 FF:25C2: A0 16        	    LDY	#>LAB_SMSG1		; point to sign-on message (high addr)
   139 FF:25C4: 20 85 31     	    JSR	LAB_18C3		; print null terminated string from memory
   140 FF:25C7: 60                   rts
   141                        TitleScreen_1:
   142 FF:25C8: A2 02                LDX     #02
   143 FF:25CA: 20 4C 1E             JSR     V_SCREEN1
   144 FF:25CD: 8B                   PHB
   145                                SETBANK 0
+  145 FF:25CE: DA               PHX
+  145 FF:25CF: A2 00        	LDX #0
+  145 FF:25D1: DA           	PHX
+  145 FF:25D2: AB           	PLB
+  145 FF:25D3: FA               PLX
   146 FF:25D4: A9 F4                lda     #$F4
  Sun Nov 21 2021 15:13                                                                                                Page 77


   147 FF:25D6: 22 18 FD 00          JSL LSetColorVEC
   148 FF:25DA: A2 00                LDX #$00
   149 FF:25DC: 9B                   TXY
   150 FF:25DD: 22 0C FD 00          JSL LSetXYVEC
   151 FF:25E1: AB                   plb
   152 FF:25E2: A9 F8         	    LDA	#<LAB_CONMSG		; point to sign-on message (low addr)
   153 FF:25E4: A0 15        	    LDY	#>LAB_CONMSG		; point to sign-on message (high addr)
   154 FF:25E6: 20 85 31     	    JSR	LAB_18C3		; print null terminated string from memory
   155 FF:25E9: 60                   RTS
   156                        
   157                        ;___ScreenEditor____________________________________________
   158                        ;
   159                        ; Basic Screen editor code
   160                        ;
   161                        ; THIS IS NATIVE '816 CODE
   162                        ;__________________________________________________________
   163                        ScreenEditor:
   164 FF:25EA: 48                   pha
   165 FF:25EB: DA                   phx
   166 FF:25EC: 5A                   phy
   167 FF:25ED: 08                   php
   168                                AccumulatorIndex8
+  168 FF:25EE: E2 30        		SEP #$30 		; 8 bit Index registers
+  168                        		LONGA OFF
+  168                                LONGI OFF
   169 FF:25F0: 8B                   PHB
   170                                SETBANK 0
+  170 FF:25F1: DA               PHX
+  170 FF:25F2: A2 00        	LDX #0
+  170 FF:25F4: DA           	PHX
+  170 FF:25F5: AB           	PLB
+  170 FF:25F6: FA               PLX
   171                        ; allow prepopulate of screen
   172                        ploop:
   173 FF:25F7: 22 1C FD 00      jsl LCURSORVEC
   174 FF:25FB: 22 08 FD 00      jsl LINPWVEC
   175 FF:25FF: C9 FF            cmp #$FF
   176 FF:2601: F0 F4            beq ploop
   177 FF:2603: 22 20 FD 00      jsl LUNCURSORVEC
   178 FF:2607: C9 01            cmp #01
   179 FF:2609: F0 19            beq crsrup
   180 FF:260B: C9 02            cmp #02
   181 FF:260D: F0 21            beq crsrdn
   182 FF:260F: C9 1F            cmp #$1f
   183 FF:2611: F0 43            beq crsrlt
   184 FF:2613: C9 04            cmp #$04
   185 FF:2615: F0 5E            beq crsrrt
   186 FF:2617: 48               PHA
   187 FF:2618: 22 00 FD 00      jsl LPRINTVEC
   188 FF:261C: 68               PLA
   189 FF:261D: C9 0D            cmp #13
   190 FF:261F: F0 68            beq pexit
   191 FF:2621: 4C F7 25         jmp ploop
   192                        
   193                        crsrup:
   194 FF:2624: AD 31 03         lda CSRY
   195 FF:2627: C9 00            cmp #00
  Sun Nov 21 2021 15:13                                                                                                Page 78


   196 FF:2629: F0 CC            beq ploop
   197 FF:262B: CE 31 03         dec CSRY
   198 FF:262E: 80 C7            bra ploop
   199                        crsrdn:
   200 FF:2630: AD 31 03         lda CSRY
   201 FF:2633: C9 17            cmp #23
   202 FF:2635: F0 05            beq crsrdn_1
   203 FF:2637: EE 31 03         inc CSRY
   204 FF:263A: 80 BB            bra ploop
   205                        crsrdn_1:
   206 FF:263C: AD 30 03         lda CSRX
   207 FF:263F: 48               pha
   208 FF:2640: A9 28            LDA #40
   209 FF:2642: A2 00            ldx #0
   210 FF:2644: A0 17            ldy #23
   211 FF:2646: 8E 30 03         stx CSRX
   212 FF:2649: 8C 31 03         sty CSRY
   213 FF:264C: 22 14 FD 00      jsl LSrlUpVEC
   214 FF:2650: 68               pla
   215 FF:2651: 8D 30 03         sta CSRX
   216 FF:2654: 80 A1            bra ploop
   217                        crsrlt:
   218 FF:2656: AD 30 03         lda CSRX
   219 FF:2659: C9 00            cmp #00
   220 FF:265B: F0 06            beq crsrlt_1
   221 FF:265D: CE 30 03         dec CSRX
   222 FF:2660: 4C F7 25         jmp ploop
   223                        crsrlt_1
   224 FF:2663: AD 31 03         lda CSRY
   225 FF:2666: C9 00            cmp #00
   226 FF:2668: F0 8D            beq ploop
   227 FF:266A: A9 27            lda #39
   228 FF:266C: 8D 30 03         sta CSRX
   229 FF:266F: CE 31 03         dec CSRY
   230 FF:2672: 4C F7 25         jmp ploop
   231                        crsrrt:
   232 FF:2675: AD 30 03         lda CSRX
   233 FF:2678: C9 27            cmp #39
   234 FF:267A: F0 06            beq crsrrt_1
   235 FF:267C: EE 30 03         inc CSRX
   236 FF:267F: 4C F7 25         jmp ploop
   237                        crsrrt_1
   238 FF:2682: A9 00            lda #00
   239 FF:2684: 8D 30 03         sta CSRX
   240 FF:2687: 80 A7            bra crsrdn
   241                        pexit:
   242 FF:2689: 20 B3 26         jsr LdKbBuffer
   243                        
   244 FF:268C: A2 51            LDX #81
   245 FF:268E: A9 00            LDA #$00
   246 FF:2690: 9F 81 21 02      STA >LIbuffs,X
   247                        TERMLOOP:
   248 FF:2694: CA               DEX
   249 FF:2695: BF 81 21 02      LDA >LIbuffs,X
   250 FF:2699: C9 20            CMP #32
   251 FF:269B: F0 06            BEQ TERMLOOP_B
   252 FF:269D: C9 00            CMP #00
  Sun Nov 21 2021 15:13                                                                                                Page 79


   253 FF:269F: F0 08            BEQ TERMLOOP_C
   254 FF:26A1: 80 0A            BRA TERMLOOP_A
   255                        TERMLOOP_B:
   256 FF:26A3: A9 00            LDA #00
   257 FF:26A5: 9F 81 21 02      STA >LIbuffs,X
   258                        TERMLOOP_C:
   259 FF:26A9: E0 00            CPX #00
   260 FF:26AB: D0 E7            BNE TERMLOOP
   261                        TERMLOOP_A:
   262                        
   263 FF:26AD: AB               PLB
   264 FF:26AE: 28               plp
   265 FF:26AF: 7A               PLY
   266 FF:26B0: FA               PLX
   267 FF:26B1: 68               PLA
   268 FF:26B2: 60               RTS
   269                        
   270                        
   271                        LdKbBuffer:
   272 FF:26B3: AD 30 03         lda CSRX
   273 FF:26B6: 48               pha
   274 FF:26B7: AD 31 03         lda CSRY
   275 FF:26BA: 48               pha
   276                        ; clear input buffer
   277 FF:26BB: A2 51            ldx #81
   278                        clloop:
   279 FF:26BD: A9 00            lda #00
   280 FF:26BF: 9F 80 21 02      sta >LIbuffs-1,X
   281 FF:26C3: CA               dex
   282 FF:26C4: D0 F7            bne clloop
   283                        
   284                        ; are we on the first line?  If so, we know it is not a continue
   285 FF:26C6: AC 31 03         ldy CSRY
   286 FF:26C9: 88               dey
   287 FF:26CA: C0 00            cpy #$00
   288 FF:26CC: F0 0D            beq LdKbBuffer_1
   289                        ; if prior line linked  set y-1
   290 FF:26CE: BB               tyx
   291 FF:26CF: BD D0 03         LDA LINEFLGS,X
   292 FF:26D2: C9 00            CMP #$00
   293 FF:26D4: F0 05            beq LdKbBuffer_1
   294 FF:26D6: 88               dey
   295 FF:26D7: A9 51            lda #81         ; get 80 chars
   296 FF:26D9: 80 15            bra LdKbBuffer_1b
   297                        ; get chars; 40 if last line char=32, 80 if not
   298                        
   299                        LdKbBuffer_1:
   300                        ; is this the last line on the screen?
   301 FF:26DB: C0 17            cpy #23
   302 FF:26DD: F0 0F            beq LdKbBuffer_1a
   303                        ; if current line linked carries to the next set size to 80
   304 FF:26DF: BB               tyx
   305 FF:26E0: BD D1 03         LDA LINEFLGS+1,X
   306 FF:26E3: C9 00            CMP #$00
   307 FF:26E5: F0 07            beq LdKbBuffer_1a
   308 FF:26E7: 68               PLA
   309 FF:26E8: 1A               inc A
  Sun Nov 21 2021 15:13                                                                                                Page 80


   310 FF:26E9: 48               pha
   311 FF:26EA: A9 51            lda #81         ; get 80 chars
   312 FF:26EC: 80 02            bra LdKbBuffer_1b
   313                        LdKbBuffer_1a:
   314 FF:26EE: A9 29            lda #41         ; get 40 chars
   315                        LdKbBuffer_1b:
   316 FF:26F0: A2 00            ldx #0
   317 FF:26F2: 22 0C FD 00      jsl LSetXYVEC
   318 FF:26F6: A8               tay
   319                        LdKbBuffer_2:
   320 FF:26F7: 20 22 23         JSR DELAY9918
   321 FF:26FA: AD 0A FE         LDA DATAP
   322 FF:26FD: 9F 80 21 02      sta >LIbuffs-1,X
   323 FF:2701: E8               inx
   324 FF:2702: 88               dey
   325 FF:2703: C0 00            cpy #00
   326 FF:2705: D0 F0            bne LdKbBuffer_2
   327 FF:2707: 7A               PLY
   328 FF:2708: 8C 31 03         stY CSRY
   329 FF:270B: 68               PLA
   330 FF:270C: 8D 30 03         sta CSRX
   331 FF:270F: C0 18            cpy #24
   332 FF:2711: D0 0A            bne LdKbBuffer_3
   333 FF:2713: 88               dey
   334 FF:2714: 8C 31 03         stY CSRY
   335 FF:2717: A9 28            lda #40
   336 FF:2719: 22 14 FD 00      jsl LSrlUpVEC
   337                        LdKbBuffer_3:
   338 FF:271D: 60               rts
   339                        
   340                        ;___LAB_MONITOR_____________________________________________
   341                        ;
   342                        ; UTILIZE BIOS TO GO TO MONITOR
   343                        ;
   344                        ;
   345                        ; THIS IS NATIVE '816 CODE
   346                        ;__________________________________________________________
   347                        LAB_MONITOR:
   348 FF:271E: D8           	CLD				; VERIFY DECIMAL MODE IS OFF
   349 FF:271F: 18           	CLC 			;
   350 FF:2720: FB           	XCE 			; SET NATIVE MODE
   351                            SETBANK 0
+  351 FF:2721: DA               PHX
+  351 FF:2722: A2 00        	LDX #0
+  351 FF:2724: DA           	PHX
+  351 FF:2725: AB           	PLB
+  351 FF:2726: FA               PLX
   352                            AccumulatorIndex16
+  352 FF:2727: C2 30        		REP #$30 		; 16 bit Index registers
+  352                        		LONGA ON
+  352                                LONGI ON
   353 FF:2729: A9 FF 7F     	LDA #STACK 		; get the stack address
   354 FF:272C: 1B           	TCS 			; and set the stack to it
   355 FF:272D: 5C 00 80 00      JML $008000
    57                        ;
    58                        ;____________________________________________________________________________________________
    59                        
  Sun Nov 21 2021 15:13                                                                                                Page 81


    60                        
    61                        			    	        ;   ensure CPU Context is in a known state
    62 FF:2731: EA           	NOP	; FIX A CODE PAGE ALIGNMENT PROBLEM
    63                        BASICBEGIN:
    64                        
    65 FF:2732: D8                   CLD                 ; VERIFY DECIMAL MODE IS OFF
    66 FF:2733: 18                   CLC                 ;
    67 FF:2734: FB                   XCE                 ; SET NATIVE MODE
    68                           		AccumulatorIndex16
+   68 FF:2735: C2 30        		REP #$30 		; 16 bit Index registers
+   68                        		LONGA ON
+   68                                LONGI ON
    69 FF:2737: A9 FF 7F     		LDA #STACK 		; get the stack address
    70 FF:273A: 1B              		TCS 			; and set the stack to it
    71 FF:273B: A9 00 00             LDA #$0000            ;
    72 FF:273E: 48                   PHA                 ; Set Direct Register to 0
    73 FF:273F: 2B                   PLD                 ;
    74                        
    75                        		IF PROGRAMBANK=DATABANK
    76                        
    77                        		ELSE
    78 FF:2740: A2 00 10     		LDX #$1000
    79 FF:2743: A0 00 10     		LDY #$1000
    80 FF:2746: A9 00 10     		LDA #$1000
    81 FF:2749: 54 02 FF     		MVN PROGRAMBANK,DATABANK	; COPY TABLES $1000 THROUGH $2000 PLUS OR MINUS :) TO WO
                    RKING BANK
    82                        		ENDIF
    83                        		AccumulatorIndex8
+   83 FF:274C: E2 30        		SEP #$30 		; 8 bit Index registers
+   83                        		LONGA OFF
+   83                                LONGI OFF
    84 FF:274E: A9 FF        		LDA	#PROGRAMBANK	; SET DATA BANK = TO PROGRAM BANK TO ALLOW FOR INITIALIZATION FR
                    OM ROM
    85 FF:2750: 48           		PHA
    86 FF:2751: AB           		PLB					;
    87                        
    88                        
    89                        
    90                        LAB_COLD
    91 FF:2752: A2 04        	LDX	#PG2_TABE-PG2_TABS-1
    92                        						; byte count-1
    93                        LAB_2D13
    94 FF:2754: BD 33 10     	LDA	PG2_TABS,X			; get byte
    95 FF:2757: A0 00        	LDY	#00				; SET DATA BANK = TO ZERO BANK
    96 FF:2759: 5A           	PHY
    97 FF:275A: AB           	PLB					;
    98 FF:275B: 9F 00 02 00  	STA	>ccflag,X			; store in page 2
    99 FF:275F: A0 FF        	LDY	#PROGRAMBANK			; SET DATA BANK = TO PROGRAM BANK TO ALLOW FOR INITIALIZ
                    ATION FROM ROM
   100 FF:2761: 5A           	PHY
   101 FF:2762: AB           	PLB					;
   102                        
   103 FF:2763: CA           	DEX					; decrement count
   104 FF:2764: 10 EE        	BPL	LAB_2D13			; loop if not done
   105                        
   106 FF:2766: A2 FF        	LDX	#$FF				; set byte
   107 FF:2768: 86 88        	STX	<Clineh				; set current line high byte (set immediate mode)
  Sun Nov 21 2021 15:13                                                                                                Page 82


   108                        
   109 FF:276A: A9 4C        	LDA	#$4C				; code for JMP
   110 FF:276C: 85 A1        	STA	<Fnxjmp				; save for jump vector for functions
   111                        
   112                        ; copy block from LAB_2CEE to $00BC - $00E0
   113                        
   114 FF:276E: A0 1D        	LDY	#LAB_2CEE_END-LAB_2CEE		; set byte count
   115                        LAB_2D4E
   116 FF:2770: BE 02 10     	LDX	LAB_2CEE-1,Y			; get byte from table
   117 FF:2773: 96 BB        	STX	<LAB_IGBY-1,Y			; save byte in page zero
   118 FF:2775: 88           	DEY					; decrement count
   119 FF:2776: D0 F8        	BNE	LAB_2D4E			; loop if not all done
   120                        
   121                        ; copy block from StrTab to $0000 - $0012
   122                        
   123                        LAB_GMEM
   124 FF:2778: A0 12        	LDY	#EndTab-StrTab-1		; set byte count-1
   125                        TabLoop
   126 FF:277A: BE 20 10     	LDX	StrTab,Y			; get byte from table
   127 FF:277D: 96 00        	STX	<PLUS_0,Y			; save byte in page zero
   128 FF:277F: 88           	DEY					; decrement count
   129 FF:2780: 10 F8        	BPL	TabLoop				; loop if not all done
   130                        
   131                        ; DO TITLE SCREEN
   132 FF:2782: 20 AB 25     	JSR 	TitleScreen
   133                        
   134                        
   135                        ; set-up start values
   136 FF:2785: A9 02        	LDA	#DATABANK		; SET DATA BANK = TO DATA BANK, ALL PROGRAM DATA IN THIS AREA
   137 FF:2787: 85 C5        	STA	<Bpntrp			; SET LAB_GBYT PAGE POINTER TO DATA BANK
   138 FF:2789: 48           	PHA
   139 FF:278A: AB           	PLB
   140 FF:278B: A9 02        	LDA 	#2			;
   141 FF:278D: 85 06        	STA 	<VIDEOMODE
   142 FF:278F: A9 00        	LDA	#$00			; clear A
   143 FF:2791: 85 E5        	STA	<NmiBase		; clear NMI handler enabled flag
   144 FF:2793: 85 E8        	STA	<IrqBase		; clear IRQ handler enabled flag
   145 FF:2795: 85 B2        	STA	<FAC1_o			; clear FAC1 overflow byte
   146 FF:2797: 85 67        	STA	<last_sh		; clear descriptor stack top item pointer high byte
   147                        
   148 FF:2799: A9 0E        	LDA	#$0E			; set default tab size
   149 FF:279B: 85 64        	STA	<TabSiz			; save it
   150 FF:279D: A9 03        	LDA	#$03			; set garbage collect step size for descriptor stack
   151 FF:279F: 85 A0        	STA	<g_step			; save it
   152 FF:27A1: A2 68        	LDX	#<des_sk		; descriptor stack start
   153 FF:27A3: 86 65        	STX	<next_s			; set descriptor stack pointer
   154 FF:27A5: 20 3D 31     	JSR	LAB_CRLF		; print CR/LF
   155                        
   156 FF:27A8: A9 00        	LDA #<Ram_top
   157 FF:27AA: A0 FF        	LDY #>Ram_top
   158 FF:27AC: 85 85        	STA	<Ememl			; set end of mem low byte
   159 FF:27AE: 84 86        	STY	<Ememh			; set end of mem high byte
   160 FF:27B0: 85 81        	STA	<Sstorl			; set bottom of string space low byte
   161 FF:27B2: 84 82        	STY	<Sstorh			; set bottom of string space high byte
   162                        
   163 FF:27B4: A0 00        	LDY	#<Ram_base		; set start addr low byte
   164 FF:27B6: A2 22        	LDX	#>Ram_base		; set start addr high byte
  Sun Nov 21 2021 15:13                                                                                                Page 83


   165 FF:27B8: 84 79        	STY	<Smeml			; save start of mem low byte
   166 FF:27BA: 86 7A        	STX	<Smemh			; save start of mem high byte
   167                        
   168 FF:27BC: 98           	TYA					; clear A
   169 FF:27BD: 91 79        	STA	(<Smeml),Y		; clear first byte
   170 FF:27BF: E6 79        	INC	<Smeml			; increment start of mem low byte
   171                        LAB_2E05
   172 FF:27C1: 20 3D 31     	JSR	LAB_CRLF		; print CR/LF
   173 FF:27C4: 20 FF 2A     	JSR	LAB_1463		; do "NEW" and "CLEAR"
   174 FF:27C7: A5 85        	LDA	<Ememl			; get end of mem low byte
   175 FF:27C9: 38           	SEC				; set carry for subtract
   176 FF:27CA: E5 79        	SBC	<Smeml			; subtract start of mem low byte
   177 FF:27CC: AA           	TAX				; copy to X
   178 FF:27CD: A5 86        	LDA	<Ememh			; get end of mem high byte
   179 FF:27CF: E5 7A        	SBC	<Smemh			; subtract start of mem high byte
   180 FF:27D1: 20 A3 48     	JSR	LAB_295E		; print XA as unsigned integer (bytes free)
   181 FF:27D4: A9 3F        	LDA	#<LAB_SMSG		; point to sign-on message (low addr)
   182 FF:27D6: A0 16        	LDY	#>LAB_SMSG		; point to sign-on message (high addr)
   183 FF:27D8: 20 85 31     	JSR	LAB_18C3		; print null terminated string from memory
   184 FF:27DB: A9 EC        	LDA	#<LAB_1274		; warm start vector low byte
   185 FF:27DD: A0 28        	LDY	#>LAB_1274		; warm start vector high byte
   186 FF:27DF: 85 01        	STA	<Wrmjpl		; save warm start vector low byte
   187 FF:27E1: 84 02        	STY	<Wrmjph		; save warm start vector high byte
   188 FF:27E3: 6C 01 00     	JMP	(Wrmjpl)		; go do warm start
   189                        
   190                        ; open up space in memory
   191                        ; move (<Ostrtl)-(<Obendl) to new block ending at (<Nbendl)
   192                        
   193                        ; <Nbendl,<Nbendh - new block end address (A/Y)
   194                        ; <Obendl,<Obendh - old block end address
   195                        ; <Ostrtl,<Ostrth - old block start address
   196                        
   197                        ; returns with ..
   198                        
   199                        ; <Nbendl,<Nbendh - new block start address (high byte - $100)
   200                        ; <Obendl,<Obendh - old block start address (high byte - $100)
   201                        ; <Ostrtl,<Ostrth - old block start address (unchanged)
   202                        
   203                        LAB_11CF
   204 FF:27E6: 20 90 28     	JSR	LAB_121F		; check available memory, "Out of memory" error if no room
   205                        					; addr to check is in AY (low/high)
   206 FF:27E9: 85 7F        	STA	<Earryl		; save new array mem end low byte
   207 FF:27EB: 84 80        	STY	<Earryh		; save new array mem end high byte
   208                        
   209                        ; open up space in memory
   210                        ; move (<Ostrtl)-(<Obendl) to new block ending at (<Nbendl)
   211                        ; don't set array end
   212                        
   213                        LAB_11D6
   214 FF:27ED: 38           	SEC				; set carry for subtract
   215 FF:27EE: A5 A6        	LDA	<Obendl		; get block end low byte
   216 FF:27F0: E5 AA        	SBC	<Ostrtl		; subtract block start low byte
   217 FF:27F2: A8           	TAY				; copy MOD(block length/$100) byte to Y
   218 FF:27F3: A5 A7        	LDA	<Obendh		; get block end high byte
   219 FF:27F5: E5 AB        	SBC	<Ostrth		; subtract block start high byte
   220 FF:27F7: AA           	TAX				; copy block length high byte to X
   221 FF:27F8: E8           	INX				; +1 to allow for count=0 exit
  Sun Nov 21 2021 15:13                                                                                                Page 84


   222 FF:27F9: 98           	TYA				; copy block length low byte to A
   223 FF:27FA: F0 74        	BEQ	LAB_120A		; branch if length low byte=0
   224                        
   225                        					; block is (X-1)*256+Y bytes, do the Y bytes first
   226                        
   227 FF:27FC: 38           	SEC				; set carry for add + 1, two's complement
   228 FF:27FD: 49 FF        	EOR	#$FF			; invert low byte for subtract
   229 FF:27FF: 65 A6        	ADC	<Obendl		; add block end low byte
   230                        
   231 FF:2801: 85 A6        	STA	<Obendl		; save corrected old block end low byte
   232 FF:2803: B0 03        	BCS	LAB_11F3		; branch if no underflow
   233                        
   234 FF:2805: C6 A7        	DEC	<Obendh		; else decrement block end high byte
   235 FF:2807: 38           	SEC				; set carry for add + 1, two's complement
   236                        LAB_11F3
   237 FF:2808: 98           	TYA				; get MOD(block length/$100) byte
   238 FF:2809: 49 FF        	EOR	#$FF			; invert low byte for subtract
   239 FF:280B: 65 A4        	ADC	<Nbendl		; add destination end low byte
   240 FF:280D: 85 A4        	STA	<Nbendl		; save modified new block end low byte
   241 FF:280F: B0 30        	BCS	LAB_1203		; branch if no underflow
   242                        
   243 FF:2811: C6 A5        	DEC	<Nbendh		; else decrement block end high byte
   244 FF:2813: 90 2C        	BCC	LAB_1203		; branch always
   245                        
   246                        LAB_11FF
   247                        	LDAINDIRECTY Obendl		; get byte from source
+  247 FF:2815: 8B               PHB
+  247 FF:2816: DA           	PHX
+  247 FF:2817: A2 01            LDX #$01
+  247 FF:2819: B5 A6            LDA <Obendl,X
+  247 FF:281B: C9 00            CMP #$00
+  247 FF:281D: D0 04            BNE *+6
+  247 FF:281F: A2 00        	LDX #00
+  247 FF:2821: DA           	PHX
+  247 FF:2822: AB           	PLB
+  247 FF:2823: FA               PLX
+  247 FF:2824: B1 A6        	LDA	(<Obendl),Y		;
+  247 FF:2826: 85 04            STA <TMPFLG
+  247 FF:2828: AB               PLB
+  247 FF:2829: A5 04            LDA <TMPFLG
   248                        	STAINDIRECTY Nbendl		; copy byte to destination
+  248 FF:282B: 8B               PHB
+  248 FF:282C: DA           	PHX
+  248 FF:282D: 48               PHA
+  248 FF:282E: A2 01            LDX #$01
+  248 FF:2830: B5 A4            LDA <Nbendl,X
+  248 FF:2832: C9 00            CMP #$00
+  248 FF:2834: D0 04            BNE *+6
+  248 FF:2836: A2 00        	LDX #00
+  248 FF:2838: DA           	PHX
+  248 FF:2839: AB           	PLB
+  248 FF:283A: 68               PLA
+  248 FF:283B: FA               PLX
+  248 FF:283C: 91 A4        	STA	(<Nbendl),Y		;
+  248 FF:283E: AB           	PLB
+  248 FF:283F: 85 04            STA <TMPFLG
   249                        LAB_1203
  Sun Nov 21 2021 15:13                                                                                                Page 85


   250 FF:2841: 88           	DEY				; decrement index
   251 FF:2842: D0 D1        	BNE	LAB_11FF		; loop until Y=0
   252                        
   253                        					; now do Y=0 indexed byte
   254                        	LDAINDIRECTY Obendl		; get byte from source
+  254 FF:2844: 8B               PHB
+  254 FF:2845: DA           	PHX
+  254 FF:2846: A2 01            LDX #$01
+  254 FF:2848: B5 A6            LDA <Obendl,X
+  254 FF:284A: C9 00            CMP #$00
+  254 FF:284C: D0 04            BNE *+6
+  254 FF:284E: A2 00        	LDX #00
+  254 FF:2850: DA           	PHX
+  254 FF:2851: AB           	PLB
+  254 FF:2852: FA               PLX
+  254 FF:2853: B1 A6        	LDA	(<Obendl),Y		;
+  254 FF:2855: 85 04            STA <TMPFLG
+  254 FF:2857: AB               PLB
+  254 FF:2858: A5 04            LDA <TMPFLG
   255                        	STAINDIRECTY Nbendl		; save byte to destination
+  255 FF:285A: 8B               PHB
+  255 FF:285B: DA           	PHX
+  255 FF:285C: 48               PHA
+  255 FF:285D: A2 01            LDX #$01
+  255 FF:285F: B5 A4            LDA <Nbendl,X
+  255 FF:2861: C9 00            CMP #$00
+  255 FF:2863: D0 04            BNE *+6
+  255 FF:2865: A2 00        	LDX #00
+  255 FF:2867: DA           	PHX
+  255 FF:2868: AB           	PLB
+  255 FF:2869: 68               PLA
+  255 FF:286A: FA               PLX
+  255 FF:286B: 91 A4        	STA	(<Nbendl),Y		;
+  255 FF:286D: AB           	PLB
+  255 FF:286E: 85 04            STA <TMPFLG
   256                        LAB_120A
   257 FF:2870: C6 A7        	DEC	<Obendh		; decrement source pointer high byte
   258 FF:2872: C6 A5        	DEC	<Nbendh		; decrement destination pointer high byte
   259 FF:2874: CA           	DEX				; decrement block count
   260 FF:2875: D0 CA        	BNE	LAB_1203		; loop until count = $0
   261                        
   262 FF:2877: 60           	RTS
   263                        
   264                        ; check room on stack for A bytes
   265                        ; stack too deep? do OM error
   266                        LAB_1212
   267                        	ACCUMULATOR16
+  267 FF:2878: C2 20        		REP #$20 		; 16 bit Index registers
+  267                        		LONGA ON
   268 FF:287A: 29 FF 00     	AND	#$00FF
   269 FF:287D: 18           	CLC
   270 FF:287E: 69 00 40     	ADC #STACK_BOTTOM
   271 FF:2881: 85 FD        	STA <TEMPW
   272 FF:2883: 3B           	TSC
   273 FF:2884: C5 FD        	CMP <TEMPW
   274 FF:2886: 90 03        	BCC	LAB_1213		; if stack < limit do "Out of memory" error then warm start
   275                        	ACCUMULATOR8
  Sun Nov 21 2021 15:13                                                                                                Page 86


+  275 FF:2888: E2 20        		SEP #$20 		; 8 bit Index registers
+  275                        		LONGA OFF
   276 FF:288A: 60           	RTS
   277                        LAB_1213
   278                        	ACCUMULATOR8
+  278 FF:288B: E2 20        		SEP #$20 		; 8 bit Index registers
+  278                        		LONGA OFF
   279 FF:288D: 4C BF 28     	JMP LAB_OMER
   280                        
   281                        ; check available memory, "Out of memory" error if no room
   282                        ; addr to check is in AY (low/high)
   283                        
   284                        LAB_121F
   285 FF:2890: C4 82        	CPY	<Sstorh		; compare bottom of string mem high byte
   286 FF:2892: 90 2A        	BCC	LAB_124B		; if less then exit (is ok)
   287                        
   288 FF:2894: D0 04        	BNE	LAB_1229		; skip next test if greater (tested <)
   289                        
   290                        					; high byte was =, now do low byte
   291 FF:2896: C5 81        	CMP	<Sstorl		; compare with bottom of string mem low byte
   292 FF:2898: 90 24        	BCC	LAB_124B		; if less then exit (is ok)
   293                        
   294                        					; addr is > string storage ptr (oops!)
   295                        LAB_1229
   296 FF:289A: 48           	PHA				; push addr low byte
   297 FF:289B: A2 08        	LDX	#$08			; set index to save <Adatal to <expneg inclusive
   298 FF:289D: 98           	TYA				; copy addr high byte (to push on stack)
   299                        
   300                        					; save misc numeric work area
   301                        LAB_122D
   302 FF:289E: 48           	PHA				; push byte
   303 FF:289F: B5 A3        	LDA	<Adatal-1,X		; get byte from <Adatal to <expneg ( ,$00 not pushed)
   304 FF:28A1: CA           	DEX				; decrement index
   305 FF:28A2: 10 FA        	BPL	LAB_122D		; loop until all done
   306                        
   307 FF:28A4: 20 EB 3B     	JSR	LAB_GARB		; garbage collection routine
   308                        
   309                        					; restore misc numeric work area
   310 FF:28A7: A2 00        	LDX	#$00			; clear the index to restore bytes
   311                        LAB_1238
   312 FF:28A9: 68           	PLA				; pop byte
   313 FF:28AA: 95 A4        	STA	<Adatal,X		; save byte to <Adatal to <expneg
   314 FF:28AC: E8           	INX				; increment index
   315 FF:28AD: E0 08        	CPX	#$08			; compare with end + 1
   316 FF:28AF: 30 F8        	BMI	LAB_1238		; loop if more to do
   317                        
   318 FF:28B1: 68           	PLA				; pop addr high byte
   319 FF:28B2: A8           	TAY				; copy back to Y
   320 FF:28B3: 68           	PLA				; pop addr low byte
   321 FF:28B4: C4 82        	CPY	<Sstorh		; compare bottom of string mem high byte
   322 FF:28B6: 90 06        	BCC	LAB_124B		; if less then exit (is ok)
   323                        
   324 FF:28B8: D0 05        	BNE	LAB_OMER		; if greater do "Out of memory" error then warm start
   325                        
   326                        					; high byte was =, now do low byte
   327 FF:28BA: C5 81        	CMP	<Sstorl		; compare with bottom of string mem low byte
   328 FF:28BC: B0 01        	BCS	LAB_OMER		; if >= do "Out of memory" error then warm start
  Sun Nov 21 2021 15:13                                                                                                Page 87


   329                        
   330                        					; ok exit, carry clear
   331                        LAB_124B
   332 FF:28BE: 60           	RTS
   333                        
   334                        ; do "Out of memory" error then warm start
   335                        
   336                        LAB_OMER
   337 FF:28BF: A2 0C        	LDX	#$0C			; error code $0C ("Out of memory" error)
   338                        
   339                        ; do error #X, then warm start
   340                        
   341                        LAB_XERR
   342 FF:28C1: 20 3D 31     	JSR	LAB_CRLF		; print CR/LF
   343                        
   344 FF:28C4: A5 06        	lda <VIDEOMODE
   345 FF:28C6: C9 02        	cmp #2
   346 FF:28C8: F0 07        	beq LAB_XERRA
   347 FF:28CA: DA           	PHX
   348 FF:28CB: A2 02        	ldx #2
   349 FF:28CD: 20 4C 1E     	jsr V_SCREEN1
   350 FF:28D0: FA           	PLX
   351                        LAB_XERRA
   352 FF:28D1: BD 8D 16     	LDA	LAB_BAER,X		; get error message pointer low byte
   353 FF:28D4: BC 8E 16     	LDY	LAB_BAER+1,X	; get error message pointer high byte
   354 FF:28D7: 20 85 31     	JSR	LAB_18C3		; print null terminated string from memory
   355                        
   356 FF:28DA: 20 38 2B     	JSR	LAB_1491		; flush stack and clear continue flag
   357 FF:28DD: A9 CA        	LDA	#<LAB_EMSG		; point to " Error" low addr
   358 FF:28DF: A0 17        	LDY	#>LAB_EMSG		; point to " Error" high addr
   359                        LAB_1269
   360 FF:28E1: 20 85 31     	JSR	LAB_18C3		; print null terminated string from memory
   361 FF:28E4: A4 88        	LDY	<Clineh		; get current line high byte
   362 FF:28E6: C8           	INY				; increment it
   363 FF:28E7: F0 03        	BEQ	LAB_1274		; go do warm start (was immediate mode)
   364                        
   365                        					; else print line number
   366 FF:28E9: 20 98 48     	JSR	LAB_2953		; print " in line [LINE #]"
   367                        
   368                        ; BASIC warm start entry point
   369                        ; wait for Basic command
   370                        
   371                        LAB_1274
   372 FF:28EC: A5 06        	lda <VIDEOMODE
   373 FF:28EE: C9 02        	cmp #2
   374 FF:28F0: F0 05        	beq LAB_1274a
   375 FF:28F2: A2 02        	ldx #2
   376 FF:28F4: 20 4C 1E     	jsr V_SCREEN1
   377                        LAB_1274a:
   378                        					; clear ON IRQ/NMI bytes
   379 FF:28F7: A9 00        	LDA	#$00			; clear A
   380 FF:28F9: 85 E8        	STA	<IrqBase		; clear enabled byte
   381 FF:28FB: 85 E5        	STA	<NmiBase		; clear enabled byte
   382 FF:28FD: A9 DB        	LDA	#<LAB_RMSG		; point to "Ready" message low byte
   383 FF:28FF: A0 17        	LDY	#>LAB_RMSG		; point to "Ready" message high byte
   384                        
   385 FF:2901: 20 85 31     	JSR	LAB_18C3		; go do print string
  Sun Nov 21 2021 15:13                                                                                                Page 88


   386                        
   387                        ; wait for Basic command (no "Ready")
   388                        
   389                        LAB_127D
   390 FF:2904: 20 E9 29     	JSR	LAB_1357		; call for BASIC input
   391                        LAB_1280
   392 FF:2907: 86 C3        	STX	<Bpntrl		; set BASIC execute pointer low byte
   393 FF:2909: 84 C4        	STY	<Bpntrh		; set BASIC execute pointer high byte
   394 FF:290B: 22 C2 00 00  	JSL	LAB_GBYT		; scan memory
   395 FF:290F: F0 F3        	BEQ	LAB_127D		; loop while null
   396                        
   397                        ; got to interpret input line now ..
   398                        
   399 FF:2911: A2 FF        	LDX	#$FF			; current line to null value
   400 FF:2913: 86 88        	STX	<Clineh		; set current line high byte
   401 FF:2915: 90 06        	BCC	LAB_1295		; branch if numeric character (handle new BASIC line)
   402                        
   403                        					; no line number .. immediate mode
   404 FF:2917: 20 2A 2A     	JSR	LAB_13A6		; crunch keywords into Basic tokens
   405 FF:291A: 4C AD 2C     	JMP	LAB_15F6		; go scan and interpret code
   406                        
   407                        ; handle new BASIC line
   408                        
   409                        LAB_1295
   410 FF:291D: 20 1E 2F     	JSR	LAB_GFPN		; get fixed-point number into temp integer
   411 FF:2920: 20 2A 2A     	JSR	LAB_13A6		; crunch keywords into Basic tokens
   412 FF:2923: 84 5D        	STY	<Ibptr			; save index pointer to end of crunched line
   413 FF:2925: 20 D3 2A     	JSR	LAB_SSLN		; search BASIC for temp integer line number
   414 FF:2928: 90 44        	BCC	LAB_12E6		; branch if not found
   415                        
   416                        					; aroooogah! line # already exists! delete it
   417 FF:292A: A0 01        	LDY	#$01			; set index to next line pointer high byte
   418 FF:292C: B1 AA        	LDA (<Baslnl),Y		; get next line pointer high byte
   419 FF:292E: 85 72        	STA	<ut1_ph		; save it
   420 FF:2930: A5 7B        	LDA	<Svarl			; get start of vars low byte
   421 FF:2932: 85 71        	STA	<ut1_pl		; save it
   422 FF:2934: A5 AB        	LDA	<Baslnh		; get found line pointer high byte
   423 FF:2936: 85 74        	STA	<ut2_ph		; save it
   424 FF:2938: A5 AA        	LDA	<Baslnl		; get found line pointer low byte
   425 FF:293A: 88           	DEY				; decrement index
   426 FF:293B: F1 AA        	SBC (<Baslnl),Y		; subtract next line pointer low byte
   427 FF:293D: 18           	CLC				; clear carry for add
   428 FF:293E: 65 7B        	ADC	<Svarl			; add start of vars low byte
   429 FF:2940: 85 7B        	STA	<Svarl			; save new start of vars low byte
   430 FF:2942: 85 73        	STA	<ut2_pl		; save destination pointer low byte
   431 FF:2944: A5 7C        	LDA	<Svarh			; get start of vars high byte
   432 FF:2946: 69 FF        	ADC	#$FF			; -1 + carry
   433 FF:2948: 85 7C        	STA	<Svarh			; save start of vars high byte
   434 FF:294A: E5 AB        	SBC	<Baslnh		; subtract found line pointer high byte
   435 FF:294C: AA           	TAX				; copy to block count
   436 FF:294D: 38           	SEC				; set carry for subtract
   437 FF:294E: A5 AA        	LDA	<Baslnl		; get found line pointer low byte
   438 FF:2950: E5 7B        	SBC	<Svarl			; subtract start of vars low byte
   439 FF:2952: A8           	TAY				; copy to bytes in first block count
   440 FF:2953: B0 03        	BCS	LAB_12D0		; branch if overflow
   441                        
   442 FF:2955: E8           	INX				; increment block count (correct for =0 loop exit)
  Sun Nov 21 2021 15:13                                                                                                Page 89


   443 FF:2956: C6 74        	DEC	<ut2_ph		; decrement destination high byte
   444                        LAB_12D0
   445 FF:2958: 18           	CLC				; clear carry for add
   446 FF:2959: 65 71        	ADC	<ut1_pl		; add source pointer low byte
   447 FF:295B: 90 03        	BCC	LAB_12D8		; branch if no overflow
   448                        
   449 FF:295D: C6 72        	DEC	<ut1_ph		; else decrement source pointer high byte
   450 FF:295F: 18           	CLC				; clear carry
   451                        
   452                        					; close up memory to delete old line
   453                        LAB_12D8
   454 FF:2960: B1 71        	LDA	(<ut1_pl),Y		; get byte from source
   455 FF:2962: 91 73        	STA	(<ut2_pl),Y		; copy to destination
   456 FF:2964: C8           	INY				; increment index
   457 FF:2965: D0 F9        	BNE	LAB_12D8		; while <> 0 do this block
   458                        
   459 FF:2967: E6 72        	INC	<ut1_ph		; increment source pointer high byte
   460 FF:2969: E6 74        	INC	<ut2_ph		; increment destination pointer high byte
   461 FF:296B: CA           	DEX				; decrement block count
   462 FF:296C: D0 F2        	BNE	LAB_12D8		; loop until all done
   463                        
   464                        					; got new line in buffer and no existing same #
   465                        LAB_12E6
   466 FF:296E: AD 81 21     	LDA	Ibuffs		; get byte from start of input buffer
   467 FF:2971: F0 3F        	BEQ	LAB_1319		; if null line just go flush stack/vars and exit
   468                        
   469                        					; got new line and it isn't empty line
   470 FF:2973: A5 85        	LDA	<Ememl			; get end of mem low byte
   471 FF:2975: A4 86        	LDY	<Ememh			; get end of mem high byte
   472 FF:2977: 85 81        	STA	<Sstorl		; set bottom of string space low byte
   473 FF:2979: 84 82        	STY	<Sstorh		; set bottom of string space high byte
   474 FF:297B: A5 7B        	LDA	<Svarl			; get start of vars low byte	(end of BASIC)
   475 FF:297D: 85 A6        	STA	<Obendl		; save old block end low byte
   476 FF:297F: A4 7C        	LDY	<Svarh			; get start of vars high byte	(end of BASIC)
   477 FF:2981: 84 A7        	STY	<Obendh		; save old block end high byte
   478 FF:2983: 65 5D        	ADC	<Ibptr			; add input buffer pointer	(also buffer length)
   479 FF:2985: 90 01        	BCC	LAB_1301		; branch if no overflow from add
   480                        
   481 FF:2987: C8           	INY				; else increment high byte
   482                        LAB_1301
   483 FF:2988: 85 A4        	STA	<Nbendl		; save new block end low byte	(move to, low byte)
   484 FF:298A: 84 A5        	STY	<Nbendh		; save new block end high byte
   485 FF:298C: 20 E6 27     	JSR	LAB_11CF		; open up space in memory
   486                        					; old start pointer <Ostrtl,<Ostrth set by the find line call
   487 FF:298F: A5 7F        	LDA	<Earryl		; get array mem end low byte
   488 FF:2991: A4 80        	LDY	<Earryh		; get array mem end high byte
   489 FF:2993: 85 7B        	STA	<Svarl			; save start of vars low byte
   490 FF:2995: 84 7C        	STY	<Svarh			; save start of vars high byte
   491 FF:2997: A4 5D        	LDY	<Ibptr			; get input buffer pointer	(also buffer length)
   492 FF:2999: 88           	DEY				; adjust for loop type
   493                        LAB_1311
   494 FF:299A: B9 7D 21     	LDA	Ibuffs-4,Y		; get byte from crunched line
   495 FF:299D: 91 AA        	STA (<Baslnl),Y		; save it to program memory
   496 FF:299F: 88           	DEY				; decrement count
   497 FF:29A0: C0 03        	CPY	#$03			; compare with first byte-1
   498 FF:29A2: D0 F6        	BNE	LAB_1311		; continue while count <> 3
   499                        
  Sun Nov 21 2021 15:13                                                                                                Page 90


   500 FF:29A4: A5 12        	LDA	<Itemph		; get line # high byte
   501 FF:29A6: 91 AA        	STA (<Baslnl),Y		; save it to program memory
   502 FF:29A8: 88           	DEY				; decrement count
   503 FF:29A9: A5 11        	LDA	<Itempl		; get line # low byte
   504 FF:29AB: 91 AA        	STA (<Baslnl),Y		; save it to program memory
   505 FF:29AD: 88           	DEY				; decrement count
   506 FF:29AE: A9 FF        	LDA	#$FF			; set byte to allow chain rebuild. if you didn't set this
   507                        					; byte then a zero already here would stop the chain rebuild
   508                        					; as it would think it was the [EOT] marker.
   509 FF:29B0: 91 AA        	STA (<Baslnl),Y		; save it to program memory
   510                        
   511                        LAB_1319
   512 FF:29B2: 20 14 2B     	JSR	LAB_1477		; reset execution to start, clear vars and flush stack
   513 FF:29B5: A6 79        	LDX	<Smeml			; get start of mem low byte
   514 FF:29B7: A5 7A        	LDA	<Smemh			; get start of mem high byte
   515 FF:29B9: A0 01        	LDY	#$01			; index to high byte of next line pointer
   516                        LAB_1325
   517 FF:29BB: 86 71        	STX	<ut1_pl		; set line start pointer low byte
   518 FF:29BD: 85 72        	STA	<ut1_ph		; set line start pointer high byte
   519 FF:29BF: B1 71        	LDA (<ut1_pl),Y		; get it
   520 FF:29C1: F0 18        	BEQ	LAB_133E		; exit if end of program
   521                        
   522                        ; rebuild chaining of Basic lines
   523                        
   524 FF:29C3: A0 04        	LDY	#$04			; point to first code byte of line
   525                        					; there is always 1 byte + [EOL] as null entries are deleted
   526                        LAB_1330
   527 FF:29C5: C8           	INY				; next code byte
   528 FF:29C6: B1 71        	LDA (<ut1_pl),Y		; get byte
   529 FF:29C8: D0 FB        	BNE	LAB_1330		; loop if not [EOL]
   530                        
   531 FF:29CA: 38           	SEC				; set carry for add + 1
   532 FF:29CB: 98           	TYA				; copy end index
   533 FF:29CC: 65 71        	ADC	<ut1_pl		; add to line start pointer low byte
   534 FF:29CE: AA           	TAX				; copy to X
   535 FF:29CF: A0 00        	LDY	#$00			; clear index, point to this line's next line pointer
   536 FF:29D1: 91 71        	STA (<ut1_pl),Y		; set next line pointer low byte
   537 FF:29D3: 98           	TYA				; clear A
   538 FF:29D4: 65 72        	ADC	<ut1_ph		; add line start pointer high byte + carry
   539 FF:29D6: C8           	INY				; increment index to high byte
   540 FF:29D7: 91 71        	STA (<ut1_pl),Y		; save next line pointer low byte
   541 FF:29D9: 90 E0        	BCC	LAB_1325		; go do next line, branch always, carry clear
   542                        
   543                        
   544                        LAB_133E
   545 FF:29DB: 4C 04 29     	JMP	LAB_127D		; else we just wait for Basic command, no "Ready"
   546                        
   547                        ; print "? " and get BASIC input
   548                        
   549                        LAB_INLN
   550                        	;JSR	LAB_18E3		; print "?" character
   551 FF:29DE: 20 AE 31     	JSR	LAB_18E0		; print " "
   552 FF:29E1: D0 18        	BNE	SimpleSerialEditor	; call for BASIC input and return
   553                        
   554                        ; receive line from keyboard
   555                        
   556                        					; $08 as delete key (BACKSPACE on standard keyboard)
  Sun Nov 21 2021 15:13                                                                                                Page 91


   557                        LAB_134B
   558 FF:29E3: 20 B3 31     	JSR	LAB_PRNA		; go print the character
   559 FF:29E6: CA           	DEX				; decrement the buffer counter (delete)
   560 FF:29E7: 80 14        	BRA 	LAB_1359
   561                        
   562                        ; call for BASIC input (main entry point)
   563                        LAB_1357
   564 FF:29E9: AF 41 03 00  	lda 	>ConsoleDevice
   565 FF:29ED: C9 00        	cmp 	#$00
   566 FF:29EF: F0 0A        	beq     SimpleSerialEditor
   567                        ;	do screen editor
   568 FF:29F1: 20 EA 25     	jsr	ScreenEditor
   569 FF:29F4: A2 81        	LDX	#<Ibuffs		; set X to buffer start-1 low byte
   570 FF:29F6: A0 21        	LDY	#>Ibuffs		; set Y to buffer start-1 high byte
   571 FF:29F8: A9 00        	LDA 	#$00
   572 FF:29FA: 60           	RTS
   573                        
   574                        SimpleSerialEditor:
   575 FF:29FB: A2 00        	LDX	#$00			; clear BASIC line buffer pointer
   576                        LAB_1359
   577 FF:29FD: 20 C1 18     	JSR	V_INPT			; call scan input device
   578 FF:2A00: B0 FB        	BCS	LAB_1359		; loop if no byte
   579                        	;BEQ	LAB_1359		; loop until valid input (ignore NULLs)
   580                        
   581 FF:2A02: C9 07        	CMP	#$07			; compare with [BELL]
   582 FF:2A04: F0 10        	BEQ	LAB_1378		; branch if [BELL]
   583                        
   584 FF:2A06: C9 0D        	CMP	#$0D			; compare with [CR]
   585 FF:2A08: F0 19        	BEQ	LAB_1384		; do CR/LF exit if [CR]
   586                        
   587 FF:2A0A: E0 00        	CPX	#$00			; compare pointer with $00
   588 FF:2A0C: D0 04        	BNE	LAB_1374		; branch if not empty
   589                        
   590                        ; next two lines ignore any non print character and [SPACE] if input buffer empty
   591                        
   592 FF:2A0E: C9 21        	CMP	#$21			; compare with [SP]+1
   593 FF:2A10: 90 EB        	BCC	LAB_1359		; if < ignore character
   594                        
   595                        LAB_1374
   596 FF:2A12: C9 08        	CMP	#$08			; compare with [BACKSPACE] (delete last character)
   597 FF:2A14: F0 CD        	BEQ	LAB_134B		; go delete last character
   598                        
   599                        LAB_1378
   600 FF:2A16: E0 50        	CPX	#Ibuffe-Ibuffs	; compare character count with max
   601 FF:2A18: B0 0C        	BCS	LAB_138E		; skip store and do [BELL] if buffer full
   602                        
   603 FF:2A1A: 9D 81 21     	STA	Ibuffs,X		; else store in buffer
   604 FF:2A1D: E8           	INX				; increment pointer
   605                        LAB_137F
   606 FF:2A1E: 20 B3 31     	JSR	LAB_PRNA		; go print the character
   607 FF:2A21: D0 DA        	BNE	LAB_1359		; always loop for next character
   608                        
   609                        LAB_1384
   610 FF:2A23: 4C 34 31     	JMP	LAB_1866		; do CR/LF exit to BASIC
   611                        
   612                        ; announce buffer full
   613                        
  Sun Nov 21 2021 15:13                                                                                                Page 92


   614                        LAB_138E
   615 FF:2A26: A9 07        	LDA	#$07			; [BELL] character into A
   616 FF:2A28: D0 F4        	BNE	LAB_137F		; go print the [BELL] but ignore input character
   617                        					; branch always
   618                        
   619                        ; crunch keywords into Basic tokens
   620                        ; position independent buffer version ..
   621                        ; faster, dictionary search version ....
   622                        
   623                        LAB_13A6
   624 FF:2A2A: A0 FF        	LDY	#$FF			; set save index (makes for easy math later)
   625                        
   626 FF:2A2C: 38           	SEC				; set carry for subtract
   627 FF:2A2D: A5 C3        	LDA	<Bpntrl		; get basic execute pointer low byte
   628 FF:2A2F: E9 81        	SBC	#<Ibuffs		; subtract input buffer start pointer
   629 FF:2A31: AA           	TAX				; copy result to X (index past line # if any)
   630                        
   631 FF:2A32: 86 60        	STX	<Oquote		; clear open quote/DATA flag
   632                        LAB_13AC
   633 FF:2A34: BD 81 21     	LDA	Ibuffs,X		; get byte from input buffer
   634 FF:2A37: F0 51        	BEQ	LAB_13EC		; if null save byte then exit
   635                        
   636 FF:2A39: C9 5F        	CMP	#'_'			; compare with "_"
   637 FF:2A3B: B0 4D        	BCS	LAB_13EC		; if >= go save byte then continue crunching
   638                        
   639 FF:2A3D: C9 3C        	CMP	#'<'			; compare with "<"
   640 FF:2A3F: B0 0E        	BCS	LAB_13CC		; if >= go crunch now
   641                        
   642 FF:2A41: C9 30        	CMP	#'0'			; compare with "0"
   643 FF:2A43: B0 45        	BCS	LAB_13EC		; if >= go save byte then continue crunching
   644                        
   645 FF:2A45: 85 5C        	STA	<Scnquo		; save buffer byte as search character
   646 FF:2A47: C9 22        	CMP	#$22			; is it quote character?
   647 FF:2A49: F0 64        	BEQ	LAB_1410		; branch if so (copy quoted string)
   648                        
   649 FF:2A4B: C9 2A        	CMP	#'*'			; compare with "*"
   650 FF:2A4D: 90 3B        	BCC	LAB_13EC		; if < go save byte then continue crunching
   651                        
   652                        						; else crunch now
   653                        LAB_13CC
   654 FF:2A4F: 24 60        	BIT	<Oquote			; get open quote/DATA token flag
   655 FF:2A51: 70 37        	BVS	LAB_13EC		; branch if b6 of <Oquote set (was DATA)
   656                        						; go save byte then continue crunching
   657                        
   658 FF:2A53: 86 78        	STX	<TempB			; save buffer read index
   659 FF:2A55: 84 BA        	STY	<csidx			; copy buffer save index
   660 FF:2A57: A0 73        	LDY	#<TAB_1STC		; get keyword first character table low address
   661 FF:2A59: 84 73        	STY	<ut2_pl			; save pointer low byte
   662 FF:2A5B: A0 11        	LDY	#>TAB_1STC		; get keyword first character table high address
   663 FF:2A5D: 84 74        	STY	<ut2_ph			; save pointer high byte
   664 FF:2A5F: A0 00        	LDY	#$00			; clear table pointer
   665                        
   666                        LAB_13D0
   667 FF:2A61: D1 73        	CMP	(<ut2_pl),Y	; compare with keyword first character table byte
   668 FF:2A63: F0 05        	BEQ	LAB_13D1		; go do word_table_chr if match
   669                        
   670 FF:2A65: 90 21        	BCC	LAB_13EA		; if < keyword first character table byte go restore
  Sun Nov 21 2021 15:13                                                                                                Page 93


   671                        					; Y and save to crunched
   672                        
   673 FF:2A67: C8           	INY				; else increment pointer
   674 FF:2A68: D0 F7        	BNE	LAB_13D0		; and loop (branch always)
   675                        
   676                        ; have matched first character of some keyword
   677                        
   678                        LAB_13D1
   679 FF:2A6A: 98           	TYA				; copy matching index
   680 FF:2A6B: 0A           	ASL	A			; *2 (bytes per pointer)
   681 FF:2A6C: AA           	TAX				; copy to new index
   682 FF:2A6D: BD 92 11     	LDA	TAB_CHRT,X		; get keyword table pointer low byte
   683 FF:2A70: 85 73        	STA	<ut2_pl		; save pointer low byte
   684 FF:2A72: BD 93 11     	LDA	TAB_CHRT+1,X	; get keyword table pointer high byte
   685 FF:2A75: 85 74        	STA	<ut2_ph		; save pointer high byte
   686                        
   687 FF:2A77: A0 FF        	LDY	#$FF			; clear table pointer (make -1 for start)
   688                        
   689 FF:2A79: A6 78        	LDX	<TempB			; restore buffer read index
   690                        
   691                        LAB_13D6
   692 FF:2A7B: C8           	INY				; next table byte
   693 FF:2A7C: B1 73        	LDA (<ut2_pl),Y		; get byte from table
   694                        LAB_13D8
   695 FF:2A7E: 30 08        	BMI	LAB_13EA		; all bytes matched so go save token
   696                        
   697 FF:2A80: E8           	INX				; next buffer byte
   698 FF:2A81: DD 81 21     	CMP	Ibuffs,X		; compare with byte from input buffer
   699 FF:2A84: F0 F5        	BEQ	LAB_13D6		; go compare next if match
   700                        
   701 FF:2A86: D0 2E        	BNE	LAB_1417		; branch if >< (not found keyword)
   702                        
   703                        LAB_13EA
   704 FF:2A88: A4 BA        	LDY	<csidx			; restore save index
   705                        
   706                        					; save crunched to output
   707                        LAB_13EC
   708 FF:2A8A: E8           	INX				; increment buffer index (to next input byte)
   709 FF:2A8B: C8           	INY				; increment save index (to next output byte)
   710 FF:2A8C: 99 81 21     	STA	Ibuffs,Y		; save byte to output
   711 FF:2A8F: C9 00        	CMP	#$00			; set the flags, set carry
   712 FF:2A91: F0 35        	BEQ	LAB_142A		; do exit if was null [EOL]
   713                        
   714                        					; A holds token or byte here
   715 FF:2A93: E9 3A        	SBC	#':'			; subtract ":" (carry set by CMP #00)
   716 FF:2A95: F0 04        	BEQ	LAB_13FF		; branch if it was ":" (is now $00)
   717                        
   718                        					; A now holds token-$3A
   719 FF:2A97: C9 49        	CMP	#TK_DATA-$3A	; compare with DATA token - $3A
   720 FF:2A99: D0 02        	BNE	LAB_1401		; branch if not DATA
   721                        
   722                        					; token was : or DATA
   723                        LAB_13FF
   724 FF:2A9B: 85 60        	STA	<Oquote		; save token-$3A (clear for ":", TK_DATA-$3A for DATA)
   725                        LAB_1401
   726 FF:2A9D: 49 57        	EOR	#TK_REM-$3A		; effectively subtract REM token offset
   727 FF:2A9F: F0 03        	BEQ LAB_1401_A
  Sun Nov 21 2021 15:13                                                                                                Page 94


   728 FF:2AA1: 4C 34 2A     	JMP	LAB_13AC		; If wasn't REM then go crunch rest of line
   729                        
   730                        LAB_1401_A:
   731 FF:2AA4: 85 5C        	STA	<Asrch			; else was REM so set search for [EOL]
   732                        
   733                        					; loop for REM, "..." etc.
   734                        LAB_1408
   735 FF:2AA6: BD 81 21     	LDA	Ibuffs,X		; get byte from input buffer
   736 FF:2AA9: F0 DF        	BEQ	LAB_13EC		; branch if null [EOL]
   737                        
   738 FF:2AAB: C5 5C        	CMP	<Asrch			; compare with stored character
   739 FF:2AAD: F0 DB        	BEQ	LAB_13EC		; branch if match (end quote)
   740                        
   741                        					; entry for copy string in quotes, don't crunch
   742                        LAB_1410
   743 FF:2AAF: C8           	INY				; increment buffer save index
   744 FF:2AB0: 99 81 21     	STA	Ibuffs,Y		; save byte to output
   745 FF:2AB3: E8           	INX				; increment buffer read index
   746 FF:2AB4: D0 F0        	BNE	LAB_1408		; loop while <> 0 (should never be 0!)
   747                        
   748                        					; not found keyword this go
   749                        LAB_1417
   750 FF:2AB6: A6 78        	LDX	<TempB			; compare has failed, restore buffer index (start byte!)
   751                        
   752                        					; now find the end of this word in the table
   753                        LAB_141B
   754 FF:2AB8: B1 73        	LDA (<ut2_pl),Y		; get table byte
   755 FF:2ABA: 08           	PHP				; save status
   756 FF:2ABB: C8           	INY				; increment table index
   757 FF:2ABC: 28           	PLP				; restore byte status
   758 FF:2ABD: 10 F9        	BPL	LAB_141B		; if not end of keyword go do next
   759                        
   760 FF:2ABF: B1 73        	LDA (<ut2_pl),Y		; get byte from keyword table
   761 FF:2AC1: D0 BB        	BNE	LAB_13D8		; go test next word if not zero byte (end of table)
   762                        
   763                        					; reached end of table with no match
   764 FF:2AC3: BD 81 21     	LDA	Ibuffs,X		; restore byte from input buffer
   765 FF:2AC6: 10 C0        	BPL	LAB_13EA		; branch always (all bytes in buffer are $00-$7F)
   766                        					; go save byte in output and continue crunching
   767                        
   768                        					; reached [EOL]
   769                        LAB_142A
   770 FF:2AC8: C8           	INY				; increment pointer
   771 FF:2AC9: C8           	INY				; increment pointer (makes it next line pointer high byte)
   772 FF:2ACA: 99 81 21     	STA	Ibuffs,Y		; save [EOL] (marks [EOT] in immediate mode)
   773 FF:2ACD: C8           	INY				; adjust for line copy
   774 FF:2ACE: C8           	INY				; adjust for line copy
   775 FF:2ACF: C8           	INY				; adjust for line copy
   776 FF:2AD0: C6 C3        	DEC	<Bpntrl		; allow for increment (change if buffer starts at $xxFF)
   777 FF:2AD2: 60           	RTS
   778                        
   779                        ; search Basic for temp integer line number from start of mem
   780                        
   781                        LAB_SSLN
   782 FF:2AD3: A5 79        	LDA	<Smeml			; get start of mem low byte
   783 FF:2AD5: A6 7A        	LDX	<Smemh			; get start of mem high byte
   784                        
  Sun Nov 21 2021 15:13                                                                                                Page 95


   785                        ; search Basic for temp integer line number from AX
   786                        ; returns carry set if found
   787                        ; returns <Baslnl/<Baslnh pointer to found or next higher (not found) line
   788                        
   789                        ; old 541 new 507
   790                        
   791                        LAB_SHLN
   792 FF:2AD7: A0 01        	LDY	#$01			; set index
   793 FF:2AD9: 85 AA        	STA	<Baslnl		; save low byte as current
   794 FF:2ADB: 86 AB        	STX	<Baslnh		; save high byte as current
   795 FF:2ADD: B1 AA        	LDA (<Baslnl),Y		; get pointer high byte from addr
   796 FF:2ADF: F0 1A        	BEQ	LAB_145F		; pointer was zero so we're done, do 'not found' exit
   797                        
   798 FF:2AE1: A0 03        	LDY	#$03			; set index to line # high byte
   799 FF:2AE3: B1 AA        	LDA (<Baslnl),Y		; get line # high byte
   800 FF:2AE5: 88           	DEY				; decrement index (point to low byte)
   801 FF:2AE6: C5 12        	CMP	<Itemph		; compare with temporary integer high byte
   802 FF:2AE8: D0 04        	BNE	LAB_1455		; if <> skip low byte check
   803                        
   804 FF:2AEA: B1 AA        	LDA (<Baslnl),Y		; get line # low byte
   805 FF:2AEC: C5 11        	CMP	<Itempl		; compare with temporary integer low byte
   806                        LAB_1455
   807 FF:2AEE: B0 09        	BCS	LAB_145E		; else if temp < this line, exit (passed line#)
   808                        
   809                        LAB_1456
   810 FF:2AF0: 88           	DEY				; decrement index to next line ptr high byte
   811 FF:2AF1: B1 AA        	LDA (<Baslnl),Y		; get next line pointer high byte
   812 FF:2AF3: AA           	TAX				; copy to X
   813 FF:2AF4: 88           	DEY				; decrement index to next line ptr low byte
   814 FF:2AF5: B1 AA        	LDA (<Baslnl),Y		; get next line pointer low byte
   815 FF:2AF7: 90 DE        	BCC	LAB_SHLN		; go search for line # in temp (<Itempl/<Itemph) from AX
   816                        					; (carry always clear)
   817                        
   818                        LAB_145E
   819 FF:2AF9: F0 01        	BEQ	LAB_1460		; exit if temp = found line #, carry is set
   820                        
   821                        LAB_145F
   822 FF:2AFB: 18           	CLC				; clear found flag
   823                        LAB_1460
   824 FF:2AFC: 60           	RTS
   825                        
   826                        ; perform NEW
   827                        
   828                        LAB_NEW
   829 FF:2AFD: D0 FD        	BNE	LAB_1460		; exit if not end of statement (to do syntax error)
   830                        
   831                        LAB_1463
   832 FF:2AFF: A9 00        	LDA	#$00			; clear A
   833 FF:2B01: A8           	TAY				; clear Y
   834 FF:2B02: 91 79        	STA	(<Smeml),Y		; clear first line, next line pointer, low byte
   835 FF:2B04: C8           	INY				; increment index
   836 FF:2B05: 91 79        	STA	(<Smeml),Y		; clear first line, next line pointer, high byte
   837 FF:2B07: 18           	CLC				; clear carry
   838 FF:2B08: A5 79        	LDA	<Smeml			; get start of mem low byte
   839 FF:2B0A: 69 02        	ADC	#$02			; calculate end of BASIC low byte
   840 FF:2B0C: 85 7B        	STA	<Svarl			; save start of vars low byte
   841 FF:2B0E: A5 7A        	LDA	<Smemh			; get start of mem high byte
  Sun Nov 21 2021 15:13                                                                                                Page 96


   842 FF:2B10: 69 00        	ADC	#$00			; add any carry
   843 FF:2B12: 85 7C        	STA	<Svarh			; save start of vars high byte
   844                        
   845                        ; reset execution to start, clear vars and flush stack
   846                        
   847                        LAB_1477
   848 FF:2B14: 18           	CLC				; clear carry
   849 FF:2B15: A5 79        	LDA	<Smeml			; get start of mem low byte
   850 FF:2B17: 69 FF        	ADC	#$FF			; -1
   851 FF:2B19: 85 C3        	STA	<Bpntrl		; save BASIC execute pointer low byte
   852 FF:2B1B: A5 7A        	LDA	<Smemh			; get start of mem high byte
   853 FF:2B1D: 69 FF        	ADC	#$FF			; -1+carry
   854 FF:2B1F: 85 C4        	STA	<Bpntrh		; save BASIC execute pointer high byte
   855                        ; "CLEAR" command gets here
   856                        
   857                        LAB_147A
   858 FF:2B21: A5 85        	LDA	<Ememl			; get end of mem low byte
   859 FF:2B23: A4 86        	LDY	<Ememh			; get end of mem high byte
   860 FF:2B25: 85 81        	STA	<Sstorl		; set bottom of string space low byte
   861 FF:2B27: 84 82        	STY	<Sstorh		; set bottom of string space high byte
   862 FF:2B29: A5 7B        	LDA	<Svarl			; get start of vars low byte
   863 FF:2B2B: A4 7C        	LDY	<Svarh			; get start of vars high byte
   864 FF:2B2D: 85 7D        	STA	<Sarryl		; save var mem end low byte
   865 FF:2B2F: 84 7E        	STY	<Sarryh		; save var mem end high byte
   866 FF:2B31: 85 7F        	STA	<Earryl		; save array mem end low byte
   867 FF:2B33: 84 80        	STY	<Earryh		; save array mem end high byte
   868 FF:2B35: 20 0C 2D     	JSR	LAB_161A		; perform RESTORE command
   869                        
   870                        ; flush stack and clear continue flag
   871                        
   872                        LAB_1491
   873 FF:2B38: A2 68        	LDX	#<des_sk	; set descriptor stack pointer
   874 FF:2B3A: 86 65        	STX	<next_s		; save descriptor stack pointer
   875                        	AccumulatorIndex16
+  875 FF:2B3C: C2 30        		REP #$30 		; 16 bit Index registers
+  875                        		LONGA ON
+  875                                LONGI ON
   876 FF:2B3E: FA           	PLX				; pull return address low byte
   877 FF:2B3F: A9 FF 7F     	LDA #STACK 		; get the stack address
   878 FF:2B42: 1B           	TCS 			; and set the stack to it
   879 FF:2B43: DA           	PHX
   880                        	AccumulatorIndex8
+  880 FF:2B44: E2 30        		SEP #$30 		; 8 bit Index registers
+  880                        		LONGA OFF
+  880                                LONGI OFF
   881 FF:2B46: A9 00        	LDA	#$00			; clear byte
   882 FF:2B48: 85 8C        	STA	<Cpntrh		; clear continue pointer high byte
   883 FF:2B4A: 85 61        	STA	<Sufnxf		; clear subscript/FNX flag
   884                        LAB_14A6
   885 FF:2B4C: 60           	RTS
   886                        
   887                        ; perform CLEAR
   888                        
   889                        LAB_CLEAR
   890 FF:2B4D: F0 D2        	BEQ	LAB_147A		; if no following token go do "CLEAR"
   891                        
   892                        					; else there was a following token (go do syntax error)
  Sun Nov 21 2021 15:13                                                                                                Page 97


   893 FF:2B4F: 60           	RTS
   894                        
   895                        ; perform LIST [n][-m]
   896                        ; bigger, faster version (a _lot_ faster)
   897                        
   898                        LAB_LIST
   899 FF:2B50: 90 06        	BCC	LAB_14BD		; branch if next character numeric (LIST n..)
   900                        
   901 FF:2B52: F0 04        	BEQ	LAB_14BD		; branch if next character [NULL] (LIST)
   902                        
   903 FF:2B54: C9 CC        	CMP	#TK_MINUS		; compare with token for -
   904 FF:2B56: D0 F4        	BNE	LAB_14A6		; exit if not - (LIST -m)
   905                        
   906                        					; LIST [[n][-m]]
   907                        					; this bit sets the n , if present, as the start and end
   908                        LAB_14BD
   909 FF:2B58: 20 1E 2F     	JSR	LAB_GFPN		; get fixed-point number into temp integer
   910 FF:2B5B: 20 D3 2A     	JSR	LAB_SSLN		; search BASIC for temp integer line number
   911                        					; (pointer in <Baslnl/<Baslnh)
   912 FF:2B5E: 22 C2 00 00  	JSL	LAB_GBYT		; scan memory
   913 FF:2B62: F0 0D        	BEQ	LAB_14D4		; branch if no more characters
   914                        
   915                        					; this bit checks the - is present
   916 FF:2B64: C9 CC        	CMP	#TK_MINUS		; compare with token for -
   917 FF:2B66: D0 61        	BNE	LAB_152B		; return if not "-" (will be Syntax error)
   918                        
   919                        					; LIST [n]-m
   920                        					; the - was there so set m as the end value
   921 FF:2B68: 22 BC 00 00  	JSL	LAB_IGBY		; increment and scan memory
   922 FF:2B6C: 20 1E 2F     	JSR	LAB_GFPN		; get fixed-point number into temp integer
   923 FF:2B6F: D0 58        	BNE	LAB_152B		; exit if not ok
   924                        
   925                        LAB_14D4
   926 FF:2B71: A5 11        	LDA	<Itempl		; get temporary integer low byte
   927 FF:2B73: 05 12        	ORA	<Itemph		; OR temporary integer high byte
   928 FF:2B75: D0 06        	BNE	LAB_14E2		; branch if start set
   929                        
   930 FF:2B77: A9 FF        	LDA	#$FF			; set for -1
   931 FF:2B79: 85 11        	STA	<Itempl		; set temporary integer low byte
   932 FF:2B7B: 85 12        	STA	<Itemph		; set temporary integer high byte
   933                        LAB_14E2
   934 FF:2B7D: A0 01        	LDY	#$01			; set index for line
   935 FF:2B7F: 84 60        	STY	<Oquote		; clear open quote flag
   936 FF:2B81: 20 3D 31     	JSR	LAB_CRLF		; print CR/LF
   937 FF:2B84: B1 AA        	LDA (<Baslnl),Y		; get next line pointer high byte
   938                        					; pointer initially set by search at LAB_14BD
   939 FF:2B86: F0 41        	BEQ	LAB_152B		; if null all done so exit
   940 FF:2B88: 20 D1 2C     	JSR	LAB_1629		; do CRTL-C check vector
   941                        
   942 FF:2B8B: C8           	INY				; increment index for line
   943 FF:2B8C: B1 AA        	LDA (<Baslnl),Y		; get line # low byte
   944 FF:2B8E: AA           	TAX				; copy to X
   945 FF:2B8F: C8           	INY				; increment index
   946 FF:2B90: B1 AA        	LDA (<Baslnl),Y		; get line # high byte
   947 FF:2B92: C5 12        	CMP	<Itemph		; compare with temporary integer high byte
   948 FF:2B94: D0 04        	BNE	LAB_14FF		; branch if no high byte match
   949                        
  Sun Nov 21 2021 15:13                                                                                                Page 98


   950 FF:2B96: E4 11        	CPX	<Itempl		; compare with temporary integer low byte
   951 FF:2B98: F0 02        	BEQ	LAB_1501		; branch if = last line to do (< will pass next branch)
   952                        
   953                        LAB_14FF				; else ..
   954 FF:2B9A: B0 2D        	BCS	LAB_152B		; if greater all done so exit
   955                        
   956                        LAB_1501
   957 FF:2B9C: 84 97        	STY	<Tidx1			; save index for line
   958 FF:2B9E: 20 A3 48     	JSR	LAB_295E		; print XA as unsigned integer
   959 FF:2BA1: A9 20        	LDA	#$20			; space is the next character
   960                        LAB_1508
   961 FF:2BA3: A4 97        	LDY	<Tidx1			; get index for line
   962 FF:2BA5: 29 7F        	AND	#$7F			; mask top out bit of character
   963                        LAB_150C
   964 FF:2BA7: 20 B3 31     	JSR	LAB_PRNA		; go print the character
   965 FF:2BAA: C9 22        	CMP	#$22			; was it " character
   966 FF:2BAC: D0 06        	BNE	LAB_1519		; branch if not
   967                        
   968                        					; we are either entering or leaving a pair of quotes
   969 FF:2BAE: A5 60        	LDA	<Oquote		; get open quote flag
   970 FF:2BB0: 49 FF        	EOR	#$FF			; toggle it
   971 FF:2BB2: 85 60        	STA	<Oquote		; save it back
   972                        LAB_1519
   973 FF:2BB4: C8           	INY				; increment index
   974 FF:2BB5: B1 AA        	LDA (<Baslnl),Y		; get next byte
   975 FF:2BB7: D0 11        	BNE	LAB_152E		; branch if not [EOL] (go print character)
   976 FF:2BB9: A8           	TAY				; else clear index
   977 FF:2BBA: B1 AA        	LDA (<Baslnl),Y		; get next line pointer low byte
   978 FF:2BBC: AA           	TAX				; copy to X
   979 FF:2BBD: C8           	INY				; increment index
   980 FF:2BBE: B1 AA        	LDA (<Baslnl),Y		; get next line pointer high byte
   981 FF:2BC0: 86 AA        	STX	<Baslnl		; set pointer to line low byte
   982 FF:2BC2: 85 AB        	STA	<Baslnh		; set pointer to line high byte
   983 FF:2BC4: F0 03        	BEQ LAB_152B
   984 FF:2BC6: 4C 7D 2B     	JMP	LAB_14E2		; go do next line if not [EOT]
   985                        
   986                        					; else ..
   987                        LAB_152B
   988 FF:2BC9: 60           	RTS
   989                        
   990                        LAB_152E
   991 FF:2BCA: 10 DB        	BPL	LAB_150C		; just go print it if not token byte
   992                        
   993                        					; else was token byte so uncrunch it (maybe)
   994 FF:2BCC: 24 60        	BIT	<Oquote		; test the open quote flag
   995 FF:2BCE: 30 D7        	BMI	LAB_150C		; just go print character if open quote set
   996                        
   997 FF:2BD0: A2 14        	LDX	#>LAB_KEYT		; get table address high byte
   998 FF:2BD2: 0A           	ASL	A			; *2
   999 FF:2BD3: 0A           	ASL	A			; *4
  1000 FF:2BD4: 90 02        	BCC	LAB_152F		; branch if no carry
  1001                        
  1002 FF:2BD6: E8           	INX				; else increment high byte
  1003 FF:2BD7: 18           	CLC				; clear carry for add
  1004                        LAB_152F
  1005 FF:2BD8: 69 04        	ADC	#<LAB_KEYT		; add low byte
  1006 FF:2BDA: 90 01        	BCC	LAB_1530		; branch if no carry
  Sun Nov 21 2021 15:13                                                                                                Page 99


  1007                        
  1008 FF:2BDC: E8           	INX				; else increment high byte
  1009                        LAB_1530
  1010 FF:2BDD: 85 73        	STA	<ut2_pl		; save table pointer low byte
  1011 FF:2BDF: 86 74        	STX	<ut2_ph		; save table pointer high byte
  1012 FF:2BE1: 84 97        	STY	<Tidx1			; save index for line
  1013 FF:2BE3: A0 00        	LDY	#$00			; clear index
  1014 FF:2BE5: B1 73        	LDA (<ut2_pl),Y		; get length
  1015 FF:2BE7: AA           	TAX				; copy length
  1016 FF:2BE8: C8           	INY				; increment index
  1017 FF:2BE9: B1 73        	LDA (<ut2_pl),Y		; get 1st character
  1018 FF:2BEB: CA           	DEX				; decrement length
  1019 FF:2BEC: D0 03        	BNE LAB_1508_A
  1020 FF:2BEE: 4C A3 2B     	JMP	LAB_1508		; if no more characters exit and print
  1021                        LAB_1508_A:
  1022 FF:2BF1: 20 B3 31     	JSR	LAB_PRNA		; go print the character
  1023 FF:2BF4: C8           	INY				; increment index
  1024 FF:2BF5: B1 73        	LDA (<ut2_pl),Y		; get keyword address low byte
  1025 FF:2BF7: 48           	PHA				; save it for now
  1026 FF:2BF8: C8           	INY				; increment index
  1027 FF:2BF9: B1 73        	LDA (<ut2_pl),Y		; get keyword address high byte
  1028 FF:2BFB: A0 00        	LDY	#$00
  1029 FF:2BFD: 85 74        	STA	<ut2_ph		; save keyword pointer high byte
  1030 FF:2BFF: 68           	PLA				; pull low byte
  1031 FF:2C00: 85 73        	STA	<ut2_pl		; save keyword pointer low byte
  1032                        LAB_1540
  1033 FF:2C02: B1 73        	LDA (<ut2_pl),Y		; get character
  1034 FF:2C04: CA           	DEX				; decrement character count
  1035 FF:2C05: D0 03        	BNE LAB_1508_B
  1036 FF:2C07: 4C A3 2B     	JMP	LAB_1508		; if last character exit and print
  1037                        LAB_1508_B:
  1038 FF:2C0A: 20 B3 31     	JSR	LAB_PRNA		; go print the character
  1039 FF:2C0D: C8           	INY				; increment index
  1040 FF:2C0E: D0 F2        	BNE	LAB_1540		; loop for next character
  1041                        
  1042                        ; perform FOR
  1043                        
  1044                        LAB_FOR
  1045 FF:2C10: A9 80        	LDA	#$80			; set FNX
  1046 FF:2C12: 85 61        	STA	<Sufnxf		; set subscript/FNX flag
  1047 FF:2C14: 20 80 2F     	JSR	LAB_LET		; go do LET
  1048 FF:2C17: 68           	PLA				; pull return address
  1049 FF:2C18: 68           	PLA				; pull return address
  1050 FF:2C19: A9 10        	LDA	#$10			; we need 16d bytes !
  1051 FF:2C1B: 20 78 28     	JSR	LAB_1212		; check room on stack for A bytes
  1052 FF:2C1E: 20 6C 2E     	JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
  1053 FF:2C21: 18           	CLC				; clear carry for add
  1054 FF:2C22: 98           	TYA				; copy index to A
  1055 FF:2C23: 65 C3        	ADC	<Bpntrl		; add BASIC execute pointer low byte
  1056 FF:2C25: 48           	PHA				; push onto stack
  1057 FF:2C26: A5 C4        	LDA	<Bpntrh		; get BASIC execute pointer high byte
  1058 FF:2C28: 69 00        	ADC	#$00			; add carry
  1059 FF:2C2A: 48           	PHA				; push onto stack
  1060 FF:2C2B: A5 88        	LDA	<Clineh		; get current line high byte
  1061 FF:2C2D: 48           	PHA				; push onto stack
  1062 FF:2C2E: A5 87        	LDA	<Clinel		; get current line low byte
  1063 FF:2C30: 48           	PHA				; push onto stack
  Sun Nov 21 2021 15:13                                                                                                Page 100


  1064 FF:2C31: A9 C2        	LDA	#TK_TO		; get "TO" token
  1065 FF:2C33: 20 15 35     	JSR	LAB_SCCA		; scan for CHR$(A) , else do syntax error then warm start
  1066 FF:2C36: 20 F1 33     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  1067 FF:2C39: 20 EE 33     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
  1068                        					; else do type mismatch
  1069 FF:2C3C: A5 B0        	LDA	<FAC1_s		; get FAC1 sign (b7)
  1070 FF:2C3E: 09 7F        	ORA	#$7F			; set all non sign bits
  1071 FF:2C40: 25 AD        	AND	<FAC1_1		; and FAC1 mantissa1
  1072 FF:2C42: 85 AD        	STA	<FAC1_1		; save FAC1 mantissa1
  1073 FF:2C44: A9 4F        	LDA	#<LAB_159F		; set return address low byte
  1074 FF:2C46: A0 2C        	LDY	#>LAB_159F		; set return address high byte
  1075 FF:2C48: 85 71        	STA	<ut1_pl		; save return address low byte
  1076 FF:2C4A: 84 72        	STY	<ut1_ph		; save return address high byte
  1077 FF:2C4C: 4C A7 34     	JMP	LAB_1B66		; round FAC1 and put on stack (returns to next instruction)
  1078                        
  1079                        LAB_159F
  1080 FF:2C4F: A9 9A        	LDA	#<LAB_259C		; set 1 pointer low addr (default step size)
  1081 FF:2C51: A0 18        	LDY	#>LAB_259C		; set 1 pointer high addr
  1082 FF:2C53: 20 7C 45     	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
  1083 FF:2C56: 22 C2 00 00  	JSL	LAB_GBYT		; scan memory
  1084 FF:2C5A: C9 C7        	CMP	#TK_STEP		; compare with STEP token
  1085 FF:2C5C: D0 07        	BNE	LAB_15B3		; jump if not "STEP"
  1086                        
  1087                        					;.was step so ..
  1088 FF:2C5E: 22 BC 00 00  	JSL	LAB_IGBY		; increment and scan memory
  1089 FF:2C62: 20 EE 33     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
  1090                        					; else do type mismatch
  1091                        LAB_15B3
  1092 FF:2C65: 20 88 46     	JSR	LAB_27CA		; return A=FF,C=1/-ve A=01,C=0/+ve
  1093 FF:2C68: 85 B0        	STA	<FAC1_s		; set FAC1 sign (b7)
  1094                        					; this is +1 for +ve step and -1 for -ve step, in NEXT we
  1095                        					; compare the FOR value and the TO value and return +1 if
  1096                        					; FOR > TO, 0 if FOR = TO and -1 if FOR < TO. the value
  1097                        					; here (+/-1) is then compared to that result and if they
  1098                        					; are the same (+ve and FOR > TO or -ve and FOR < TO) then
  1099                        					; the loop is done
  1100 FF:2C6A: 20 9C 34     	JSR	LAB_1B5B		; push sign, round FAC1 and put on stack
  1101 FF:2C6D: A5 98        	LDA	<Frnxth		; get var pointer for FOR/NEXT high byte
  1102 FF:2C6F: 48           	PHA				; push on stack
  1103 FF:2C70: A5 97        	LDA	<Frnxtl		; get var pointer for FOR/NEXT low byte
  1104 FF:2C72: 48           	PHA				; push on stack
  1105 FF:2C73: A9 81        	LDA	#TK_FOR		; get FOR token
  1106 FF:2C75: 48           	PHA				; push on stack
  1107                        
  1108                        ; interpreter inner loop
  1109                        
  1110                        LAB_15C2
  1111 FF:2C76: 20 D1 2C     	JSR	LAB_1629		; do CRTL-C check vector
  1112 FF:2C79: A5 C3        	LDA	<Bpntrl		; get BASIC execute pointer low byte
  1113 FF:2C7B: A4 C4        	LDY	<Bpntrh		; get BASIC execute pointer high byte
  1114                        
  1115 FF:2C7D: A6 88        	LDX	<Clineh		; continue line is $FFxx for immediate mode
  1116                        					; ($00xx for RUN from immediate mode)
  1117 FF:2C7F: E8           	INX				; increment it (now $00 if immediate mode)
  1118 FF:2C80: F0 04        	BEQ	LAB_15D1		; branch if null (immediate mode)
  1119                        
  1120 FF:2C82: 85 8B        	STA	<Cpntrl		; save continue pointer low byte
  Sun Nov 21 2021 15:13                                                                                                Page 101


  1121 FF:2C84: 84 8C        	STY	<Cpntrh		; save continue pointer high byte
  1122                        LAB_15D1
  1123 FF:2C86: A0 00        	LDY	#$00			; clear index
  1124 FF:2C88: B1 C3        	LDA (<Bpntrl),Y		; get next byte
  1125 FF:2C8A: F0 07        	BEQ	LAB_15DC		; branch if null [EOL]
  1126                        
  1127 FF:2C8C: C9 3A        	CMP	#':'			; compare with ":"
  1128 FF:2C8E: F0 1D        	BEQ	LAB_15F6		; branch if = (statement separator)
  1129                        
  1130                        LAB_15D9
  1131 FF:2C90: 4C 28 35     	JMP	LAB_SNER		; else syntax error then warm start
  1132                        
  1133                        					; have reached [EOL]
  1134                        LAB_15DC
  1135 FF:2C93: A0 02        	LDY	#$02			; set index
  1136 FF:2C95: B1 C3        	LDA (<Bpntrl),Y		; get next line pointer high byte
  1137 FF:2C97: 18           	CLC				; clear carry for no "BREAK" message
  1138 FF:2C98: F0 59        	BEQ	LAB_1651		; if null go to immediate mode (was immediate or [EOT]
  1139                        					; marker)
  1140                        
  1141 FF:2C9A: C8           	INY				; increment index
  1142 FF:2C9B: B1 C3        	LDA (<Bpntrl),Y		; get line # low byte
  1143 FF:2C9D: 85 87        	STA	<Clinel		; save current line low byte
  1144 FF:2C9F: C8           	INY				; increment index
  1145 FF:2CA0: B1 C3        	LDA (<Bpntrl),Y		; get line # high byte
  1146 FF:2CA2: 85 88        	STA	<Clineh		; save current line high byte
  1147 FF:2CA4: 98           	TYA				; A now = 4
  1148 FF:2CA5: 65 C3        	ADC	<Bpntrl		; add BASIC execute pointer low byte
  1149 FF:2CA7: 85 C3        	STA	<Bpntrl		; save BASIC execute pointer low byte
  1150 FF:2CA9: 90 02        	BCC	LAB_15F6		; branch if no overflow
  1151                        
  1152 FF:2CAB: E6 C4        	INC	<Bpntrh		; else increment BASIC execute pointer high byte
  1153                        LAB_15F6
  1154 FF:2CAD: 22 BC 00 00  	JSL	LAB_IGBY		; increment and scan memory
  1155                        
  1156                        
  1157                        
  1158                        
  1159                        LAB_15F9
  1160 FF:2CB1: 20 B7 2C     	JSR	LAB_15FF		; go interpret BASIC code from (<Bpntrl)
  1161                        LAB_15FC
  1162 FF:2CB4: 4C 76 2C     	JMP	LAB_15C2		; loop
  1163                        
  1164                        ; interpret BASIC code from (<Bpntrl)
  1165                        
  1166                        LAB_15FF
  1167 FF:2CB7: F0 61        	BEQ	LAB_1628		; exit if zero [EOL]
  1168                        
  1169                        LAB_1602
  1170 FF:2CB9: 0A           	ASL	A			; *2 bytes per vector and normalise token
  1171 FF:2CBA: B0 03        	BCS	LAB_1609		; branch if was token
  1172 FF:2CBC: 4C 80 2F     	JMP	LAB_LET			; else go do implied LET
  1173                        
  1174                        LAB_1609
  1175             00000080   TK_TABUSE .EQU 	(TK_TAB-$80)*2
  1176 FF:2CBF: C9 80        	CMP	#TK_TABUSE		; compare normalised token * 2 with TAB
  1177 FF:2CC1: B0 CD        	BCS	LAB_15D9		; branch if A>=TAB (do syntax error then warm start)
  Sun Nov 21 2021 15:13                                                                                                Page 102


  1178                        					; only tokens before TAB can start a line
  1179 FF:2CC3: A8           	TAY				; copy to index
  1180 FF:2CC4: B9 39 10     	LDA	LAB_CTBL+1,Y		; get vector high byte
  1181 FF:2CC7: 48           	PHA				; onto stack
  1182 FF:2CC8: B9 38 10     	LDA	LAB_CTBL,Y		; get vector low byte
  1183 FF:2CCB: 48           	PHA				; onto stack
  1184 FF:2CCC: 22 BC 00 00  	JSL	LAB_IGBY		; jump to increment and scan memory
  1185                        					; then "return" to vector
  1186 FF:2CD0: 60           	RTS
  1187                        ; CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
  1188                        ; key press is detected.
  1189                        
  1190                        LAB_1629
  1191 FF:2CD1: 6C 03 02     	JMP	(VEC_CC)		; ctrl c check vector
  1192                        
  1193                        ; if there was a key press it gets back here ..
  1194                        
  1195                        LAB_1636
  1196 FF:2CD4: C9 03        	CMP	#$03			; compare with CTRL-C
  1197                        
  1198                        ; perform STOP
  1199                        
  1200                        LAB_STOP
  1201 FF:2CD6: B0 01        	BCS	LAB_163B		; branch if token follows STOP
  1202                        					; else just END
  1203                        ; END
  1204                        
  1205                        LAB_END
  1206 FF:2CD8: 18           	CLC				; clear the carry, indicate a normal program end
  1207                        LAB_163B
  1208 FF:2CD9: D0 72        	BNE	LAB_167A		; if wasn't CTRL-C or there is a following byte return
  1209                        
  1210 FF:2CDB: A5 C4        	LDA	<Bpntrh		; get the BASIC execute pointer high byte
  1211 FF:2CDD: 49 21        	EOR	#>Ibuffs		; compare with buffer address high byte (Cb unchanged)
  1212 FF:2CDF: F0 10        	BEQ	LAB_164F		; branch if the BASIC pointer is in the input buffer
  1213                        					; (can't continue in immediate mode)
  1214                        
  1215                        					; else ..
  1216 FF:2CE1: 49 21        	EOR	#>Ibuffs		; correct the bits
  1217 FF:2CE3: A4 C3        	LDY	<Bpntrl		; get BASIC execute pointer low byte
  1218 FF:2CE5: 84 8B        	STY	<Cpntrl		; save continue pointer low byte
  1219 FF:2CE7: 85 8C        	STA	<Cpntrh		; save continue pointer high byte
  1220                        LAB_1647
  1221 FF:2CE9: A5 87        	LDA	<Clinel		; get current line low byte
  1222 FF:2CEB: A4 88        	LDY	<Clineh		; get current line high byte
  1223 FF:2CED: 85 89        	STA	<Blinel		; save break line low byte
  1224 FF:2CEF: 84 8A        	STY	<Blineh		; save break line high byte
  1225                        LAB_164F
  1226 FF:2CF1: 68           	PLA				; pull return address low
  1227 FF:2CF2: 68           	PLA				; pull return address high
  1228                        LAB_1651
  1229 FF:2CF3: 90 12        	BCC	LAB_165E		; if was program end just do warm start
  1230                        
  1231                        					; else ..
  1232                        
  1233 FF:2CF5: A5 06        	lda <VIDEOMODE
  1234 FF:2CF7: C9 02        	cmp #2
  Sun Nov 21 2021 15:13                                                                                                Page 103


  1235 FF:2CF9: F0 05        	beq LAB_1651A
  1236 FF:2CFB: A2 02        	ldx #2
  1237 FF:2CFD: 20 4C 1E     	jsr V_SCREEN1
  1238                        LAB_1651A
  1239 FF:2D00: A9 C2        	LDA	#<LAB_BMSG		; point to "Break" low byte
  1240 FF:2D02: A0 17        	LDY	#>LAB_BMSG		; point to "Break" high byte
  1241 FF:2D04: 4C E1 28     	JMP	LAB_1269		; print "Break" and do warm start
  1242                        
  1243                        LAB_165E
  1244 FF:2D07: 4C EC 28     	JMP	LAB_1274		; go do warm start
  1245                        
  1246                        ; perform RESTORE
  1247                        
  1248                        LAB_RESTORE
  1249 FF:2D0A: D0 0F        	BNE	LAB_RESTOREn	; branch if next character not null (RESTORE n)
  1250                        
  1251                        LAB_161A
  1252 FF:2D0C: 38           	SEC				; set carry for subtract
  1253 FF:2D0D: A5 79        	LDA	<Smeml			; get start of mem low byte
  1254 FF:2D0F: E9 01        	SBC	#$01			; -1
  1255 FF:2D11: A4 7A        	LDY	<Smemh			; get start of mem high byte
  1256 FF:2D13: B0 01        	BCS	LAB_1624		; branch if no underflow
  1257                        
  1258                        LAB_uflow
  1259 FF:2D15: 88           	DEY				; else decrement high byte
  1260                        LAB_1624
  1261 FF:2D16: 85 8F        	STA	<Dptrl			; save DATA pointer low byte
  1262 FF:2D18: 84 90        	STY	<Dptrh			; save DATA pointer high byte
  1263                        LAB_1628
  1264 FF:2D1A: 60           	RTS
  1265                        
  1266                        					; is RESTORE n
  1267                        LAB_RESTOREn
  1268 FF:2D1B: 20 1E 2F     	JSR	LAB_GFPN		; get fixed-point number into temp integer
  1269 FF:2D1E: 20 6F 2E     	JSR	LAB_SNBL		; scan for next BASIC line
  1270 FF:2D21: A5 88        	LDA	<Clineh		; get current line high byte
  1271 FF:2D23: C5 12        	CMP	<Itemph		; compare with temporary integer high byte
  1272 FF:2D25: B0 0B        	BCS	LAB_reset_search	; branch if >= (start search from beginning)
  1273                        
  1274 FF:2D27: 98           	TYA				; else copy line index to A
  1275 FF:2D28: 38           	SEC				; set carry (+1)
  1276 FF:2D29: 65 C3        	ADC	<Bpntrl		; add BASIC execute pointer low byte
  1277 FF:2D2B: A6 C4        	LDX	<Bpntrh		; get BASIC execute pointer high byte
  1278 FF:2D2D: 90 07        	BCC	LAB_go_search	; branch if no overflow to high byte
  1279                        
  1280 FF:2D2F: E8           	INX				; increment high byte
  1281 FF:2D30: B0 04        	BCS	LAB_go_search	; branch always (can never be carry clear)
  1282                        
  1283                        ; search for line # in temp (<Itempl/<Itemph) from start of mem pointer (<Smeml)
  1284                        
  1285                        LAB_reset_search
  1286 FF:2D32: A5 79        	LDA	<Smeml			; get start of mem low byte
  1287 FF:2D34: A6 7A        	LDX	<Smemh			; get start of mem high byte
  1288                        
  1289                        ; search for line # in temp (<Itempl/<Itemph) from (AX)
  1290                        
  1291                        LAB_go_search
  Sun Nov 21 2021 15:13                                                                                                Page 104


  1292                        
  1293 FF:2D36: 20 D7 2A     	JSR	LAB_SHLN		; search Basic for temp integer line number from AX
  1294 FF:2D39: B0 03        	BCS	LAB_line_found	; if carry set go set pointer
  1295                        
  1296 FF:2D3B: 4C 41 2E     	JMP	LAB_16F7		; else go do "Undefined statement" error
  1297                        
  1298                        LAB_line_found
  1299                        					; carry already set for subtract
  1300 FF:2D3E: A5 AA        	LDA	<Baslnl		; get pointer low byte
  1301 FF:2D40: E9 01        	SBC	#$01			; -1
  1302 FF:2D42: A4 AB        	LDY	<Baslnh		; get pointer high byte
  1303 FF:2D44: B0 D0        	BCS	LAB_1624		; branch if no underflow (save DATA pointer and return)
  1304                        
  1305 FF:2D46: 90 CD        	BCC	LAB_uflow		; else decrement high byte then save DATA pointer and
  1306                        					; return (branch always)
  1307                        
  1308                        ; perform NULL
  1309                        
  1310                        LAB_NULL
  1311 FF:2D48: 20 9E 40     	JSR	LAB_GTBY		; get byte parameter
  1312 FF:2D4B: 86 0D        	STX	<Nullct		; save new NULL count
  1313                        LAB_167A
  1314 FF:2D4D: 60           	RTS
  1315                        
  1316                        ; perform CONT
  1317                        
  1318                        LAB_CONT
  1319 FF:2D4E: D0 FD        	BNE	LAB_167A		; if following byte exit to do syntax error
  1320                        
  1321 FF:2D50: A4 8C        	LDY	<Cpntrh		; get continue pointer high byte
  1322 FF:2D52: D0 05        	BNE	LAB_166C		; go do continue if we can
  1323                        
  1324 FF:2D54: A2 1E        	LDX	#$1E			; error code $1E ("Can't continue" error)
  1325 FF:2D56: 4C C1 28     	JMP	LAB_XERR		; do error #X, then warm start
  1326                        
  1327                        					; we can continue so ..
  1328                        LAB_166C
  1329 FF:2D59: A9 93        	LDA	#TK_ON		; set token for ON
  1330 FF:2D5B: 20 B8 4D     	JSR	LAB_IRQ		; set IRQ flags
  1331 FF:2D5E: A9 93        	LDA	#TK_ON		; set token for ON
  1332 FF:2D60: 20 BB 4D     	JSR	LAB_NMI		; set NMI flags
  1333                        
  1334 FF:2D63: 84 C4        	STY	<Bpntrh		; save BASIC execute pointer high byte
  1335 FF:2D65: A5 8B        	LDA	<Cpntrl		; get continue pointer low byte
  1336 FF:2D67: 85 C3        	STA	<Bpntrl		; save BASIC execute pointer low byte
  1337 FF:2D69: A5 89        	LDA	<Blinel		; get break line low byte
  1338 FF:2D6B: A4 8A        	LDY	<Blineh		; get break line high byte
  1339 FF:2D6D: 85 87        	STA	<Clinel		; set current line low byte
  1340 FF:2D6F: 84 88        	STY	<Clineh		; set current line high byte
  1341 FF:2D71: 60           	RTS
  1342                        
  1343                        ; perform RUN
  1344                        
  1345                        LAB_RUN
  1346 FF:2D72: D0 03        	BNE	LAB_1696		; branch if RUN n
  1347 FF:2D74: 4C 14 2B     	JMP	LAB_1477		; reset execution to start, clear variables, flush stack and
  1348                        					; return
  Sun Nov 21 2021 15:13                                                                                                Page 105


  1349                        
  1350                        ; does RUN n
  1351                        
  1352                        LAB_1696
  1353 FF:2D77: 20 21 2B     	JSR	LAB_147A		; go do "CLEAR"
  1354 FF:2D7A: F0 2F        	BEQ	LAB_16B0		; get n and do GOTO n (branch always as CLEAR sets Z=1)
  1355                        
  1356                        ; perform DO
  1357                        
  1358                        LAB_DO
  1359 FF:2D7C: A9 05        	LDA	#$05			; need 5 bytes for DO
  1360 FF:2D7E: 20 78 28     	JSR	LAB_1212		; check room on stack for A bytes
  1361 FF:2D81: A5 C4        	LDA	<Bpntrh		; get BASIC execute pointer high byte
  1362 FF:2D83: 48           	PHA				; push on stack
  1363 FF:2D84: A5 C3        	LDA	<Bpntrl		; get BASIC execute pointer low byte
  1364 FF:2D86: 48           	PHA				; push on stack
  1365 FF:2D87: A5 88        	LDA	<Clineh		; get current line high byte
  1366 FF:2D89: 48           	PHA				; push on stack
  1367 FF:2D8A: A5 87        	LDA	<Clinel		; get current line low byte
  1368 FF:2D8C: 48           	PHA				; push on stack
  1369 FF:2D8D: A9 9C        	LDA	#TK_DO		; token for DO
  1370 FF:2D8F: 48           	PHA				; push on stack
  1371 FF:2D90: 22 C2 00 00  	JSL	LAB_GBYT		; scan memory
  1372 FF:2D94: 4C 76 2C     	JMP	LAB_15C2		; go do interpreter inner loop
  1373                        
  1374                        ; perform GOSUB
  1375                        
  1376                        LAB_GOSUB
  1377 FF:2D97: A9 05        	LDA	#$05			; need 5 bytes for GOSUB
  1378 FF:2D99: 20 78 28     	JSR	LAB_1212		; check room on stack for A bytes
  1379 FF:2D9C: A5 C4        	LDA	<Bpntrh		; get BASIC execute pointer high byte
  1380 FF:2D9E: 48           	PHA				; push on stack
  1381 FF:2D9F: A5 C3        	LDA	<Bpntrl		; get BASIC execute pointer low byte
  1382 FF:2DA1: 48           	PHA				; push on stack
  1383 FF:2DA2: A5 88        	LDA	<Clineh		; get current line high byte
  1384 FF:2DA4: 48           	PHA				; push on stack
  1385 FF:2DA5: A5 87        	LDA	<Clinel		; get current line low byte
  1386 FF:2DA7: 48           	PHA				; push on stack
  1387 FF:2DA8: A9 8F        	LDA	#TK_GOSUB		; token for GOSUB
  1388 FF:2DAA: 48           	PHA				; push on stack
  1389                        LAB_16B0
  1390 FF:2DAB: 22 C2 00 00  	JSL	LAB_GBYT		; scan memory
  1391 FF:2DAF: 20 B5 2D     	JSR	LAB_GOTO		; perform GOTO n
  1392 FF:2DB2: 4C 76 2C     	JMP	LAB_15C2		; go do interpreter inner loop
  1393                        					; (can't RTS, we used the stack!)
  1394                        
  1395                        ; perform GOTO
  1396                        
  1397                        LAB_GOTO
  1398 FF:2DB5: 20 1E 2F     	JSR	LAB_GFPN		; get fixed-point number into temp integer
  1399 FF:2DB8: 20 6F 2E     	JSR	LAB_SNBL		; scan for next BASIC line
  1400 FF:2DBB: A5 88        	LDA	<Clineh		; get current line high byte
  1401 FF:2DBD: C5 12        	CMP	<Itemph		; compare with temporary integer high byte
  1402 FF:2DBF: B0 0B        	BCS	LAB_16D0		; branch if >= (start search from beginning)
  1403                        
  1404 FF:2DC1: 98           	TYA				; else copy line index to A
  1405 FF:2DC2: 38           	SEC				; set carry (+1)
  Sun Nov 21 2021 15:13                                                                                                Page 106


  1406 FF:2DC3: 65 C3        	ADC	<Bpntrl		; add BASIC execute pointer low byte
  1407 FF:2DC5: A6 C4        	LDX	<Bpntrh		; get BASIC execute pointer high byte
  1408 FF:2DC7: 90 07        	BCC	LAB_16D4		; branch if no overflow to high byte
  1409                        
  1410 FF:2DC9: E8           	INX				; increment high byte
  1411 FF:2DCA: B0 04        	BCS	LAB_16D4		; branch always (can never be carry)
  1412                        
  1413                        ; search for line # in temp (<Itempl/<Itemph) from start of mem pointer (<Smeml)
  1414                        
  1415                        LAB_16D0
  1416 FF:2DCC: A5 79        	LDA	<Smeml			; get start of mem low byte
  1417 FF:2DCE: A6 7A        	LDX	<Smemh			; get start of mem high byte
  1418                        
  1419                        ; search for line # in temp (<Itempl/<Itemph) from (AX)
  1420                        
  1421                        LAB_16D4
  1422 FF:2DD0: 20 D7 2A     	JSR	LAB_SHLN		; search Basic for temp integer line number from AX
  1423 FF:2DD3: 90 6C        	BCC	LAB_16F7		; if carry clear go do "Undefined statement" error
  1424                        					; (unspecified statement)
  1425                        
  1426                        					; carry already set for subtract
  1427 FF:2DD5: A5 AA        	LDA	<Baslnl		; get pointer low byte
  1428 FF:2DD7: E9 01        	SBC	#$01			; -1
  1429 FF:2DD9: 85 C3        	STA	<Bpntrl		; save BASIC execute pointer low byte
  1430 FF:2DDB: A5 AB        	LDA	<Baslnh		; get pointer high byte
  1431 FF:2DDD: E9 00        	SBC	#$00			; subtract carry
  1432 FF:2DDF: 85 C4        	STA	<Bpntrh		; save BASIC execute pointer high byte
  1433                        LAB_16E5
  1434 FF:2DE1: 60           	RTS
  1435                        
  1436                        LAB_DONOK
  1437 FF:2DE2: A2 22        	LDX	#$22			; error code $22 ("LOOP without DO" error)
  1438 FF:2DE4: 4C C1 28     	JMP	LAB_XERR		; do error #X, then warm start
  1439                        
  1440                        ; perform LOOP
  1441                        
  1442                        LAB_LOOP
  1443 FF:2DE7: A8           	TAY				; save following token
  1444 FF:2DE8: A3 03        	LDA	3,S			; get token byte from stack
  1445 FF:2DEA: C9 9C        	CMP	#TK_DO		; compare with DO token
  1446 FF:2DEC: D0 F4        	BNE	LAB_DONOK	; branch if no matching DO
  1447                        
  1448                        	; FIXUP STACK
  1449                        	Index16
+ 1449 FF:2DEE: C2 10        		REP #$10 		; 16 bit Index registers
+ 1449                        		LONGI ON
  1450 FF:2DF0: BA           	TSX
  1451 FF:2DF1: E8           	INX				; dump calling routine return address
  1452 FF:2DF2: E8           	INX				; dump calling routine return address
  1453 FF:2DF3: 9A           	TXS				; correct stack
  1454                        	Index8
+ 1454 FF:2DF4: E2 10        		SEP #$10 		; 8 bit Index registers
+ 1454                        		LONGI OFF
  1455                        
  1456 FF:2DF6: 98           	TYA				; get saved following token back
  1457 FF:2DF7: F0 20        	BEQ	LoopAlways		; if no following token loop forever
  1458                        					; (stack pointer in X)
  Sun Nov 21 2021 15:13                                                                                                Page 107


  1459                        
  1460 FF:2DF9: C9 3A        	CMP	#':'			; could be ':'
  1461 FF:2DFB: F0 1C        	BEQ	LoopAlways		; if :... loop forever
  1462                        
  1463 FF:2DFD: E9 C8        	SBC	#TK_UNTIL		; subtract token for UNTIL, we know carry is set here
  1464 FF:2DFF: AA           	TAX				; copy to X (if it was UNTIL then Y will be correct)
  1465 FF:2E00: F0 04        	BEQ	DoRest		; branch if was UNTIL
  1466                        
  1467 FF:2E02: CA           	DEX				; decrement result
  1468 FF:2E03: D0 64        	BNE	LAB_16FC		; if not WHILE go do syntax error and warm start
  1469                        					; only if the token was WHILE will this fail
  1470                        
  1471 FF:2E05: CA           	DEX				; set invert result byte
  1472                        DoRest
  1473 FF:2E06: 86 98        	STX	<Frnxth		; save invert result byte
  1474 FF:2E08: 22 BC 00 00  	JSL	LAB_IGBY		; increment and scan memory
  1475 FF:2E0C: 20 02 34     	JSR	LAB_EVEX		; evaluate expression
  1476 FF:2E0F: A5 AC        	LDA	<FAC1_e		; get FAC1 exponent
  1477 FF:2E11: F0 02        	BEQ	DoCmp			; if =0 go do straight compare
  1478                        
  1479 FF:2E13: A9 FF        	LDA	#$FF			; else set all bits
  1480                        DoCmp
  1481 FF:2E15: 45 98        	EOR	<Frnxth		; EOR with invert byte
  1482 FF:2E17: D0 17        	BNE	LoopDone		; if <> 0 clear stack and back to interpreter loop
  1483                        
  1484                        					; loop condition wasn't met so do it again
  1485                        LoopAlways
  1486 FF:2E19: A3 02        	LDA	2,S			; get current line low byte
  1487 FF:2E1B: 85 87        	STA	<Clinel		; save current line low byte
  1488 FF:2E1D: A3 03        	LDA	3,S			; get current line high byte
  1489 FF:2E1F: 85 88        	STA	<Clineh		; save current line high byte
  1490 FF:2E21: A3 04        	LDA	4,S			; get BASIC execute pointer low byte
  1491 FF:2E23: 85 C3        	STA	<Bpntrl		; save BASIC execute pointer low byte
  1492 FF:2E25: A3 05        	LDA	5,S			; get BASIC execute pointer high byte
  1493 FF:2E27: 85 C4        	STA	<Bpntrh		; save BASIC execute pointer high byte
  1494 FF:2E29: 22 C2 00 00  	JSL	LAB_GBYT		; scan memory
  1495 FF:2E2D: 4C 76 2C     	JMP	LAB_15C2		; go do interpreter inner loop
  1496                        
  1497                        					; clear stack and back to interpreter loop
  1498                        LoopDone
  1499                        	Index16
+ 1499 FF:2E30: C2 10        		REP #$10 		; 16 bit Index registers
+ 1499                        		LONGI ON
  1500 FF:2E32: BA           	TSX
  1501 FF:2E33: E8           	INX				; dump DO token
  1502 FF:2E34: E8           	INX				; dump current line low byte
  1503 FF:2E35: E8           	INX				; dump current line high byte
  1504 FF:2E36: E8           	INX				; dump BASIC execute pointer low byte
  1505 FF:2E37: E8           	INX				; dump BASIC execute pointer high byte
  1506 FF:2E38: 9A           	TXS				; correct stack
  1507                        	Index8
+ 1507 FF:2E39: E2 10        		SEP #$10 		; 8 bit Index registers
+ 1507                        		LONGI OFF
  1508 FF:2E3B: 4C 5B 2E     	JMP	LAB_DATA		; go perform DATA (find : or [EOL])
  1509                        
  1510                        ; do the return without gosub error
  1511                        
  Sun Nov 21 2021 15:13                                                                                                Page 108


  1512                        LAB_16F4
  1513 FF:2E3E: A2 04        	LDX	#$04			; error code $04 ("RETURN without GOSUB" error)
  1514 FF:2E40: 2C           	.byte	$2C			; makes next line BIT LAB_0EA2
  1515                        
  1516                        LAB_16F7				; do undefined statement error
  1517 FF:2E41: A2 0E        	LDX	#$0E			; error code $0E ("Undefined statement" error)
  1518 FF:2E43: 4C C1 28     	JMP	LAB_XERR		; do error #X, then warm start
  1519                        
  1520                        ; perform RETURN
  1521                        
  1522                        LAB_RETURN
  1523 FF:2E46: D0 99        	BNE	LAB_16E5		; exit if following token (to allow syntax error)
  1524                        
  1525                        LAB_16E8
  1526 FF:2E48: 68           	PLA				; dump calling routine return address
  1527 FF:2E49: 68           	PLA				; dump calling routine return address
  1528 FF:2E4A: 68           	PLA				; pull token
  1529 FF:2E4B: C9 8F        	CMP	#TK_GOSUB		; compare with GOSUB token
  1530 FF:2E4D: D0 EF        	BNE	LAB_16F4		; branch if no matching GOSUB
  1531                        
  1532                        LAB_16FF
  1533 FF:2E4F: 68           	PLA				; pull current line low byte
  1534 FF:2E50: 85 87        	STA	<Clinel		; save current line low byte
  1535 FF:2E52: 68           	PLA				; pull current line high byte
  1536 FF:2E53: 85 88        	STA	<Clineh		; save current line high byte
  1537 FF:2E55: 68           	PLA				; pull BASIC execute pointer low byte
  1538 FF:2E56: 85 C3        	STA	<Bpntrl		; save BASIC execute pointer low byte
  1539 FF:2E58: 68           	PLA				; pull BASIC execute pointer high byte
  1540 FF:2E59: 85 C4        	STA	<Bpntrh		; save BASIC execute pointer high byte
  1541                        
  1542                        					; now do the DATA statement as we could be returning into
  1543                        					; the middle of an ON <var> GOSUB n,m,p,q line
  1544                        					; (the return address used by the DATA statement is the one
  1545                        					; pushed before the GOSUB was executed!)
  1546                        
  1547                        ; perform DATA
  1548                        
  1549                        LAB_DATA
  1550 FF:2E5B: 20 6C 2E     	JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
  1551                        
  1552                        					; set BASIC execute pointer
  1553                        LAB_170F
  1554 FF:2E5E: 98           	TYA				; copy index to A
  1555 FF:2E5F: 18           	CLC				; clear carry for add
  1556 FF:2E60: 65 C3        	ADC	<Bpntrl		; add BASIC execute pointer low byte
  1557 FF:2E62: 85 C3        	STA	<Bpntrl		; save BASIC execute pointer low byte
  1558 FF:2E64: 90 02        	BCC	LAB_1719		; skip next if no carry
  1559                        
  1560 FF:2E66: E6 C4        	INC	<Bpntrh		; else increment BASIC execute pointer high byte
  1561                        LAB_1719
  1562 FF:2E68: 60           	RTS
  1563                        
  1564                        LAB_16FC
  1565 FF:2E69: 4C 28 35     	JMP	LAB_SNER		; do syntax error then warm start
  1566                        
  1567                        ; scan for next BASIC statement ([:] or [EOL])
  1568                        ; returns Y as index to [:] or [EOL]
  Sun Nov 21 2021 15:13                                                                                                Page 109


  1569                        
  1570                        LAB_SNBS
  1571 FF:2E6C: A2 3A        	LDX	#':'			; set look for character = ":"
  1572 FF:2E6E: 2C           	.byte	$2C			; makes next line BIT $00A2
  1573                        
  1574                        ; scan for next BASIC line
  1575                        ; returns Y as index to [EOL]
  1576                        
  1577                        LAB_SNBL
  1578 FF:2E6F: A2 00        	LDX	#$00			; set alt search character = [EOL]
  1579 FF:2E71: A0 00        	LDY	#$00			; set search character = [EOL]
  1580 FF:2E73: 84 5C        	STY	<Asrch			; store search character
  1581                        LAB_1725
  1582 FF:2E75: 8A           	TXA				; get alt search character
  1583 FF:2E76: 45 5C        	EOR	<Asrch			; toggle search character, effectively swap with $00
  1584 FF:2E78: 85 5C        	STA	<Asrch			; save swapped search character
  1585                        LAB_172D
  1586 FF:2E7A: B1 C3        	LDA (<Bpntrl),Y		; get next byte
  1587 FF:2E7C: F0 EA        	BEQ	LAB_1719		; exit if null [EOL]
  1588                        
  1589 FF:2E7E: C5 5C        	CMP	<Asrch			; compare with search character
  1590 FF:2E80: F0 E6        	BEQ	LAB_1719		; exit if found
  1591                        
  1592 FF:2E82: C8           	INY				; increment index
  1593 FF:2E83: C9 22        	CMP	#$22			; compare current character with open quote
  1594 FF:2E85: D0 F3        	BNE	LAB_172D		; if not open quote go get next character
  1595                        
  1596 FF:2E87: F0 EC        	BEQ	LAB_1725		; if found go swap search character for alt search character
  1597                        
  1598                        ; perform IF
  1599                        
  1600                        LAB_IF
  1601 FF:2E89: 20 02 34     	JSR	LAB_EVEX		; evaluate the expression
  1602 FF:2E8C: 22 C2 00 00  	JSL	LAB_GBYT		; scan memory
  1603 FF:2E90: C9 C5        	CMP	#TK_THEN		; compare with THEN token
  1604 FF:2E92: F0 12        	BEQ	LAB_174B		; if it was THEN go do IF
  1605                        
  1606                        					; wasn't IF .. THEN so must be IF .. GOTO
  1607 FF:2E94: C9 8B        	CMP	#TK_GOTO		; compare with GOTO token
  1608 FF:2E96: D0 D1        	BNE	LAB_16FC		; if it wasn't GOTO go do syntax error
  1609                        
  1610 FF:2E98: A6 C3        	LDX	<Bpntrl		; save the basic pointer low byte
  1611 FF:2E9A: A4 C4        	LDY	<Bpntrh		; save the basic pointer high byte
  1612 FF:2E9C: 22 BC 00 00  	JSL	LAB_IGBY		; increment and scan memory
  1613 FF:2EA0: B0 C7        	BCS	LAB_16FC		; if not numeric go do syntax error
  1614                        
  1615 FF:2EA2: 86 C3        	STX	<Bpntrl		; restore the basic pointer low byte
  1616 FF:2EA4: 84 C4        	STY	<Bpntrh		; restore the basic pointer high byte
  1617                        LAB_174B
  1618 FF:2EA6: A5 AC        	LDA	<FAC1_e		; get FAC1 exponent
  1619 FF:2EA8: F0 1F        	BEQ	LAB_174E		; if the result was zero go look for an ELSE
  1620                        
  1621 FF:2EAA: 22 BC 00 00  	JSL	LAB_IGBY		; else increment and scan memory
  1622 FF:2EAE: B0 03        	BCS	LAB_174D		; if not numeric go do var or keyword
  1623                        
  1624                        LAB_174C
  1625 FF:2EB0: 4C B5 2D     	JMP	LAB_GOTO		; else was numeric so do GOTO n
  Sun Nov 21 2021 15:13                                                                                                Page 110


  1626                        
  1627                        					; is var or keyword
  1628                        LAB_174D
  1629 FF:2EB3: C9 90        	CMP	#TK_RETURN		; compare the byte with the token for RETURN
  1630 FF:2EB5: D0 03        	BNE	LAB_174G		; if it wasn't RETURN go interpret BASIC code from (<Bpntrl)
  1631                        					; and return to this code to process any following code
  1632                        
  1633 FF:2EB7: 4C B9 2C     	JMP	LAB_1602		; else it was RETURN so interpret BASIC code from (<Bpntrl)
  1634                        					; but don't return here
  1635                        
  1636                        LAB_174G
  1637 FF:2EBA: 20 B7 2C     	JSR	LAB_15FF		; interpret BASIC code from (<Bpntrl)
  1638                        
  1639                        ; the IF was executed and there may be a following ELSE so the code needs to return
  1640                        ; here to check and ignore the ELSE if present
  1641                        
  1642 FF:2EBD: A0 00        	LDY	#$00			; clear the index
  1643 FF:2EBF: B1 C3        	LDA (<Bpntrl),Y		; get the next BASIC byte
  1644 FF:2EC1: C9 C1        	CMP	#TK_ELSE		; compare it with the token for ELSE
  1645 FF:2EC3: D0 03        	BNE LAB_DATA_A
  1646 FF:2EC5: 4C 5B 2E     	JMP	LAB_DATA		; if ELSE ignore the following statement
  1647                        
  1648                        ; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
  1649                        ; following ELSE will, correctly, cause a syntax error
  1650                        LAB_DATA_A
  1651 FF:2EC8: 60           	RTS				; else return to the interpreter inner loop
  1652                        
  1653                        ; perform ELSE after IF
  1654                        
  1655                        LAB_174E
  1656 FF:2EC9: A0 00        	LDY	#$00			; clear the BASIC byte index
  1657 FF:2ECB: A2 01        	LDX	#$01			; clear the nesting depth
  1658                        LAB_1750
  1659 FF:2ECD: C8           	INY				; increment the BASIC byte index
  1660 FF:2ECE: B1 C3        	LDA (<Bpntrl),Y		; get the next BASIC byte
  1661 FF:2ED0: F0 0F        	BEQ	LAB_1753		; if EOL go add the pointer and return
  1662                        
  1663 FF:2ED2: C9 8D        	CMP	#TK_IF		; compare the byte with the token for IF
  1664 FF:2ED4: D0 03        	BNE	LAB_1752		; if not IF token skip the depth increment
  1665                        
  1666 FF:2ED6: E8           	INX				; else increment the nesting depth ..
  1667 FF:2ED7: D0 F4        	BNE	LAB_1750		; .. and continue looking
  1668                        
  1669                        LAB_1752
  1670 FF:2ED9: C9 C1        	CMP	#TK_ELSE		; compare the byte with the token for ELSE
  1671 FF:2EDB: D0 F0        	BNE	LAB_1750		; if not ELSE token continue looking
  1672                        
  1673 FF:2EDD: CA           	DEX				; was ELSE so decrement the nesting depth
  1674 FF:2EDE: D0 ED        	BNE	LAB_1750		; loop if still nested
  1675                        
  1676 FF:2EE0: C8           	INY				; increment the BASIC byte index past the ELSE
  1677                        
  1678                        ; found the matching ELSE, now do <{n|statement}>
  1679                        
  1680                        LAB_1753
  1681 FF:2EE1: 98           	TYA				; else copy line index to A
  1682 FF:2EE2: 18           	CLC				; clear carry for add
  Sun Nov 21 2021 15:13                                                                                                Page 111


  1683 FF:2EE3: 65 C3        	ADC	<Bpntrl		; add the BASIC execute pointer low byte
  1684 FF:2EE5: 85 C3        	STA	<Bpntrl		; save the BASIC execute pointer low byte
  1685 FF:2EE7: 90 02        	BCC	LAB_1754		; branch if no overflow to high byte
  1686                        
  1687 FF:2EE9: E6 C4        	INC	<Bpntrh		; else increment the BASIC execute pointer high byte
  1688                        LAB_1754
  1689 FF:2EEB: 22 C2 00 00  	JSL	LAB_GBYT		; scan memory
  1690 FF:2EEF: 90 BF        	BCC	LAB_174C		; if numeric do GOTO n
  1691                        					; the code will return to the interpreter loop at the
  1692                        					; tail end of the GOTO <n>
  1693                        
  1694 FF:2EF1: 4C B7 2C     	JMP	LAB_15FF		; interpret BASIC code from (<Bpntrl)
  1695                        					; the code will return to the interpreter loop at the
  1696                        					; tail end of the <statement>
  1697                        
  1698                        ; perform REM, skip (rest of) line
  1699                        
  1700                        LAB_REM
  1701 FF:2EF4: 20 6F 2E     	JSR	LAB_SNBL		; scan for next BASIC line
  1702 FF:2EF7: 4C 5E 2E     	JMP	LAB_170F		; go set BASIC execute pointer and return, branch always
  1703                        
  1704                        LAB_16FD
  1705 FF:2EFA: 4C 28 35     	JMP	LAB_SNER		; do syntax error then warm start
  1706                        
  1707                        ; perform ON
  1708                        
  1709                        LAB_ON
  1710                        LAB_NONM
  1711 FF:2EFD: 20 9E 40     	JSR	LAB_GTBY		; get byte parameter
  1712 FF:2F00: 48           	PHA				; push GOTO/GOSUB token
  1713 FF:2F01: C9 8F        	CMP	#TK_GOSUB		; compare with GOSUB token
  1714 FF:2F03: F0 04        	BEQ	LAB_176B		; branch if GOSUB
  1715                        
  1716 FF:2F05: C9 8B        	CMP	#TK_GOTO		; compare with GOTO token
  1717                        LAB_1767
  1718 FF:2F07: D0 F1        	BNE	LAB_16FD		; if not GOTO do syntax error then warm start
  1719                        
  1720                        
  1721                        ; next character was GOTO or GOSUB
  1722                        
  1723                        LAB_176B
  1724 FF:2F09: C6 AF        	DEC	<FAC1_3		; decrement index (byte value)
  1725 FF:2F0B: D0 04        	BNE	LAB_1773		; branch if not zero
  1726                        
  1727 FF:2F0D: 68           	PLA				; pull GOTO/GOSUB token
  1728 FF:2F0E: 4C B9 2C     	JMP	LAB_1602		; go execute it
  1729                        
  1730                        LAB_1773
  1731 FF:2F11: 22 BC 00 00  	JSL	LAB_IGBY		; increment and scan memory
  1732 FF:2F15: 20 1E 2F     	JSR	LAB_GFPN		; get fixed-point number into temp integer (skip this n)
  1733                        					; (we could LDX #',' and JSR LAB_SNBL+2, then we
  1734                        					; just BNE LAB_176B for the loop. should be quicker ..
  1735                        					; no we can't, what if we meet a colon or [EOL]?)
  1736 FF:2F18: C9 2C        	CMP	#$2C			; compare next character with ","
  1737 FF:2F1A: F0 ED        	BEQ	LAB_176B		; loop if ","
  1738                        
  1739                        LAB_177E
  Sun Nov 21 2021 15:13                                                                                                Page 112


  1740 FF:2F1C: 68           	PLA				; else pull keyword token (run out of options)
  1741                        					; also dump +/-1 pointer low byte and exit
  1742                        LAB_177F
  1743 FF:2F1D: 60           	RTS
  1744                        
  1745                        ; takes n * 106 + 11 cycles where n is the number of digits
  1746                        
  1747                        ; get fixed-point number into temp integer
  1748                        
  1749                        LAB_GFPN
  1750 FF:2F1E: A2 00        	LDX	#$00			; clear reg
  1751 FF:2F20: 86 11        	STX	<Itempl		; clear temporary integer low byte
  1752                        LAB_1785
  1753 FF:2F22: 86 12        	STX	<Itemph		; save temporary integer high byte
  1754 FF:2F24: B0 F7        	BCS	LAB_177F		; return if carry set, end of scan, character was
  1755                        					; not 0-9
  1756                        
  1757 FF:2F26: E0 19        	CPX	#$19			; compare high byte with $19
  1758 FF:2F28: A8           	TAY				; ensure Zb = 0 if the branch is taken
  1759 FF:2F29: B0 DC        	BCS	LAB_1767		; branch if >=, makes max line # 63999 because next
  1760                        					; bit does *$0A, = 64000, compare at target will fail
  1761                        					; and do syntax error
  1762                        
  1763 FF:2F2B: E9 2F        	SBC	#'0'-1		; subtract "0", $2F + carry, from byte
  1764 FF:2F2D: A8           	TAY				; copy binary digit
  1765 FF:2F2E: A5 11        	LDA	<Itempl		; get temporary integer low byte
  1766 FF:2F30: 0A           	ASL	A			; *2 low byte
  1767 FF:2F31: 26 12        	ROL	<Itemph		; *2 high byte
  1768 FF:2F33: 0A           	ASL	A		; *2 low byte
  1769 FF:2F34: 26 12        	ROL	<Itemph		; *2 high byte, *4
  1770 FF:2F36: 65 11        	ADC	<Itempl		; + low byte, *5
  1771 FF:2F38: 85 11        	STA	<Itempl		; save it
  1772 FF:2F3A: 8A           	TXA				; get high byte copy to A
  1773 FF:2F3B: 65 12        	ADC	<Itemph		; + high byte, *5
  1774 FF:2F3D: 06 11        	ASL	<Itempl		; *2 low byte, *10d
  1775 FF:2F3F: 2A           	ROL	A			; *2 high byte, *10d
  1776 FF:2F40: AA           	TAX				; copy high byte back to X
  1777 FF:2F41: 98           	TYA				; get binary digit back
  1778 FF:2F42: 65 11        	ADC	<Itempl		; add number low byte
  1779 FF:2F44: 85 11        	STA	<Itempl		; save number low byte
  1780 FF:2F46: 90 01        	BCC	LAB_17B3		; if no overflow to high byte get next character
  1781                        
  1782 FF:2F48: E8           	INX				; else increment high byte
  1783                        LAB_17B3
  1784 FF:2F49: 22 BC 00 00  	JSL	LAB_IGBY		; increment and scan memory
  1785 FF:2F4D: 4C 22 2F     	JMP	LAB_1785		; loop for next character
  1786                        
  1787                        ; perform DEC
  1788                        
  1789                        LAB_DEC
  1790 FF:2F50: A9 9E        	LDA	#<LAB_2AFD		; set -1 pointer low byte
  1791 FF:2F52: 2C           	.byte	$2C			; BIT abs to skip the LDA below
  1792                        
  1793                        ; perform INC
  1794                        
  1795                        LAB_INC
  1796 FF:2F53: A9 9A        	LDA	#<LAB_259C		; set 1 pointer low byte
  Sun Nov 21 2021 15:13                                                                                                Page 113


  1797                        LAB_17B5
  1798 FF:2F55: 48           	PHA				; save +/-1 pointer low byte
  1799                        LAB_17B7
  1800 FF:2F56: 20 FF 36     	JSR	LAB_GVAR		; get var address
  1801 FF:2F59: A6 5F        	LDX	<Dtypef		; get data type flag, $FF=string, $00=numeric
  1802 FF:2F5B: 30 20        	BMI	IncrErr		; exit if string
  1803                        
  1804 FF:2F5D: 85 97        	STA	<Lvarpl		; save var address low byte
  1805 FF:2F5F: 84 98        	STY	<Lvarph		; save var address high byte
  1806 FF:2F61: 20 7C 45     	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
  1807 FF:2F64: 68           	PLA				; get +/-1 pointer low byte
  1808 FF:2F65: 48           	PHA				; save +/-1 pointer low byte
  1809 FF:2F66: A0 18        	LDY	#>LAB_259C		; set +/-1 pointer high byte (both the same)
  1810 FF:2F68: 20 67 42     	JSR	LAB_246C		; add (AY) to FAC1
  1811 FF:2F6B: 20 F2 45     	JSR	LAB_PFAC		; pack FAC1 into variable (<Lvarpl)
  1812                        
  1813 FF:2F6E: 22 C2 00 00  	JSL	LAB_GBYT		; scan memory
  1814 FF:2F72: C9 2C        	CMP	#','			; compare with ","
  1815 FF:2F74: D0 A6        	BNE	LAB_177E		; exit if not "," (either end or error)
  1816                        
  1817                        					; was "," so another INCR variable to do
  1818 FF:2F76: 22 BC 00 00  	JSL	LAB_IGBY		; increment and scan memory
  1819 FF:2F7A: 4C 56 2F     	JMP	LAB_17B7		; go do next var
  1820                        
  1821                        IncrErr
  1822 FF:2F7D: 4C FD 33     	JMP	LAB_1ABC		; do "Type mismatch" error then warm start
  1823                        
  1824                        ; perform LET
  1825                        
  1826                        LAB_LET
  1827 FF:2F80: 20 FF 36     	JSR	LAB_GVAR		; get var address
  1828 FF:2F83: 85 97        	STA	<Lvarpl		; save var address low byte
  1829 FF:2F85: 84 98        	STY	<Lvarph		; save var address high byte
  1830 FF:2F87: A9 D6        	LDA	#TK_EQUAL		; get = token
  1831 FF:2F89: 20 15 35     	JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
  1832 FF:2F8C: A5 5F        	LDA	<Dtypef		; get data type flag, $FF=string, $00=numeric
  1833 FF:2F8E: 48           	PHA				; push data type flag
  1834 FF:2F8F: 20 02 34     	JSR	LAB_EVEX		; evaluate expression
  1835 FF:2F92: 68           	PLA				; pop data type flag
  1836 FF:2F93: 2A           	ROL	A			; set carry if type = string
  1837 FF:2F94: 20 F4 33     	JSR	LAB_CKTM		; type match check, set C for string
  1838 FF:2F97: D0 03        	BNE	LAB_17D5		; branch if string
  1839                        
  1840 FF:2F99: 4C F2 45     	JMP	LAB_PFAC		; pack FAC1 into variable (<Lvarpl) and return
  1841                        
  1842                        ; string LET
  1843                        
  1844                        LAB_17D5
  1845 FF:2F9C: A0 02        	LDY	#$02			; set index to pointer high byte
  1846                        	LDAINDIRECTY des_pl		; get string pointer high byte
+ 1846 FF:2F9E: 8B               PHB
+ 1846 FF:2F9F: DA           	PHX
+ 1846 FF:2FA0: A2 01            LDX #$01
+ 1846 FF:2FA2: B5 AE            LDA <des_pl,X
+ 1846 FF:2FA4: C9 00            CMP #$00
+ 1846 FF:2FA6: D0 04            BNE *+6
+ 1846 FF:2FA8: A2 00        	LDX #00
  Sun Nov 21 2021 15:13                                                                                                Page 114


+ 1846 FF:2FAA: DA           	PHX
+ 1846 FF:2FAB: AB           	PLB
+ 1846 FF:2FAC: FA               PLX
+ 1846 FF:2FAD: B1 AE        	LDA	(<des_pl),Y		;
+ 1846 FF:2FAF: 85 04            STA <TMPFLG
+ 1846 FF:2FB1: AB               PLB
+ 1846 FF:2FB2: A5 04            LDA <TMPFLG
  1847 FF:2FB4: C5 82        	CMP	<Sstorh		; compare bottom of string space high byte
  1848 FF:2FB6: 90 2B        	BCC	LAB_17F4		; if less assign value and exit (was in program memory)
  1849 FF:2FB8: D0 1B        	BNE	LAB_17E6		; branch if >
  1850                        					; else was equal so compare low bytes
  1851 FF:2FBA: 88           	DEY				; decrement index
  1852                        	LDAINDIRECTY des_pl		; get pointer low byte
+ 1852 FF:2FBB: 8B               PHB
+ 1852 FF:2FBC: DA           	PHX
+ 1852 FF:2FBD: A2 01            LDX #$01
+ 1852 FF:2FBF: B5 AE            LDA <des_pl,X
+ 1852 FF:2FC1: C9 00            CMP #$00
+ 1852 FF:2FC3: D0 04            BNE *+6
+ 1852 FF:2FC5: A2 00        	LDX #00
+ 1852 FF:2FC7: DA           	PHX
+ 1852 FF:2FC8: AB           	PLB
+ 1852 FF:2FC9: FA               PLX
+ 1852 FF:2FCA: B1 AE        	LDA	(<des_pl),Y		;
+ 1852 FF:2FCC: 85 04            STA <TMPFLG
+ 1852 FF:2FCE: AB               PLB
+ 1852 FF:2FCF: A5 04            LDA <TMPFLG
  1853 FF:2FD1: C5 81        	CMP	<Sstorl		; compare bottom of string space low byte
  1854 FF:2FD3: 90 0E        	BCC	LAB_17F4		; if less assign value and exit (was in program memory)
  1855                        
  1856                        					; pointer was >= to bottom of string space pointer
  1857                        LAB_17E6
  1858 FF:2FD5: A4 AF        	LDY	<des_ph		; get descriptor pointer high byte
  1859 FF:2FD7: C4 7C        	CPY	<Svarh			; compare start of vars high byte
  1860 FF:2FD9: 90 08        	BCC	LAB_17F4		; branch if less (descriptor is on stack)
  1861                        
  1862 FF:2FDB: D0 0D        	BNE	LAB_17FB		; branch if greater (descriptor is not on stack)
  1863                        
  1864                        					; else high bytes were equal so ..
  1865 FF:2FDD: A5 AE        	LDA	<des_pl		; get descriptor pointer low byte
  1866 FF:2FDF: C5 7B        	CMP	<Svarl			; compare start of vars low byte
  1867 FF:2FE1: B0 07        	BCS	LAB_17FB		; branch if >= (descriptor is not on stack)
  1868                        
  1869                        LAB_17F4
  1870 FF:2FE3: A5 AE        	LDA	<des_pl		; get descriptor pointer low byte
  1871 FF:2FE5: A4 AF        	LDY	<des_ph		; get descriptor pointer high byte
  1872 FF:2FE7: 4C 14 30     	JMP	LAB_1811		; clean stack, copy descriptor to variable and return
  1873                        
  1874                        					; make space and copy string
  1875                        LAB_17FB
  1876                        
  1877 FF:2FEA: A0 00        	LDY	#$00			; index to length
  1878                        	LDAINDIRECTY des_pl		; get string length
+ 1878 FF:2FEC: 8B               PHB
+ 1878 FF:2FED: DA           	PHX
+ 1878 FF:2FEE: A2 01            LDX #$01
+ 1878 FF:2FF0: B5 AE            LDA <des_pl,X
  Sun Nov 21 2021 15:13                                                                                                Page 115


+ 1878 FF:2FF2: C9 00            CMP #$00
+ 1878 FF:2FF4: D0 04            BNE *+6
+ 1878 FF:2FF6: A2 00        	LDX #00
+ 1878 FF:2FF8: DA           	PHX
+ 1878 FF:2FF9: AB           	PLB
+ 1878 FF:2FFA: FA               PLX
+ 1878 FF:2FFB: B1 AE        	LDA	(<des_pl),Y		;
+ 1878 FF:2FFD: 85 04            STA <TMPFLG
+ 1878 FF:2FFF: AB               PLB
+ 1878 FF:3000: A5 04            LDA <TMPFLG
  1879 FF:3002: 20 26 3B     	JSR	LAB_209C		; copy string
  1880 FF:3005: A5 9E        	LDA	<des_2l		; get descriptor pointer low byte
  1881 FF:3007: A4 9F        	LDY	<des_2h		; get descriptor pointer high byte
  1882 FF:3009: 85 B8        	STA	<ssptr_l		; save descriptor pointer low byte
  1883 FF:300B: 84 B9        	STY	<ssptr_h		; save descriptor pointer high byte
  1884 FF:300D: 20 84 3D     	JSR	LAB_228A		; copy string from descriptor (<sdescr) to (<Sutill)
  1885 FF:3010: A9 AC        	LDA	#<FAC1_e		; set descriptor pointer low byte
  1886 FF:3012: A0 00        	LDY	#>FAC1_e		; get descriptor pointer high byte
  1887                        
  1888                        					; clean stack and assign value to string variable
  1889                        LAB_1811
  1890 FF:3014: 85 9E        	STA	<des_2l		; save descriptor_2 pointer low byte
  1891 FF:3016: 84 9F        	STY	<des_2h		; save descriptor_2 pointer high byte
  1892 FF:3018: 20 86 3E     	JSR	LAB_22EB		; clean descriptor stack, YA = pointer
  1893 FF:301B: A0 00        	LDY	#$00			; index to length
  1894                        	LDAINDIRECTY des_2l 	; get string length
+ 1894 FF:301D: 8B               PHB
+ 1894 FF:301E: DA           	PHX
+ 1894 FF:301F: A2 01            LDX #$01
+ 1894 FF:3021: B5 9E            LDA <des_2l,X
+ 1894 FF:3023: C9 00            CMP #$00
+ 1894 FF:3025: D0 04            BNE *+6
+ 1894 FF:3027: A2 00        	LDX #00
+ 1894 FF:3029: DA           	PHX
+ 1894 FF:302A: AB           	PLB
+ 1894 FF:302B: FA               PLX
+ 1894 FF:302C: B1 9E        	LDA	(<des_2l),Y		;
+ 1894 FF:302E: 85 04            STA <TMPFLG
+ 1894 FF:3030: AB               PLB
+ 1894 FF:3031: A5 04            LDA <TMPFLG
  1895                        	STAINDIRECTY Lvarpl		; copy to let string variable
+ 1895 FF:3033: 8B               PHB
+ 1895 FF:3034: DA           	PHX
+ 1895 FF:3035: 48               PHA
+ 1895 FF:3036: A2 01            LDX #$01
+ 1895 FF:3038: B5 97            LDA <Lvarpl,X
+ 1895 FF:303A: C9 00            CMP #$00
+ 1895 FF:303C: D0 04            BNE *+6
+ 1895 FF:303E: A2 00        	LDX #00
+ 1895 FF:3040: DA           	PHX
+ 1895 FF:3041: AB           	PLB
+ 1895 FF:3042: 68               PLA
+ 1895 FF:3043: FA               PLX
+ 1895 FF:3044: 91 97        	STA	(<Lvarpl),Y		;
+ 1895 FF:3046: AB           	PLB
+ 1895 FF:3047: 85 04            STA <TMPFLG
  1896 FF:3049: C8           	INY				; index to string pointer low byte
  Sun Nov 21 2021 15:13                                                                                                Page 116


  1897                        	LDAINDIRECTY des_2l	; get string pointer low byte
+ 1897 FF:304A: 8B               PHB
+ 1897 FF:304B: DA           	PHX
+ 1897 FF:304C: A2 01            LDX #$01
+ 1897 FF:304E: B5 9E            LDA <des_2l,X
+ 1897 FF:3050: C9 00            CMP #$00
+ 1897 FF:3052: D0 04            BNE *+6
+ 1897 FF:3054: A2 00        	LDX #00
+ 1897 FF:3056: DA           	PHX
+ 1897 FF:3057: AB           	PLB
+ 1897 FF:3058: FA               PLX
+ 1897 FF:3059: B1 9E        	LDA	(<des_2l),Y		;
+ 1897 FF:305B: 85 04            STA <TMPFLG
+ 1897 FF:305D: AB               PLB
+ 1897 FF:305E: A5 04            LDA <TMPFLG
  1898                        	STAINDIRECTY Lvarpl		; copy to let string variable
+ 1898 FF:3060: 8B               PHB
+ 1898 FF:3061: DA           	PHX
+ 1898 FF:3062: 48               PHA
+ 1898 FF:3063: A2 01            LDX #$01
+ 1898 FF:3065: B5 97            LDA <Lvarpl,X
+ 1898 FF:3067: C9 00            CMP #$00
+ 1898 FF:3069: D0 04            BNE *+6
+ 1898 FF:306B: A2 00        	LDX #00
+ 1898 FF:306D: DA           	PHX
+ 1898 FF:306E: AB           	PLB
+ 1898 FF:306F: 68               PLA
+ 1898 FF:3070: FA               PLX
+ 1898 FF:3071: 91 97        	STA	(<Lvarpl),Y		;
+ 1898 FF:3073: AB           	PLB
+ 1898 FF:3074: 85 04            STA <TMPFLG
  1899 FF:3076: C8           	INY				; index to string pointer high byte
  1900                        	LDAINDIRECTY des_2l		; get string pointer high byte
+ 1900 FF:3077: 8B               PHB
+ 1900 FF:3078: DA           	PHX
+ 1900 FF:3079: A2 01            LDX #$01
+ 1900 FF:307B: B5 9E            LDA <des_2l,X
+ 1900 FF:307D: C9 00            CMP #$00
+ 1900 FF:307F: D0 04            BNE *+6
+ 1900 FF:3081: A2 00        	LDX #00
+ 1900 FF:3083: DA           	PHX
+ 1900 FF:3084: AB           	PLB
+ 1900 FF:3085: FA               PLX
+ 1900 FF:3086: B1 9E        	LDA	(<des_2l),Y		;
+ 1900 FF:3088: 85 04            STA <TMPFLG
+ 1900 FF:308A: AB               PLB
+ 1900 FF:308B: A5 04            LDA <TMPFLG
  1901                        	STAINDIRECTY Lvarpl		; copy to let string variable
+ 1901 FF:308D: 8B               PHB
+ 1901 FF:308E: DA           	PHX
+ 1901 FF:308F: 48               PHA
+ 1901 FF:3090: A2 01            LDX #$01
+ 1901 FF:3092: B5 97            LDA <Lvarpl,X
+ 1901 FF:3094: C9 00            CMP #$00
+ 1901 FF:3096: D0 04            BNE *+6
+ 1901 FF:3098: A2 00        	LDX #00
+ 1901 FF:309A: DA           	PHX
  Sun Nov 21 2021 15:13                                                                                                Page 117


+ 1901 FF:309B: AB           	PLB
+ 1901 FF:309C: 68               PLA
+ 1901 FF:309D: FA               PLX
+ 1901 FF:309E: 91 97        	STA	(<Lvarpl),Y		;
+ 1901 FF:30A0: AB           	PLB
+ 1901 FF:30A1: 85 04            STA <TMPFLG
  1902 FF:30A3: 60           	RTS
  1903                        
  1904                        ; perform GET
  1905                        
  1906                        LAB_GET
  1907 FF:30A4: 20 FF 36     	JSR	LAB_GVAR		; get var address
  1908 FF:30A7: 85 97        	STA	<Lvarpl		; save var address low byte
  1909 FF:30A9: 84 98        	STY	<Lvarph		; save var address high byte
  1910 FF:30AB: 20 9D 4D     	JSR	INGET			; get input byte
  1911 FF:30AE: A6 5F        	LDX	<Dtypef		; get data type flag, $FF=string, $00=numeric
  1912 FF:30B0: 30 07        	BMI	LAB_GETS		; go get string character
  1913                        
  1914                        					; was numeric get
  1915 FF:30B2: A8           	TAY				; copy character to Y
  1916 FF:30B3: 20 CA 39     	JSR	LAB_1FD0		; convert Y to byte in FAC1
  1917 FF:30B6: 4C F2 45     	JMP	LAB_PFAC		; pack FAC1 into variable (<Lvarpl) and return
  1918                        
  1919                        LAB_GETS
  1920 FF:30B9: 48           	PHA				; save character
  1921 FF:30BA: A9 01        	LDA	#$01			; string is single byte
  1922 FF:30BC: B0 01        	BCS	LAB_IsByte		; branch if byte received
  1923                        
  1924 FF:30BE: 68           	PLA				; string is null
  1925                        LAB_IsByte
  1926 FF:30BF: 20 2E 3B     	JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
  1927                        					; X=$AD=<Sutill=ptr low byte, Y=$AE=<Sutilh=ptr high byte
  1928 FF:30C2: F0 19        	BEQ	LAB_NoSt		; skip store if null string
  1929                        
  1930 FF:30C4: 68           	PLA				; get character back
  1931 FF:30C5: A0 00        	LDY	#$00			; clear index
  1932                        	STAINDIRECTY str_pl		; save byte in string (byte IS string!)
+ 1932 FF:30C7: 8B               PHB
+ 1932 FF:30C8: DA           	PHX
+ 1932 FF:30C9: 48               PHA
+ 1932 FF:30CA: A2 01            LDX #$01
+ 1932 FF:30CC: B5 AD            LDA <str_pl,X
+ 1932 FF:30CE: C9 00            CMP #$00
+ 1932 FF:30D0: D0 04            BNE *+6
+ 1932 FF:30D2: A2 00        	LDX #00
+ 1932 FF:30D4: DA           	PHX
+ 1932 FF:30D5: AB           	PLB
+ 1932 FF:30D6: 68               PLA
+ 1932 FF:30D7: FA               PLX
+ 1932 FF:30D8: 91 AD        	STA	(<str_pl),Y		;
+ 1932 FF:30DA: AB           	PLB
+ 1932 FF:30DB: 85 04            STA <TMPFLG
  1933                        LAB_NoSt
  1934 FF:30DD: 20 91 3B     	JSR	LAB_RTST		; check for space on descriptor stack then put address
  1935                        					; and length on descriptor stack and update stack pointers
  1936                        
  1937 FF:30E0: 4C 9C 2F     	JMP	LAB_17D5		; do string LET and return
  Sun Nov 21 2021 15:13                                                                                                Page 118


  1938                        
  1939                        ; perform PRINT
  1940                        
  1941                        LAB_1829
  1942 FF:30E3: 20 88 31     	JSR	LAB_18C6		; print string from <Sutill/<Sutilh
  1943                        LAB_182C
  1944 FF:30E6: 22 C2 00 00  	JSL	LAB_GBYT		; scan memory
  1945                        
  1946                        ; PRINT
  1947                        
  1948                        LAB_PRINT
  1949 FF:30EA: F0 51        	BEQ	LAB_CRLF		; if nothing following just print CR/LF
  1950                        
  1951                        LAB_1831
  1952 FF:30EC: C9 C0        	CMP	#TK_TAB		; compare with TAB( token
  1953 FF:30EE: F0 6C        	BEQ	LAB_18A2		; go do TAB/SPC
  1954                        
  1955 FF:30F0: C9 C4        	CMP	#TK_SPC		; compare with SPC( token
  1956 FF:30F2: F0 68        	BEQ	LAB_18A2		; go do TAB/SPC
  1957                        
  1958 FF:30F4: C9 2C        	CMP	#','			; compare with ","
  1959 FF:30F6: F0 4E        	BEQ	LAB_188B		; go do move to next TAB mark
  1960                        
  1961 FF:30F8: C9 3B        	CMP	#$3B			; compare with ";"
  1962 FF:30FA: F0 7F        	BEQ	LAB_18BD		; if ";" continue with PRINT processing
  1963                        
  1964 FF:30FC: 20 02 34     	JSR	LAB_EVEX		; evaluate expression
  1965 FF:30FF: 24 5F        	BIT	<Dtypef		; test data type flag, $FF=string, $00=numeric
  1966 FF:3101: 30 E0        	BMI	LAB_1829		; branch if string
  1967                        
  1968 FF:3103: 20 B6 48     	JSR	LAB_296E		; convert FAC1 to string
  1969 FF:3106: 20 38 3B     	JSR	LAB_20AE		; print " terminated string to <Sutill/<Sutilh
  1970 FF:3109: A0 00        	LDY	#$00			; clear index
  1971                        
  1972                        ; don't check fit if terminal width byte is zero
  1973                        
  1974 FF:310B: A5 0F        	LDA	<TWidth			; get terminal width byte
  1975 FF:310D: F0 20        	BEQ	LAB_185E		; skip check if zero
  1976                        
  1977                        	FETCHINDIRECTY des_pl
+ 1977 FF:310F: 8B               PHB
+ 1977 FF:3110: 48           	PHA
+ 1977 FF:3111: DA               PHX
+ 1977 FF:3112: A2 01            LDX #$01
+ 1977 FF:3114: B5 AE            LDA <des_pl,X
+ 1977 FF:3116: C9 00            CMP #$00
+ 1977 FF:3118: D0 04            BNE *+6
+ 1977 FF:311A: A2 00        	LDX #00
+ 1977 FF:311C: DA           	PHX
+ 1977 FF:311D: AB           	PLB
+ 1977 FF:311E: FA               PLX
+ 1977 FF:311F: B1 AE            LDA	(<des_pl),Y		;
+ 1977 FF:3121: 85 04            STA <TMPFLG
+ 1977 FF:3123: 68               PLA
+ 1977 FF:3124: AB               PLB
  1978 FF:3125: 38           	SEC					; set carry for subtract
  1979 FF:3126: E5 0E        	SBC	<TPos			; subtract terminal position
  Sun Nov 21 2021 15:13                                                                                                Page 119


  1980 FF:3128: E5 04        	SBC	<TMPFLG			; subtract string length
  1981 FF:312A: B0 03        	BCS	LAB_185E		; branch if less than terminal width
  1982                        
  1983 FF:312C: 20 3D 31     	JSR	LAB_CRLF		; else print CR/LF
  1984                        LAB_185E
  1985 FF:312F: 20 88 31     	JSR	LAB_18C6		; print string from <Sutill/<Sutilh
  1986 FF:3132: F0 B2        	BEQ	LAB_182C		; always go continue processing line
  1987                        
  1988                        ; CR/LF return to BASIC from BASIC input handler
  1989                        
  1990                        LAB_1866
  1991 FF:3134: A9 00        	LDA	#$00			; clear byte
  1992 FF:3136: 9D 81 21     	STA	Ibuffs,X		; null terminate input
  1993 FF:3139: A2 81        	LDX	#<Ibuffs		; set X to buffer start-1 low byte
  1994 FF:313B: A0 21        	LDY	#>Ibuffs		; set Y to buffer start-1 high byte
  1995                        ; print CR/LF
  1996                        
  1997                        LAB_CRLF
  1998 FF:313D: A9 0D        	LDA	#$0D			; load [CR]
  1999 FF:313F: 20 B3 31     	JSR	LAB_PRNA		; go print the character
  2000 FF:3142: A9 0A        	LDA	#$0A			; load [LF]
  2001 FF:3144: D0 6D        	BNE	LAB_PRNA		; go print the character and return, branch always
  2002                        LAB_188B
  2003 FF:3146: A5 0E        	LDA	<TPos			; get terminal position
  2004 FF:3148: C5 10        	CMP	<Iclim			; compare with input column limit
  2005 FF:314A: 90 05        	BCC	LAB_1897		; branch if less
  2006                        
  2007 FF:314C: 20 3D 31     	JSR	LAB_CRLF		; else print CR/LF (next line)
  2008 FF:314F: D0 2A        	BNE	LAB_18BD		; continue with PRINT processing (branch always)
  2009                        
  2010                        LAB_1897
  2011 FF:3151: 38           	SEC				; set carry for subtract
  2012                        LAB_1898
  2013 FF:3152: E5 64        	SBC	<TabSiz		; subtract TAB size
  2014 FF:3154: B0 FC        	BCS	LAB_1898		; loop if result was +ve
  2015                        
  2016 FF:3156: 49 FF        	EOR	#$FF			; complement it
  2017 FF:3158: 69 01        	ADC	#$01			; +1 (twos complement)
  2018 FF:315A: D0 15        	BNE	LAB_18B6		; always print A spaces (result is never $00)
  2019                        
  2020                        					; do TAB/SPC
  2021                        LAB_18A2
  2022 FF:315C: 48           	PHA				; save token
  2023 FF:315D: 20 9A 40     	JSR	LAB_SGBY		; scan and get byte parameter
  2024 FF:3160: C9 29        	CMP	#$29			; is next character )
  2025 FF:3162: F0 03        	BEQ LAB_18A2aa
  2026                        	;BNE	LAB_1910		; if not do syntax error then warm start
  2027 FF:3164: 4C FA 31     	jmp	LAB_1910		; if not do syntax error then warm start
  2028                        LAB_18A2aa:
  2029 FF:3167: 68           	PLA				; get token back
  2030 FF:3168: C9 C0        	CMP	#TK_TAB		; was it TAB ?
  2031 FF:316A: D0 06        	BNE	LAB_18B7		; if not go do SPC
  2032                        
  2033                        					; calculate TAB offset
  2034 FF:316C: 8A           	TXA				; copy integer value to A
  2035 FF:316D: E5 0E        	SBC	<TPos			; subtract terminal position
  2036 FF:316F: 90 0A        	BCC	LAB_18BD		; branch if result was < 0 (can't TAB backwards)
  Sun Nov 21 2021 15:13                                                                                                Page 120


  2037                        
  2038                        					; print A spaces
  2039                        LAB_18B6
  2040 FF:3171: AA           	TAX				; copy result to X
  2041                        LAB_18B7
  2042 FF:3172: 8A           	TXA				; set flags on size for SPC
  2043 FF:3173: F0 06        	BEQ	LAB_18BD		; branch if result was = $0, already here
  2044                        
  2045                        					; print X spaces
  2046                        LAB_18BA
  2047 FF:3175: 20 AE 31     	JSR	LAB_18E0		; print " "
  2048 FF:3178: CA           	DEX				; decrement count
  2049 FF:3179: D0 FA        	BNE	LAB_18BA		; loop if not all done
  2050                        
  2051                        					; continue with PRINT processing
  2052                        LAB_18BD
  2053 FF:317B: 22 BC 00 00  	JSL	LAB_IGBY		; increment and scan memory
  2054 FF:317F: F0 03        	BEQ LAB_18BDA
  2055 FF:3181: 4C EC 30     	JMP LAB_1831		; if more to print go do it
  2056                        LAB_18BDA
  2057 FF:3184: 60           	RTS
  2058                        
  2059                        ; print null terminated string from memory
  2060                        
  2061                        LAB_18C3
  2062 FF:3185: 20 38 3B     	JSR	LAB_20AE		; print " terminated string to <Sutill/<Sutilh
  2063                        
  2064                        ; print string from <Sutill/<Sutilh
  2065                        
  2066                        LAB_18C6
  2067 FF:3188: 20 15 3E     	JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
  2068                        					; space returns with A = length, X=$71=pointer low byte,
  2069                        					; Y=$72=pointer high byte
  2070 FF:318B: A0 00        	LDY	#$00			; reset index
  2071 FF:318D: AA           	TAX				; copy length to X
  2072 FF:318E: F0 5D        	BEQ	LAB_188C		; exit (RTS) if null string
  2073                        LAB_18CD
  2074                        
  2075                        	LDAINDIRECTY ut1_pl		; get next byte
+ 2075 FF:3190: 8B               PHB
+ 2075 FF:3191: DA           	PHX
+ 2075 FF:3192: A2 01            LDX #$01
+ 2075 FF:3194: B5 71            LDA <ut1_pl,X
+ 2075 FF:3196: C9 00            CMP #$00
+ 2075 FF:3198: D0 04            BNE *+6
+ 2075 FF:319A: A2 00        	LDX #00
+ 2075 FF:319C: DA           	PHX
+ 2075 FF:319D: AB           	PLB
+ 2075 FF:319E: FA               PLX
+ 2075 FF:319F: B1 71        	LDA	(<ut1_pl),Y		;
+ 2075 FF:31A1: 85 04            STA <TMPFLG
+ 2075 FF:31A3: AB               PLB
+ 2075 FF:31A4: A5 04            LDA <TMPFLG
  2076 FF:31A6: 20 B3 31     	JSR	LAB_PRNA		; go print the character
  2077 FF:31A9: C8           	INY				; increment index
  2078 FF:31AA: CA           	DEX				; decrement count
  2079 FF:31AB: D0 E3        	BNE	LAB_18CD		; loop if not done yet
  Sun Nov 21 2021 15:13                                                                                                Page 121


  2080 FF:31AD: 60           	RTS
  2081                        
  2082                        					; Print single format character
  2083                        ; print " "
  2084                        
  2085                        LAB_18E0
  2086 FF:31AE: A9 20        	LDA	#$20			; load " "
  2087 FF:31B0: 2C           	.byte	$2C			; change next line to BIT LAB_3FA9
  2088                        
  2089                        ; print "?" character
  2090                        
  2091                        LAB_18E3
  2092 FF:31B1: A9 3F        	LDA	#$3F			; load "?" character
  2093                        
  2094                        ; print character in A
  2095                        ; now includes the null handler
  2096                        ; also includes infinite line length code
  2097                        ; note! some routines expect this one to exit with Zb=0
  2098                        
  2099                        LAB_PRNA
  2100 FF:31B3: C9 20        	CMP	#' '			; compare with " "
  2101 FF:31B5: 90 19        	BCC	LAB_18F9		; branch if less (non printing)
  2102                        
  2103                        					; else printable character
  2104 FF:31B7: 48           	PHA				; save the character
  2105                        
  2106                        ; don't check fit if terminal width byte is zero
  2107                        
  2108 FF:31B8: A5 0F        	LDA	<TWidth		; get terminal width
  2109 FF:31BA: D0 0A        	BNE	LAB_18F0		; branch if not zero (not infinite length)
  2110                        
  2111                        ; is "infinite line" so check TAB position
  2112                        
  2113 FF:31BC: A5 0E        	LDA	<TPos			; get position
  2114 FF:31BE: E5 64        	SBC	<TabSiz		; subtract TAB size, carry set by CMP #$20 above
  2115 FF:31C0: D0 0B        	BNE	LAB_18F7		; skip reset if different
  2116                        
  2117 FF:31C2: 85 0E        	STA	<TPos			; else reset position
  2118 FF:31C4: F0 07        	BEQ	LAB_18F7		; go print character
  2119                        
  2120                        LAB_18F0
  2121 FF:31C6: C5 0E        	CMP	<TPos			; compare with terminal character position
  2122 FF:31C8: D0 03        	BNE	LAB_18F7		; branch if not at end of line
  2123                        
  2124 FF:31CA: 20 3D 31     	JSR	LAB_CRLF		; else print CR/LF
  2125                        LAB_18F7
  2126 FF:31CD: E6 0E        	INC	<TPos			; increment terminal position
  2127 FF:31CF: 68           	PLA				; get character back
  2128                        LAB_18F9
  2129 FF:31D0: 20 D0 18     	JSR	V_OUTP		; output byte via output vector
  2130 FF:31D3: C9 0D        	CMP	#$0D			; compare with [CR]
  2131 FF:31D5: D0 14        	BNE	LAB_188A		; branch if not [CR]
  2132                        
  2133                        					; else print nullct nulls after the [CR]
  2134 FF:31D7: 86 78        	STX	<TempB			; save buffer index
  2135 FF:31D9: A6 0D        	LDX	<Nullct		; get null count
  2136 FF:31DB: F0 0A        	BEQ	LAB_1886		; branch if no nulls
  Sun Nov 21 2021 15:13                                                                                                Page 122


  2137                        
  2138 FF:31DD: A9 00        	LDA	#$00			; load [NULL]
  2139                        LAB_1880
  2140 FF:31DF: 20 B3 31     	JSR	LAB_PRNA		; go print the character
  2141 FF:31E2: CA           	DEX				; decrement count
  2142 FF:31E3: D0 FA        	BNE	LAB_1880		; loop if not all done
  2143                        
  2144 FF:31E5: A9 0D        	LDA	#$0D			; restore the character (and set the flags)
  2145                        LAB_1886
  2146 FF:31E7: 86 0E        	STX	<TPos			; clear terminal position (X always = zero when we get here)
  2147 FF:31E9: A6 78        	LDX	<TempB			; restore buffer index
  2148                        LAB_188A
  2149 FF:31EB: 29 FF        	AND	#$FF			; set the flags
  2150                        LAB_188C
  2151 FF:31ED: 60           	RTS
  2152                        
  2153                        ; handle bad input data
  2154                        
  2155                        LAB_1904
  2156 FF:31EE: A5 62        	LDA	<Imode			; get input mode flag, $00=INPUT, $00=READ
  2157 FF:31F0: 10 0B        	BPL	LAB_1913		; branch if INPUT (go do redo)
  2158                        
  2159 FF:31F2: A5 8D        	LDA	<Dlinel		; get current DATA line low byte
  2160 FF:31F4: A4 8E        	LDY	<Dlineh		; get current DATA line high byte
  2161 FF:31F6: 85 87        	STA	<Clinel		; save current line low byte
  2162 FF:31F8: 84 88        	STY	<Clineh		; save current line high byte
  2163                        LAB_1910
  2164 FF:31FA: 4C 28 35     	JMP	LAB_SNER		; do syntax error then warm start
  2165                        
  2166                        					; mode was INPUT
  2167                        LAB_1913
  2168 FF:31FD: A9 F6        	LDA	#<LAB_REDO		; point to redo message (low addr)
  2169 FF:31FF: A0 17        	LDY	#>LAB_REDO		; point to redo message (high addr)
  2170 FF:3201: 20 85 31     	JSR	LAB_18C3		; print null terminated string from memory
  2171 FF:3204: A5 8B        	LDA	<Cpntrl		; get continue pointer low byte
  2172 FF:3206: A4 8C        	LDY	<Cpntrh		; get continue pointer high byte
  2173 FF:3208: 85 C3        	STA	<Bpntrl		; save BASIC execute pointer low byte
  2174 FF:320A: 84 C4        	STY	<Bpntrh		; save BASIC execute pointer high byte
  2175 FF:320C: 60           	RTS
  2176                        
  2177                        ; perform INPUT
  2178                        
  2179                        LAB_INPUT
  2180 FF:320D: C9 22        	CMP	#$22			; compare next byte with open quote
  2181 FF:320F: D0 0B        	BNE	LAB_1934		; branch if no prompt string
  2182                        
  2183 FF:3211: 20 E1 34     	JSR	LAB_1BC1		; print "..." string
  2184 FF:3214: A9 3B        	LDA	#$3B			; load A with ";"
  2185 FF:3216: 20 15 35     	JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
  2186 FF:3219: 20 88 31     	JSR	LAB_18C6		; print string from <Sutill/<Sutilh
  2187                        
  2188                        					; done with prompt, now get data
  2189                        LAB_1934
  2190 FF:321C: 20 CE 39     	JSR	LAB_CKRN		; check not Direct, back here if ok
  2191 FF:321F: 20 DE 29     	JSR	LAB_INLN		; print "? " and get BASIC input
  2192 FF:3222: A9 00        	LDA	#$00			; set mode = INPUT
  2193                        	;CMP	Ibuffs			; test first byte in buffer
  Sun Nov 21 2021 15:13                                                                                                Page 123


  2194 FF:3224: 80 06        	BRA	LAB_1953		; branch if not null input
  2195                        
  2196                        	;CLC				; was null input so clear carry to exit program
  2197                        	;JMP	LAB_1647		; go do BREAK exit
  2198                        
  2199                        ; perform READ
  2200                        
  2201                        LAB_READ
  2202 FF:3226: A6 8F        	LDX	<Dptrl			; get DATA pointer low byte
  2203 FF:3228: A4 90        	LDY	<Dptrh			; get DATA pointer high byte
  2204 FF:322A: A9 80        	LDA	#$80			; set mode = READ
  2205                        
  2206                        LAB_1953
  2207 FF:322C: 85 62        	STA	<Imode			; set input mode flag, $00=INPUT, $80=READ
  2208 FF:322E: 86 91        	STX	<Rdptrl			; save READ pointer low byte
  2209 FF:3230: 84 92        	STY	<Rdptrh			; save READ pointer high byte
  2210                        
  2211                        					; READ or INPUT next variable from list
  2212                        LAB_195B
  2213 FF:3232: 20 FF 36     	JSR	LAB_GVAR		; get (var) address
  2214 FF:3235: 85 97        	STA	<Lvarpl		; save address low byte
  2215 FF:3237: 84 98        	STY	<Lvarph		; save address high byte
  2216 FF:3239: A5 C3        	LDA	<Bpntrl		; get BASIC execute pointer low byte
  2217 FF:323B: A4 C4        	LDY	<Bpntrh		; get BASIC execute pointer high byte
  2218 FF:323D: 85 11        	STA	<Itempl		; save as temporary integer low byte
  2219 FF:323F: 84 12        	STY	<Itemph		; save as temporary integer high byte
  2220 FF:3241: A6 91        	LDX	<Rdptrl		; get READ pointer low byte
  2221 FF:3243: A4 92        	LDY	<Rdptrh		; get READ pointer high byte
  2222 FF:3245: 86 C3        	STX	<Bpntrl		; set BASIC execute pointer low byte
  2223 FF:3247: 84 C4        	STY	<Bpntrh		; set BASIC execute pointer high byte
  2224 FF:3249: 22 C2 00 00  	JSL	LAB_GBYT		; scan memory
  2225 FF:324D: D0 0C        	BNE	LAB_1988		; branch if not null
  2226                        
  2227                        					; pointer was to null entry
  2228 FF:324F: 24 62        	BIT	<Imode			; test input mode flag, $00=INPUT, $80=READ
  2229 FF:3251: 30 63        	BMI	LAB_19DD		; branch if READ
  2230                        
  2231                        					; mode was INPUT
  2232                        	;JSR	LAB_18E3		; print "?" character (double ? for extended input)
  2233                        	;JSR	LAB_INLN		; print "? " and get BASIC input
  2234 FF:3253: 86 C3        	STX	<Bpntrl		; set BASIC execute pointer low byte
  2235 FF:3255: 84 C4        	STY	<Bpntrh		; set BASIC execute pointer high byte
  2236                        LAB_1985
  2237 FF:3257: 22 C2 00 00  	JSL	LAB_GBYT		; scan memory
  2238                        LAB_1988
  2239 FF:325B: 24 5F        	BIT	<Dtypef		; test data type flag, $FF=string, $00=numeric
  2240 FF:325D: 10 24        	BPL	LAB_19B0		; branch if numeric
  2241                        
  2242                        					; else get string
  2243 FF:325F: 85 5B        	STA	<Srchc			; save search character
  2244 FF:3261: C9 22        	CMP	#$22			; was it " ?
  2245 FF:3263: F0 07        	BEQ	LAB_1999		; branch if so
  2246                        
  2247 FF:3265: A9 3A        	LDA	#':'			; else search character is ":"
  2248 FF:3267: 85 5B        	STA	<Srchc			; set new search character
  2249 FF:3269: A9 2C        	LDA	#','			; other search character is ","
  2250 FF:326B: 18           	CLC				; clear carry for add
  Sun Nov 21 2021 15:13                                                                                                Page 124


  2251                        LAB_1999
  2252 FF:326C: 85 5C        	STA	<Asrch			; set second search character
  2253 FF:326E: A5 C3        	LDA	<Bpntrl		; get BASIC execute pointer low byte
  2254 FF:3270: A4 C4        	LDY	<Bpntrh		; get BASIC execute pointer high byte
  2255                        
  2256 FF:3272: 69 00        	ADC	#$00			; c is =1 if we came via the BEQ LAB_1999, else =0
  2257 FF:3274: 90 01        	BCC	LAB_19A4		; branch if no execute pointer low byte rollover
  2258                        
  2259 FF:3276: C8           	INY				; else increment high byte
  2260                        LAB_19A4
  2261 FF:3277: 20 3E 3B     	JSR	LAB_20B4		; print <Srchc or <Asrch terminated string to <Sutill/<Sutilh
  2262 FF:327A: 20 20 41     	JSR	LAB_23F3		; restore BASIC execute pointer from temp (<Btmpl/<Btmph)
  2263 FF:327D: 20 9C 2F     	JSR	LAB_17D5		; go do string LET
  2264 FF:3280: 4C 89 32     	JMP	LAB_19B6		; go check string terminator
  2265                        
  2266                        					; get numeric INPUT
  2267                        LAB_19B0
  2268 FF:3283: 20 A9 47     	JSR	LAB_2887		; get FAC1 from string
  2269 FF:3286: 20 F2 45     	JSR	LAB_PFAC		; pack FAC1 into (<Lvarpl)
  2270                        LAB_19B6
  2271 FF:3289: 22 C2 00 00  	JSL	LAB_GBYT		; scan memory
  2272 FF:328D: F0 0B        	BEQ	LAB_19C5		; branch if null (last entry)
  2273                        
  2274 FF:328F: C9 2C        	CMP	#','			; else compare with ","
  2275 FF:3291: F0 03        	BEQ	LAB_19C2		; branch if ","
  2276                        
  2277 FF:3293: 4C EE 31     	JMP	LAB_1904		; else go handle bad input data
  2278                        
  2279                        					; got good input data
  2280                        LAB_19C2
  2281 FF:3296: 22 BC 00 00  	JSL	LAB_IGBY		; increment and scan memory
  2282                        LAB_19C5
  2283 FF:329A: A5 C3        	LDA	<Bpntrl		; get BASIC execute pointer low byte (temp READ/INPUT ptr)
  2284 FF:329C: A4 C4        	LDY	<Bpntrh		; get BASIC execute pointer high byte (temp READ/INPUT ptr)
  2285 FF:329E: 85 91        	STA	<Rdptrl		; save for now
  2286 FF:32A0: 84 92        	STY	<Rdptrh		; save for now
  2287 FF:32A2: A5 11        	LDA	<Itempl		; get temporary integer low byte (temp BASIC execute ptr)
  2288 FF:32A4: A4 12        	LDY	<Itemph		; get temporary integer high byte (temp BASIC execute ptr)
  2289 FF:32A6: 85 C3        	STA	<Bpntrl		; set BASIC execute pointer low byte
  2290 FF:32A8: 84 C4        	STY	<Bpntrh		; set BASIC execute pointer high byte
  2291 FF:32AA: 22 C2 00 00  	JSL	LAB_GBYT		; scan memory
  2292 FF:32AE: F0 30        	BEQ	LAB_1A03		; if null go do extra ignored message
  2293                        
  2294 FF:32B0: 20 24 35     	JSR	LAB_1C01		; else scan for "," , else do syntax error then warm start
  2295 FF:32B3: 4C 32 32     	JMP	LAB_195B		; go INPUT next variable from list
  2296                        
  2297                        					; find next DATA statement or do "Out of DATA" error
  2298                        LAB_19DD
  2299 FF:32B6: 20 6C 2E     	JSR	LAB_SNBS		; scan for next BASIC statement ([:] or [EOL])
  2300 FF:32B9: C8           	INY				; increment index
  2301 FF:32BA: AA           	TAX				; copy character ([:] or [EOL])
  2302 FF:32BB: D0 15        	BNE	LAB_19F6		; branch if [:]
  2303                        
  2304 FF:32BD: A2 06        	LDX	#$06			; set for "Out of DATA" error
  2305 FF:32BF: C8           	INY				; increment index, now points to next line pointer high byte
  2306 FF:32C0: B1 C3        	LDA (<Bpntrl),Y		; get next line pointer high byte
  2307 FF:32C2: D0 03        	BNE	LAB_19DE		; branch if NOT end (eventually does error X)
  Sun Nov 21 2021 15:13                                                                                                Page 125


  2308 FF:32C4: 4C 81 33     	JMP LAB_1A54
  2309                        LAB_19DE
  2310 FF:32C7: C8           	INY				; increment index
  2311 FF:32C8: B1 C3        	LDA (<Bpntrl),Y		; get next line # low byte
  2312 FF:32CA: 85 8D        	STA	<Dlinel		; save current DATA line low byte
  2313 FF:32CC: C8           	INY				; increment index
  2314 FF:32CD: B1 C3        	LDA (<Bpntrl),Y		; get next line # high byte
  2315 FF:32CF: C8           	INY				; increment index
  2316 FF:32D0: 85 8E        	STA	<Dlineh		; save current DATA line high byte
  2317                        LAB_19F6
  2318 FF:32D2: B1 C3        	LDA (<Bpntrl),Y		; get byte
  2319 FF:32D4: C8           	INY				; increment index
  2320 FF:32D5: AA           	TAX				; copy to X
  2321 FF:32D6: 20 5E 2E     	JSR	LAB_170F		; set BASIC execute pointer
  2322 FF:32D9: E0 83        	CPX	#TK_DATA		; compare with "DATA" token
  2323 FF:32DB: D0 D9        	BNE	LAB_19DD		; go find next statement if not "DATA"
  2324 FF:32DD: 4C 57 32     	JMP	LAB_1985		; was "DATA" so go do next READ
  2325                        
  2326                        ; end of INPUT/READ routine
  2327                        
  2328                        LAB_1A03
  2329 FF:32E0: A5 91        	LDA	<Rdptrl		; get temp READ pointer low byte
  2330 FF:32E2: A4 92        	LDY	<Rdptrh		; get temp READ pointer high byte
  2331 FF:32E4: A6 62        	LDX	<Imode			; get input mode flag, $00=INPUT, $80=READ
  2332 FF:32E6: 10 03        	BPL	LAB_1A0E		; branch if INPUT
  2333                        
  2334 FF:32E8: 4C 16 2D     	JMP	LAB_1624		; save AY as DATA pointer and return
  2335                        
  2336                        					; we were getting INPUT
  2337                        LAB_1A0E
  2338 FF:32EB: A0 00        	LDY	#$00			; clear index
  2339                        	LDAINDIRECTY Rdptrl		; get next byte
+ 2339 FF:32ED: 8B               PHB
+ 2339 FF:32EE: DA           	PHX
+ 2339 FF:32EF: A2 01            LDX #$01
+ 2339 FF:32F1: B5 91            LDA <Rdptrl,X
+ 2339 FF:32F3: C9 00            CMP #$00
+ 2339 FF:32F5: D0 04            BNE *+6
+ 2339 FF:32F7: A2 00        	LDX #00
+ 2339 FF:32F9: DA           	PHX
+ 2339 FF:32FA: AB           	PLB
+ 2339 FF:32FB: FA               PLX
+ 2339 FF:32FC: B1 91        	LDA	(<Rdptrl),Y		;
+ 2339 FF:32FE: 85 04            STA <TMPFLG
+ 2339 FF:3300: AB               PLB
+ 2339 FF:3301: A5 04            LDA <TMPFLG
  2340 FF:3303: D0 01        	BNE	LAB_1A1B		; error if not end of INPUT
  2341                        
  2342 FF:3305: 60           	RTS
  2343                        
  2344                        					; user typed too much
  2345                        LAB_1A1B
  2346 FF:3306: A9 E5        	LDA	#<LAB_IMSG		; point to extra ignored message (low addr)
  2347 FF:3308: A0 17        	LDY	#>LAB_IMSG		; point to extra ignored message (high addr)
  2348 FF:330A: 4C 85 31     	JMP	LAB_18C3		; print null terminated string from memory and return
  2349                        
  2350                        ; search the stack for FOR activity
  Sun Nov 21 2021 15:13                                                                                                Page 126


  2351                        ; exit with z=1 if FOR else exit with z=0
  2352                        
  2353                        LAB_11A1
  2354                        	Index16
+ 2354 FF:330D: C2 10        		REP #$10 		; 16 bit Index registers
+ 2354                        		LONGI ON
  2355 FF:330F: BA           	TSX				; copy stack pointer
  2356 FF:3310: E8           	INX				; +1 pass return address
  2357 FF:3311: E8           	INX				; +2 pass return address
  2358 FF:3312: E8           	INX				; +3 pass calling routine return address
  2359 FF:3313: E8           	INX				; +4 pass calling routine return address
  2360                        LAB_11A6
  2361 FF:3314: 8B           	PHB
  2362 FF:3315: A9 00        	LDA #$00		; WANT TO ACCESS ZERO BANK FOR STACK
  2363 FF:3317: 48           	PHA
  2364 FF:3318: AB           	PLB
  2365 FF:3319: BD 01 00     	LDA	1,X			; get token byte from stack
  2366 FF:331C: AB           	PLB
  2367 FF:331D: C9 81        	CMP	#TK_FOR		; is it FOR token
  2368 FF:331F: D0 47        	BNE	LAB_11CE	; exit if not FOR token
  2369                        
  2370                        					; was FOR token
  2371 FF:3321: A5 98        	LDA	<Frnxth		; get var pointer for FOR/NEXT high byte
  2372 FF:3323: D0 10        	BNE	LAB_11BB	; branch if not null
  2373                        
  2374 FF:3325: 8B           	PHB
  2375 FF:3326: A9 00        	LDA #$00		; WANT TO ACCESS ZERO BANK FOR STACK
  2376 FF:3328: 48           	PHA
  2377 FF:3329: AB           	PLB
  2378 FF:332A: BD 02 00     	LDA	2,X			; get FOR variable pointer low byte
  2379 FF:332D: 85 97        	STA	<Frnxtl		; save var pointer for FOR/NEXT low byte
  2380 FF:332F: BD 03 00     	LDA	3,X			; get FOR variable pointer high byte
  2381 FF:3332: 85 98        	STA	<Frnxth		; save var pointer for FOR/NEXT high byte
  2382 FF:3334: AB           	PLB
  2383                        LAB_11BB
  2384 FF:3335: 8B           	PHB
  2385 FF:3336: A9 00        	LDA #$00		; WANT TO ACCESS ZERO BANK FOR STACK
  2386 FF:3338: 48           	PHA
  2387 FF:3339: AB           	PLB
  2388 FF:333A: BD 03 00     	LDA	3,X
  2389 FF:333D: 85 04        	STA <TMPFLG
  2390 FF:333F: AB           	PLB
  2391 FF:3340: C5 04        	CMP	<TMPFLG			; compare var pointer with stacked var pointer (high byte)
  2392 FF:3342: D0 11        	BNE	LAB_11C7	; branch if no match
  2393                        
  2394 FF:3344: A5 97        	LDA	<Frnxtl		; get var pointer for FOR/NEXT low byte
  2395 FF:3346: 8B           	PHB
  2396 FF:3347: A9 00        	LDA #$00		; WANT TO ACCESS ZERO BANK FOR STACK
  2397 FF:3349: 48           	PHA
  2398 FF:334A: AB           	PLB
  2399 FF:334B: BD 02 00     	LDA	2,X
  2400 FF:334E: 85 04        	STA <TMPFLG
  2401 FF:3350: AB           	PLB
  2402 FF:3351: C5 04        	CMP	<TMPFLG			; compare var pointer with stacked var pointer (high byte)
  2403 FF:3353: F0 13        	BEQ	LAB_11CE	; exit if match found
  2404                        
  2405                        LAB_11C7
  Sun Nov 21 2021 15:13                                                                                                Page 127


  2406 FF:3355: E8           	INX
  2407 FF:3356: E8           	INX
  2408 FF:3357: E8           	INX
  2409 FF:3358: E8           	INX
  2410 FF:3359: E8           	INX
  2411 FF:335A: E8           	INX
  2412 FF:335B: E8           	INX
  2413 FF:335C: E8           	INX
  2414 FF:335D: E8           	INX
  2415 FF:335E: E8           	INX
  2416 FF:335F: E8           	INX
  2417 FF:3360: E8           	INX
  2418 FF:3361: E8           	INX
  2419 FF:3362: E8           	INX
  2420 FF:3363: E8           	INX
  2421 FF:3364: E8           	INX
  2422 FF:3365: 9A           	TXS				; copy back to index
  2423 FF:3366: D0 AC        	BNE	LAB_11A6		; loop if not at start of stack
  2424                        LAB_11CE
  2425 FF:3368: 86 FD        	STX <TEMPW
  2426                        	Index8
+ 2426 FF:336A: E2 10        		SEP #$10 		; 8 bit Index registers
+ 2426                        		LONGI OFF
  2427 FF:336C: 60           	RTS
  2428                        
  2429                        ; perform NEXT
  2430                        
  2431                        LAB_NEXT
  2432 FF:336D: D0 04        	BNE	LAB_1A46		; branch if NEXT var
  2433                        
  2434 FF:336F: A0 00        	LDY	#$00			; else clear Y
  2435 FF:3371: F0 03        	BEQ	LAB_1A49		; branch always (no variable to search for)
  2436                        
  2437                        ; NEXT var
  2438                        
  2439                        LAB_1A46
  2440 FF:3373: 20 FF 36     	JSR	LAB_GVAR		; get variable address
  2441                        LAB_1A49
  2442 FF:3376: 85 97        	STA	<Frnxtl		; store variable pointer low byte
  2443 FF:3378: 84 98        	STY	<Frnxth		; store variable pointer high byte
  2444                        					; (both cleared if no variable defined)
  2445 FF:337A: 20 0D 33     	JSR	LAB_11A1		; search the stack for FOR activity
  2446 FF:337D: F0 04        	BEQ	LAB_1A56		; branch if found
  2447                        
  2448 FF:337F: A2 00        	LDX	#$00			; else set error $00 ("NEXT without FOR" error)
  2449                        LAB_1A54
  2450 FF:3381: F0 7C        	BEQ	LAB_1ABE		; do error #X, then warm start
  2451                        
  2452                        
  2453                        LAB_1A56
  2454                        	AccumulatorIndex16
+ 2454 FF:3383: C2 30        		REP #$30 		; 16 bit Index registers
+ 2454                        		LONGA ON
+ 2454                                LONGI ON
  2455 FF:3385: A6 FD        	LDX <TEMPW
  2456 FF:3387: 9A           	TXS				; set stack pointer, X set by search, dumps return addresses
  2457 FF:3388: 8A           	TXA				; copy stack pointer
  Sun Nov 21 2021 15:13                                                                                                Page 128


  2458 FF:3389: 18           	CLC				; CLEAR carry
  2459                        
  2460 FF:338A: 69 09 00     	ADC	#$0009		; point to TO var
  2461 FF:338D: 85 73        	STA	<ut2_pl		; save pointer to TO var for compare
  2462 FF:338F: 38           	SEC
  2463 FF:3390: E9 05 00     	SBC	#$0005		; point to STEP var
  2464 FF:3393: 85 FD        	STA <TEMPW
  2465                        
  2466                        	AccumulatorIndex8
+ 2466 FF:3395: E2 30        		SEP #$30 		; 8 bit Index registers
+ 2466                        		LONGA OFF
+ 2466                                LONGI OFF
  2467 FF:3397: A4 FE        	LDY	<TEMPW+1		; point to stack page high byte
  2468                        
  2469 FF:3399: 8B           	PHB				; ensure UNPACK works in stack bank not data bank
  2470 FF:339A: DA           	phx
  2471 FF:339B: A2 00        	ldx #$00
  2472 FF:339D: DA           	phx
  2473 FF:339E: AB           	PLB
  2474 FF:339F: FA           	plx
  2475 FF:33A0: 20 7C 45     	JSR	LAB_UFAC	; unpack memory (STEP value) into FAC1
  2476 FF:33A3: AB           	PLB
  2477                        
  2478 FF:33A4: A3 08        	LDA	8,S			; get step sign
  2479 FF:33A6: 85 B0        	STA	<FAC1_s		; save FAC1 sign (b7)
  2480 FF:33A8: A5 97        	LDA	<Frnxtl		; get FOR variable pointer low byte
  2481 FF:33AA: A4 98        	LDY	<Frnxth		; get FOR variable pointer high byte
  2482 FF:33AC: 20 67 42     	JSR	LAB_246C		; add (FOR variable) to FAC1
  2483 FF:33AF: 20 F2 45     	JSR	LAB_PFAC		; pack FAC1 into (FOR variable)
  2484 FF:33B2: A4 FE        	LDY	<TEMPW+1		; point to stack page high byte
  2485                        
  2486 FF:33B4: 8B           	PHB				; ensure compare works in stack bank not data bank
  2487 FF:33B5: DA           	phx
  2488 FF:33B6: A2 00        	ldx #$00
  2489 FF:33B8: DA           	phx
  2490 FF:33B9: AB           	PLB
  2491 FF:33BA: FA           	plx
  2492                        
  2493 FF:33BB: 20 B8 46     	JSR	LAB_27FA		; compare FAC1 with (Y,<ut2_pl) (TO value)
  2494 FF:33BE: AB           	PLB
  2495                        
  2496                        
  2497 FF:33BF: C3 08        	CMP	8,S	; compare step sign
  2498 FF:33C1: F0 13        	BEQ	LAB_1A9B		; branch if = (loop complete)
  2499                        ;
  2500                        ;					; loop back and do it all again
  2501 FF:33C3: A3 0D        	LDA	$0D,S		; get FOR line low byte
  2502 FF:33C5: 85 87        	STA	<Clinel		; save current line low byte
  2503 FF:33C7: A3 0E        	LDA	$0E,S		; get FOR line high byte
  2504 FF:33C9: 85 88        	STA	<Clineh		; save current line high byte
  2505 FF:33CB: A3 10        	LDA	$10,S		; get BASIC execute pointer low byte
  2506 FF:33CD: 85 C3        	STA	<Bpntrl		; save BASIC execute pointer low byte
  2507 FF:33CF: A3 0F        	LDA	$0F,S		; get BASIC execute pointer high byte
  2508 FF:33D1: 85 C4        	STA	<Bpntrh		; save BASIC execute pointer high byte
  2509                        LAB_1A98
  2510 FF:33D3: 4C 76 2C     	JMP	LAB_15C2		; go do interpreter inner loop
  2511                        ;
  Sun Nov 21 2021 15:13                                                                                                Page 129


  2512                        ;					; loop complete so carry on
  2513                        LAB_1A9B
  2514                        
  2515                        
  2516                        	AccumulatorIndex16
+ 2516 FF:33D6: C2 30        		REP #$30 		; 16 bit Index registers
+ 2516                        		LONGA ON
+ 2516                                LONGI ON
  2517 FF:33D8: 3B           	TSC				; stack copy to A
  2518                        ;;;;;;;;;;;;;;;;;;; THIS MAY NOT BE RIGHT !@#$%^&* TAG
  2519 FF:33D9: 69 0F 00     	ADC	#$000F			; add $10 ($0F+carry) to dump FOR structure
  2520 FF:33DC: 1B           	TCS				; copy back to index
  2521                        	AccumulatorIndex8
+ 2521 FF:33DD: E2 30        		SEP #$30 		; 8 bit Index registers
+ 2521                        		LONGA OFF
+ 2521                                LONGI OFF
  2522                        
  2523                        
  2524                        
  2525 FF:33DF: 22 C2 00 00  	JSL	LAB_GBYT		; scan memory
  2526 FF:33E3: C9 2C        	CMP	#','			; compare with ","
  2527 FF:33E5: D0 EC        	BNE	LAB_1A98		; branch if not "," (go do interpreter inner loop)
  2528                        
  2529                        					; was "," so another NEXT variable to do
  2530 FF:33E7: 22 BC 00 00  	JSL	LAB_IGBY		; else increment and scan memory
  2531 FF:33EB: 20 73 33     	JSR	LAB_1A46		; do NEXT (var)
  2532                        
  2533                        ; evaluate expression and check is numeric, else do type mismatch
  2534                        
  2535                        LAB_EVNM
  2536 FF:33EE: 20 02 34     	JSR	LAB_EVEX		; evaluate expression
  2537                        
  2538                        ; check if source is numeric, else do type mismatch
  2539                        
  2540                        LAB_CTNM
  2541 FF:33F1: 18           	CLC				; destination is numeric
  2542 FF:33F2: 24           	.byte	$24			; makes next line BIT $38
  2543                        
  2544                        ; check if source is string, else do type mismatch
  2545                        
  2546                        LAB_CTST
  2547 FF:33F3: 38           	SEC				; required type is string
  2548                        
  2549                        ; type match check, set C for string, clear C for numeric
  2550                        
  2551                        LAB_CKTM
  2552 FF:33F4: 24 5F        	BIT	<Dtypef		; test data type flag, $FF=string, $00=numeric
  2553 FF:33F6: 30 03        	BMI	LAB_1ABA		; branch if data type is string
  2554                        
  2555                        					; else data type was numeric
  2556 FF:33F8: B0 03        	BCS	LAB_1ABC		; if required type is string do type mismatch error
  2557                        LAB_1AB9
  2558 FF:33FA: 60           	RTS
  2559                        
  2560                        					; data type was string, now check required type
  2561                        LAB_1ABA
  2562 FF:33FB: B0 FD        	BCS	LAB_1AB9		; exit if required type is string
  Sun Nov 21 2021 15:13                                                                                                Page 130


  2563                        
  2564                        					; else do type mismatch error
  2565                        LAB_1ABC
  2566 FF:33FD: A2 18        	LDX	#$18			; error code $18 ("Type mismatch" error)
  2567                        LAB_1ABE
  2568 FF:33FF: 4C C1 28     	JMP	LAB_XERR		; do error #X, then warm start
  2569                        
  2570                        ; evaluate expression
  2571                        
  2572                        LAB_EVEX
  2573 FF:3402: A6 C3        	LDX	<Bpntrl		; get BASIC execute pointer low byte
  2574 FF:3404: D0 02        	BNE	LAB_1AC7		; skip next if not zero
  2575                        
  2576 FF:3406: C6 C4        	DEC	<Bpntrh		; else decrement BASIC execute pointer high byte
  2577                        LAB_1AC7
  2578 FF:3408: C6 C3        	DEC	<Bpntrl		; decrement BASIC execute pointer low byte
  2579                        
  2580                        LAB_EVEZ
  2581 FF:340A: A9 00        	LDA	#$00			; set null precedence (flag done)
  2582                        LAB_1ACC
  2583 FF:340C: 48           	PHA				; push precedence byte
  2584 FF:340D: A9 02        	LDA	#$02			; 2 bytes
  2585 FF:340F: 20 78 28     	JSR	LAB_1212		; check room on stack for A bytes
  2586 FF:3412: 20 F0 34     	JSR	LAB_GVAL		; get value from line
  2587 FF:3415: A9 00        	LDA	#$00			; clear A
  2588 FF:3417: 85 9B        	STA	<comp_f		; clear compare function flag
  2589                        LAB_1ADB
  2590 FF:3419: 22 C2 00 00  	JSL	LAB_GBYT		; scan memory
  2591                        LAB_1ADE
  2592 FF:341D: 38           	SEC				; set carry for subtract
  2593 FF:341E: E9 D5        	SBC	#TK_GT		; subtract token for > (lowest comparison function)
  2594 FF:3420: 90 18        	BCC	LAB_1AFA		; branch if < TK_GT
  2595                        
  2596 FF:3422: C9 03        	CMP	#$03			; compare with ">" to "<" tokens
  2597 FF:3424: B0 14        	BCS	LAB_1AFA		; branch if >= TK_SGN (highest evaluation function +1)
  2598                        
  2599                        					; was token for > = or < (A = 0, 1 or 2)
  2600 FF:3426: C9 01        	CMP	#$01			; compare with token for =
  2601 FF:3428: 2A           	ROL	A			; *2, b0 = carry (=1 if token was = or <)
  2602                        					; (A = 0, 3 or 5)
  2603 FF:3429: 49 01        	EOR	#$01			; toggle b0
  2604                        					; (A = 1, 2 or 4. 1 if >, 2 if =, 4 if <)
  2605 FF:342B: 45 9B        	EOR	<comp_f		; EOR with compare function flag bits
  2606 FF:342D: C5 9B        	CMP	<comp_f		; compare with compare function flag
  2607 FF:342F: 90 68        	BCC	LAB_1B53		; if <(<comp_f) do syntax error then warm start
  2608                        					; was more than one <, = or >)
  2609                        
  2610 FF:3431: 85 9B        	STA	<comp_f		; save new compare function flag
  2611 FF:3433: 22 BC 00 00  	JSL	LAB_IGBY		; increment and scan memory
  2612 FF:3437: 4C 1D 34     	JMP	LAB_1ADE		; go do next character
  2613                        
  2614                        					; token is < ">" or > "<" tokens
  2615                        LAB_1AFA
  2616 FF:343A: A6 9B        	LDX	<comp_f		; get compare function flag
  2617 FF:343C: D0 2C        	BNE	LAB_1B2A		; branch if compare function
  2618                        
  2619 FF:343E: B0 79        	BCS	LAB_1B78		; go do functions
  Sun Nov 21 2021 15:13                                                                                                Page 131


  2620                        
  2621                        					; else was <  TK_GT so is operator or lower
  2622 FF:3440: 69 0A        	ADC	#TK_GT-TK_PLUS	; add # of operators (+, -, *, /, ^, AND, OR or EOR)
  2623 FF:3442: 90 75        	BCC	LAB_1B78		; branch if < + operator
  2624                        
  2625                        					; carry was set so token was +, -, *, /, ^, AND, OR or EOR
  2626 FF:3444: D0 07        	BNE	LAB_1B0B		; branch if not + token
  2627                        
  2628 FF:3446: 24 5F        	BIT	<Dtypef		; test data type flag, $FF=string, $00=numeric
  2629 FF:3448: 10 03        	BPL	LAB_1B0B		; branch if not string
  2630                        
  2631                        					; will only be $00 if type is string and token was +
  2632 FF:344A: 4C 1C 3D     	JMP	LAB_224D		; add strings, string 1 is in descriptor <des_pl, string 2
  2633                        					; is in line, and return
  2634                        
  2635                        LAB_1B0B
  2636 FF:344D: 85 71        	STA	<ut1_pl		; save it
  2637 FF:344F: 0A           	ASL	A		; *2
  2638 FF:3450: 65 71        	ADC	<ut1_pl		; *3
  2639 FF:3452: A8           	TAY				; copy to index
  2640                        LAB_1B13
  2641 FF:3453: 68           	PLA				; pull previous precedence
  2642 FF:3454: D9 4C 11     	CMP	LAB_OPPT,Y		; compare with precedence byte
  2643 FF:3457: B0 65        	BCS	LAB_1B7D		; branch if A >=
  2644                        
  2645 FF:3459: 20 F1 33     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  2646                        LAB_1B1C
  2647 FF:345C: 48           	PHA				; save precedence
  2648                        LAB_1B1D
  2649 FF:345D: 20 85 34     	JSR	LAB_1B43		; get vector, execute function then continue evaluation
  2650 FF:3460: 68           	PLA				; restore precedence
  2651 FF:3461: A4 99        	LDY	<prstk			; get precedence stacked flag
  2652 FF:3463: 10 19        	BPL	LAB_1B3C		; branch if stacked values
  2653                        
  2654 FF:3465: AA           	TAX				; copy precedence (set flags)
  2655 FF:3466: F0 76        	BEQ	LAB_1B9D		; exit if done
  2656                        
  2657 FF:3468: D0 5D        	BNE	LAB_1B86		; else pop FAC2 and return, branch always
  2658                        
  2659                        LAB_1B2A
  2660 FF:346A: 26 5F        	ROL	<Dtypef		; shift data type flag into Cb
  2661 FF:346C: 8A           	TXA				; copy compare function flag
  2662 FF:346D: 85 5F        	STA	<Dtypef		; clear data type flag, X is 0xxx xxxx
  2663 FF:346F: 2A           	ROL	A			; shift data type into compare function byte b0
  2664 FF:3470: A6 C3        	LDX	<Bpntrl		; get BASIC execute pointer low byte
  2665 FF:3472: D0 02        	BNE	LAB_1B34		; branch if no underflow
  2666                        
  2667 FF:3474: C6 C4        	DEC	<Bpntrh		; else decrement BASIC execute pointer high byte
  2668                        LAB_1B34
  2669 FF:3476: C6 C3        	DEC	<Bpntrl		; decrement BASIC execute pointer low byte
  2670             0000000C   TK_LT_PLUS	.EQU TK_LT-TK_PLUS
  2671 FF:3478: A0 24        	LDY	#TK_LT_PLUS*3	; set offset to last operator entry
  2672 FF:347A: 85 9B        	STA	<comp_f		; save new compare function flag
  2673 FF:347C: D0 D5        	BNE	LAB_1B13		; branch always
  2674                        
  2675                        LAB_1B3C
  2676 FF:347E: D9 4C 11     	CMP	LAB_OPPT,Y		;.compare with stacked function precedence
  Sun Nov 21 2021 15:13                                                                                                Page 132


  2677 FF:3481: B0 44        	BCS	LAB_1B86		; branch if A >=, pop FAC2 and return
  2678                        
  2679 FF:3483: 90 D7        	BCC	LAB_1B1C		; branch always
  2680                        
  2681                        ;.get vector, execute function then continue evaluation
  2682                        
  2683                        LAB_1B43
  2684 FF:3485: B9 4E 11     	LDA	LAB_OPPT+2,Y	; get function vector high byte
  2685 FF:3488: 48           	PHA				; onto stack
  2686 FF:3489: B9 4D 11     	LDA	LAB_OPPT+1,Y	; get function vector low byte
  2687 FF:348C: 48           	PHA				; onto stack
  2688                        					; now push sign, round FAC1 and put on stack
  2689 FF:348D: 20 9C 34     	JSR	LAB_1B5B		; function will return here, then the next RTS will call
  2690                        					; the function
  2691 FF:3490: A5 9B        	LDA	<comp_f		; get compare function flag
  2692 FF:3492: 48           	PHA				; push compare evaluation byte
  2693 FF:3493: B9 4C 11     	LDA	LAB_OPPT,Y		; get precedence byte
  2694 FF:3496: 4C 0C 34     	JMP	LAB_1ACC		; continue evaluating expression
  2695                        
  2696                        LAB_1B53
  2697 FF:3499: 4C 28 35     	JMP	LAB_SNER		; do syntax error then warm start
  2698                        
  2699                        ; push sign, round FAC1 and put on stack
  2700                        
  2701                        LAB_1B5B
  2702 FF:349C: 68           	PLA				; get return addr low byte
  2703 FF:349D: 85 71        	STA	<ut1_pl		; save it
  2704 FF:349F: E6 71        	INC	<ut1_pl		; increment it (was ret-1 pushed? yes!)
  2705                        					; note! no check is made on the high byte! if the calling
  2706                        					; routine assembles to a page edge then this all goes
  2707                        					; horribly wrong !!!
  2708 FF:34A1: 68           	PLA				; get return addr high byte
  2709 FF:34A2: 85 72        	STA	<ut1_ph		; save it
  2710 FF:34A4: A5 B0        	LDA	<FAC1_s		; get FAC1 sign (b7)
  2711 FF:34A6: 48           	PHA				; push sign
  2712                        
  2713                        ; round FAC1 and put on stack
  2714                        
  2715                        LAB_1B66
  2716 FF:34A7: 20 78 46     	JSR	LAB_27BA		; round FAC1
  2717 FF:34AA: A5 AF        	LDA	<FAC1_3		; get FAC1 mantissa3
  2718 FF:34AC: 48           	PHA				; push on stack
  2719 FF:34AD: A5 AE        	LDA	<FAC1_2		; get FAC1 mantissa2
  2720 FF:34AF: 48           	PHA				; push on stack
  2721 FF:34B0: A5 AD        	LDA	<FAC1_1		; get FAC1 mantissa1
  2722 FF:34B2: 48           	PHA				; push on stack
  2723 FF:34B3: A5 AC        	LDA	<FAC1_e		; get FAC1 exponent
  2724 FF:34B5: 48           	PHA				; push on stack
  2725 FF:34B6: 6C 71 00     	JMP	(ut1_pl)		; return, sort of
  2726                        
  2727                        ; do functions
  2728                        
  2729                        LAB_1B78
  2730 FF:34B9: A0 FF        	LDY	#$FF			; flag function
  2731 FF:34BB: 68           	PLA				; pull precedence byte
  2732                        LAB_1B7B
  2733 FF:34BC: F0 20        	BEQ	LAB_1B9D		; exit if done
  Sun Nov 21 2021 15:13                                                                                                Page 133


  2734                        
  2735                        LAB_1B7D
  2736 FF:34BE: C9 64        	CMP	#$64			; compare previous precedence with $64
  2737 FF:34C0: F0 03        	BEQ	LAB_1B84		; branch if was $64 (< function)
  2738                        
  2739 FF:34C2: 20 F1 33     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  2740                        LAB_1B84
  2741 FF:34C5: 84 99        	STY	<prstk			; save precedence stacked flag
  2742                        
  2743                        					; pop FAC2 and return
  2744                        LAB_1B86
  2745 FF:34C7: 68           	PLA				; pop byte
  2746 FF:34C8: 4A           	LSR	A				; shift out comparison evaluation lowest bit
  2747 FF:34C9: 85 63        	STA	<Cflag			; save comparison evaluation flag
  2748 FF:34CB: 68           	PLA				; pop exponent
  2749 FF:34CC: 85 B3        	STA	<FAC2_e		; save FAC2 exponent
  2750 FF:34CE: 68           	PLA				; pop mantissa1
  2751 FF:34CF: 85 B4        	STA	<FAC2_1		; save FAC2 mantissa1
  2752 FF:34D1: 68           	PLA				; pop mantissa2
  2753 FF:34D2: 85 B5        	STA	<FAC2_2		; save FAC2 mantissa2
  2754 FF:34D4: 68           	PLA				; pop mantissa3
  2755 FF:34D5: 85 B6        	STA	<FAC2_3		; save FAC2 mantissa3
  2756 FF:34D7: 68           	PLA				; pop sign
  2757 FF:34D8: 85 B7        	STA	<FAC2_s		; save FAC2 sign (b7)
  2758 FF:34DA: 45 B0        	EOR	<FAC1_s		; EOR FAC1 sign (b7)
  2759 FF:34DC: 85 B8        	STA	<FAC_sc		; save sign compare (FAC1 EOR FAC2)
  2760                        LAB_1B9D
  2761 FF:34DE: A5 AC        	LDA	<FAC1_e		; get FAC1 exponent
  2762 FF:34E0: 60           	RTS
  2763                        
  2764                        ; print "..." string to string util area
  2765                        
  2766                        LAB_1BC1
  2767 FF:34E1: A5 C3        	LDA	<Bpntrl		; get BASIC execute pointer low byte
  2768 FF:34E3: A4 C4        	LDY	<Bpntrh		; get BASIC execute pointer high byte
  2769 FF:34E5: 69 00        	ADC	#$00			; add carry to low byte
  2770 FF:34E7: 90 01        	BCC	LAB_1BCA		; branch if no overflow
  2771                        
  2772 FF:34E9: C8           	INY				; increment high byte
  2773                        LAB_1BCA
  2774 FF:34EA: 20 38 3B     	JSR	LAB_20AE		; print " terminated string to <Sutill/<Sutilh
  2775 FF:34ED: 4C 20 41     	JMP	LAB_23F3		; restore BASIC execute pointer from temp and return
  2776                        
  2777                        ; get value from line
  2778                        
  2779                        LAB_GVAL
  2780 FF:34F0: 22 BC 00 00  	JSL	LAB_IGBY		; increment and scan memory
  2781 FF:34F4: B0 03        	BCS	LAB_1BAC		; branch if not numeric character
  2782                        
  2783                        					; else numeric string found (e.g. 123)
  2784                        LAB_1BA9
  2785 FF:34F6: 4C A9 47     	JMP	LAB_2887		; get FAC1 from string and return
  2786                        
  2787                        ; get value from line .. continued
  2788                        
  2789                        					; wasn't a number so ..
  2790                        LAB_1BAC
  Sun Nov 21 2021 15:13                                                                                                Page 134


  2791 FF:34F9: AA           	TAX				; set the flags
  2792 FF:34FA: 30 31        	BMI	LAB_1BD0		; if -ve go test token values
  2793                        
  2794                        					; else it is either a string, number, variable or (<expr>)
  2795 FF:34FC: C9 24        	CMP	#'$'			; compare with "$"
  2796 FF:34FE: F0 F6        	BEQ	LAB_1BA9		; branch if "$", hex number
  2797                        
  2798 FF:3500: C9 25        	CMP	#'%'			; else compare with "%"
  2799 FF:3502: F0 F2        	BEQ	LAB_1BA9		; branch if "%", binary number
  2800                        
  2801 FF:3504: C9 2E        	CMP	#'.'			; compare with "."
  2802 FF:3506: F0 EE        	BEQ	LAB_1BA9		; if so get FAC1 from string and return (e.g. was .123)
  2803                        
  2804                        					; it wasn't any sort of number so ..
  2805 FF:3508: C9 22        	CMP	#$22			; compare with "
  2806 FF:350A: F0 D5        	BEQ	LAB_1BC1		; branch if open quote
  2807                        
  2808                        					; wasn't any sort of number so ..
  2809                        
  2810                        ; evaluate expression within parentheses
  2811                        
  2812 FF:350C: C9 28        	CMP	#'('			; compare with "("
  2813 FF:350E: D0 51        	BNE	LAB_1C18		; if not "(" get (var), return value in FAC1 and $ flag
  2814                        
  2815                        LAB_1BF7
  2816 FF:3510: 20 0A 34     	JSR	LAB_EVEZ		; evaluate expression, no decrement
  2817                        
  2818                        ; all the 'scan for' routines return the character after the sought character
  2819                        
  2820                        ; scan for ")" , else do syntax error then warm start
  2821                        
  2822                        LAB_1BFB
  2823 FF:3513: A9 29        	LDA	#$29			; load A with ")"
  2824                        
  2825                        ; scan for CHR$(A) , else do syntax error then warm start
  2826                        
  2827                        LAB_SCCA
  2828 FF:3515: A0 00        	LDY	#$00			; clear index
  2829 FF:3517: D1 C3        	CMP (<Bpntrl),Y		; check next byte is = A
  2830 FF:3519: D0 0D        	BNE	LAB_SNER		; if not do syntax error then warm start
  2831                        
  2832 FF:351B: 22 BC 00 00  	JSL	LAB_IGBY		; increment and scan memory then return
  2833 FF:351F: 60           	RTS
  2834                        ; scan for "(" , else do syntax error then warm start
  2835                        
  2836                        LAB_1BFE
  2837 FF:3520: A9 28        	LDA	#$28			; load A with "("
  2838 FF:3522: D0 F1        	BNE	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
  2839                        					; (branch always)
  2840                        
  2841                        ; scan for "," , else do syntax error then warm start
  2842                        
  2843                        LAB_1C01
  2844 FF:3524: A9 2C        	LDA	#$2C			; load A with ","
  2845 FF:3526: D0 ED        	BNE	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
  2846                        					; (branch always)
  2847                        
  Sun Nov 21 2021 15:13                                                                                                Page 135


  2848                        ; syntax error then warm start
  2849                        
  2850                        LAB_SNER
  2851 FF:3528: A2 02        	LDX	#$02			; error code $02 ("Syntax" error)
  2852 FF:352A: 4C C1 28     	JMP	LAB_XERR		; do error #X, then warm start
  2853                        
  2854                        ; get value from line .. continued
  2855                        ; do tokens
  2856                        
  2857                        LAB_1BD0
  2858 FF:352D: C9 CC        	CMP	#TK_MINUS		; compare with token for -
  2859 FF:352F: F0 29        	BEQ	LAB_1C11		; branch if - token (do set-up for functions)
  2860                        
  2861                        					; wasn't -n so ..
  2862 FF:3531: C9 CB        	CMP	#TK_PLUS		; compare with token for +
  2863 FF:3533: F0 BB        	BEQ	LAB_GVAL		; branch if + token (+n = n so ignore leading +)
  2864                        
  2865 FF:3535: C9 C6        	CMP	#TK_NOT		; compare with token for NOT
  2866 FF:3537: D0 13        	BNE	LAB_1BE7		; branch if not token for NOT
  2867                        
  2868                        					; was NOT token
  2869             0000000B   TK_EQUAL_PLUS	.EQU TK_EQUAL-TK_PLUS
  2870 FF:3539: A0 21        	LDY	#TK_EQUAL_PLUS*3	; offset to NOT function
  2871 FF:353B: D0 1F        	BNE	LAB_1C13		; do set-up for function then execute (branch always)
  2872                        
  2873                        ; do = compare
  2874                        
  2875                        LAB_EQUAL
  2876 FF:353D: 20 00 38     	JSR	LAB_EVIR		; evaluate integer expression (no sign check)
  2877 FF:3540: A5 AF        	LDA	<FAC1_3		; get FAC1 mantissa3
  2878 FF:3542: 49 FF        	EOR	#$FF			; invert it
  2879 FF:3544: A8           	TAY				; copy it
  2880 FF:3545: A5 AE        	LDA	<FAC1_2		; get FAC1 mantissa2
  2881 FF:3547: 49 FF        	EOR	#$FF			; invert it
  2882 FF:3549: 4C BD 39     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  2883                        
  2884                        ; get value from line .. continued
  2885                        
  2886                        					; wasn't +, -, or NOT so ..
  2887                        LAB_1BE7
  2888 FF:354C: C9 C3        	CMP	#TK_FN		; compare with token for FN
  2889 FF:354E: D0 03        	BNE	LAB_1BEE		; branch if not token for FN
  2890                        
  2891 FF:3550: 4C 1B 3A     	JMP	LAB_201E		; go evaluate FNx
  2892                        
  2893                        ; get value from line .. continued
  2894                        
  2895                        					; wasn't +, -, NOT or FN so ..
  2896                        LAB_1BEE
  2897 FF:3553: E9 D8        	SBC	#TK_SGN		; subtract with token for SGN
  2898 FF:3555: B0 19        	BCS	LAB_1C27		; if a function token go do it
  2899                        
  2900 FF:3557: 4C 28 35     	JMP	LAB_SNER		; else do syntax error
  2901                        
  2902                        ; set-up for functions
  2903                        
  2904                        LAB_1C11
  Sun Nov 21 2021 15:13                                                                                                Page 136


  2905             0000000A   TK_GT_PLUS	.EQU TK_GT-TK_PLUS
  2906 FF:355A: A0 1E        	LDY	#TK_GT_PLUS*3	; set offset from base to > operator
  2907                        LAB_1C13
  2908 FF:355C: 68           	PLA				; dump return address low byte
  2909 FF:355D: 68           	PLA				; dump return address high byte
  2910 FF:355E: 4C 5D 34     	JMP	LAB_1B1D		; execute function then continue evaluation
  2911                        
  2912                        ; variable name set-up
  2913                        ; get (var), return value in FAC_1 and $ flag
  2914                        
  2915                        LAB_1C18
  2916 FF:3561: 20 FF 36     	JSR	LAB_GVAR		; get (var) address
  2917 FF:3564: 85 AE        	STA	<FAC1_2		; save address low byte in FAC1 mantissa2
  2918 FF:3566: 84 AF        	STY	<FAC1_3		; save address high byte in FAC1 mantissa3
  2919 FF:3568: A6 5F        	LDX	<Dtypef		; get data type flag, $FF=string, $00=numeric
  2920 FF:356A: 30 03        	BMI	LAB_1C25		; if string then return (does RTS)
  2921                        
  2922                        LAB_1C24
  2923 FF:356C: 4C 7C 45     	JMP	LAB_UFAC		; unpack memory (AY) into FAC1
  2924                        
  2925                        LAB_1C25
  2926 FF:356F: 60           	RTS
  2927                        
  2928                        ; get value from line .. continued
  2929                        ; only functions left so ..
  2930                        
  2931                        ; set up function references
  2932                        
  2933                        ; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
  2934                        ; to process function calls. now the function vector is computed and pushed on the stack
  2935                        ; and the preprocess offset is read. if the preprocess offset is non zero then the vector
  2936                        ; is calculated and the routine called, if not this routine just does RTS. whichever
  2937                        ; happens the RTS at the end of this routine, or the end of the preprocess routine, calls
  2938                        ; the function code
  2939                        
  2940                        ; this also removes some less than elegant code that was used to bypass type checking
  2941                        ; for functions that returned strings
  2942                        
  2943                        LAB_1C27
  2944 FF:3570: 0A           	ASL	A			; *2 (2 bytes per function address)
  2945 FF:3571: A8           	TAY				; copy to index
  2946                        
  2947 FF:3572: B9 03 11     	LDA	LAB_FTBM,Y		; get function jump vector high byte
  2948 FF:3575: 48           	PHA				; push functions jump vector high byte
  2949 FF:3576: B9 02 11     	LDA	LAB_FTBL,Y		; get function jump vector low byte
  2950 FF:3579: 48           	PHA				; push functions jump vector low byte
  2951                        
  2952 FF:357A: B9 B9 10     	LDA	LAB_FTPM,Y		; get function pre process vector high byte
  2953 FF:357D: F0 05        	BEQ	LAB_1C56		; skip pre process if null vector
  2954                        
  2955 FF:357F: 48           	PHA				; push functions pre process vector high byte
  2956 FF:3580: B9 B8 10     	LDA	LAB_FTPL,Y		; get function pre process vector low byte
  2957 FF:3583: 48           	PHA				; push functions pre process vector low byte
  2958                        
  2959                        LAB_1C56
  2960 FF:3584: 60           	RTS				; do function, or pre process, call
  2961                        
  Sun Nov 21 2021 15:13                                                                                                Page 137


  2962                        ; process string expression in parenthesis
  2963                        
  2964                        LAB_PPFS
  2965 FF:3585: 20 10 35     	JSR	LAB_1BF7		; process expression in parenthesis
  2966 FF:3588: 4C F3 33     	JMP	LAB_CTST		; check if source is string then do function,
  2967                        					; else do type mismatch
  2968                        
  2969                        ; process numeric expression in parenthesis
  2970                        
  2971                        LAB_PPFN
  2972 FF:358B: 20 10 35     	JSR	LAB_1BF7		; process expression in parenthesis
  2973 FF:358E: 4C F1 33     	JMP	LAB_CTNM		; check if source is numeric then do function,
  2974                        					; else do type mismatch
  2975                        
  2976                        ; set numeric data type and increment BASIC execute pointer
  2977                        
  2978                        LAB_PPBI
  2979 FF:3591: 46 5F        	LSR	<Dtypef		; clear data type flag, $FF=string, $00=numeric
  2980 FF:3593: 22 BC 00 00  	JSL	LAB_IGBY		; increment and scan memory then do function
  2981 FF:3597: 60           	RTS
  2982                        ; process string for LEFT$, RIGHT$ or MID$
  2983                        
  2984                        LAB_LRMS
  2985 FF:3598: 20 0A 34     	JSR	LAB_EVEZ		; evaluate (should be string) expression
  2986 FF:359B: 20 24 35     	JSR	LAB_1C01		; scan for ",", else do syntax error then warm start
  2987 FF:359E: 20 F3 33     	JSR	LAB_CTST		; check if source is string, else do type mismatch
  2988                        
  2989 FF:35A1: 68           	PLA				; get function jump vector low byte
  2990 FF:35A2: AA           	TAX				; save functions jump vector low byte
  2991 FF:35A3: 68           	PLA				; get function jump vector high byte
  2992 FF:35A4: A8           	TAY				; save functions jump vector high byte
  2993 FF:35A5: A5 AF        	LDA	<des_ph		; get descriptor pointer high byte
  2994 FF:35A7: 48           	PHA				; push string pointer high byte
  2995 FF:35A8: A5 AE        	LDA	<des_pl		; get descriptor pointer low byte
  2996 FF:35AA: 48           	PHA				; push string pointer low byte
  2997 FF:35AB: 98           	TYA				; get function jump vector high byte back
  2998 FF:35AC: 48           	PHA				; save functions jump vector high byte
  2999 FF:35AD: 8A           	TXA				; get function jump vector low byte back
  3000 FF:35AE: 48           	PHA				; save functions jump vector low byte
  3001 FF:35AF: 20 9E 40     	JSR	LAB_GTBY		; get byte parameter
  3002 FF:35B2: 8A           	TXA				; copy byte parameter to A
  3003 FF:35B3: 60           	RTS				; go do function
  3004                        
  3005                        ; process numeric expression(s) for BIN$ or HEX$
  3006                        
  3007                        LAB_BHSS
  3008 FF:35B4: 20 0A 34     	JSR	LAB_EVEZ		; process expression
  3009 FF:35B7: 20 F1 33     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  3010 FF:35BA: A5 AC        	LDA	<FAC1_e		; get FAC1 exponent
  3011 FF:35BC: C9 98        	CMP	#$98			; compare with exponent = 2^24
  3012 FF:35BE: B0 22        	BCS	LAB_BHER		; branch if n>=2^24 (is too big)
  3013                        
  3014 FF:35C0: 20 53 47     	JSR	LAB_2831		; convert FAC1 floating-to-fixed
  3015 FF:35C3: A2 02        	LDX	#$02			; 3 bytes to do
  3016                        LAB_CFAC
  3017 FF:35C5: B5 AD        	LDA	<FAC1_1,X		; get byte from FAC1
  3018 FF:35C7: 95 11        	STA	<nums_1,X		; save byte to temp
  Sun Nov 21 2021 15:13                                                                                                Page 138


  3019 FF:35C9: CA           	DEX				; decrement index
  3020 FF:35CA: 10 F9        	BPL	LAB_CFAC		; copy FAC1 mantissa to temp
  3021                        
  3022 FF:35CC: 22 C2 00 00  	JSL	LAB_GBYT		; get next BASIC byte
  3023 FF:35D0: A2 00        	LDX	#$00			; set default to no leading "0"s
  3024 FF:35D2: C9 29        	CMP	#')'			; compare with close bracket
  3025 FF:35D4: F0 0B        	BEQ	LAB_1C54		; if ")" go do rest of function
  3026                        
  3027 FF:35D6: 20 2F 41     	JSR	LAB_SCGB		; scan for "," and get byte
  3028 FF:35D9: 22 C2 00 00  	JSL	LAB_GBYT		; get last byte back
  3029 FF:35DD: C9 29        	CMP	#')'			; is next character )
  3030 FF:35DF: D0 01        	BNE	LAB_BHER		; if not ")" go do error
  3031                        
  3032                        LAB_1C54
  3033 FF:35E1: 60           	RTS				; else do function
  3034                        
  3035                        LAB_BHER
  3036 FF:35E2: 4C 87 38     	JMP	LAB_FCER		; do function call error then warm start
  3037                        
  3038                        ; perform EOR
  3039                        
  3040                        ; added operator format is the same as AND or OR, precedence is the same as OR
  3041                        
  3042                        ; this bit worked first time but it took a while to sort out the operator table
  3043                        ; pointers and offsets afterwards!
  3044                        
  3045                        LAB_EOR
  3046 FF:35E5: 20 0C 36     	JSR	GetFirst		; get first integer expression (no sign check)
  3047 FF:35E8: 45 5B        	EOR	<XOAw_l		; EOR with expression 1 low byte
  3048 FF:35EA: A8           	TAY				; save in Y
  3049 FF:35EB: A5 AE        	LDA	<FAC1_2		; get FAC1 mantissa2
  3050 FF:35ED: 45 5C        	EOR	<XOAw_h		; EOR with expression 1 high byte
  3051 FF:35EF: 4C BD 39     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3052                        
  3053                        ; perform OR
  3054                        
  3055                        LAB_OR
  3056 FF:35F2: 20 0C 36     	JSR	GetFirst		; get first integer expression (no sign check)
  3057 FF:35F5: 05 5B        	ORA	<XOAw_l		; OR with expression 1 low byte
  3058 FF:35F7: A8           	TAY				; save in Y
  3059 FF:35F8: A5 AE        	LDA	<FAC1_2		; get FAC1 mantissa2
  3060 FF:35FA: 05 5C        	ORA	<XOAw_h		; OR with expression 1 high byte
  3061 FF:35FC: 4C BD 39     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3062                        
  3063                        ; perform AND
  3064                        
  3065                        LAB_AND
  3066 FF:35FF: 20 0C 36     	JSR	GetFirst		; get first integer expression (no sign check)
  3067 FF:3602: 25 5B        	AND	<XOAw_l		; AND with expression 1 low byte
  3068 FF:3604: A8           	TAY				; save in Y
  3069 FF:3605: A5 AE        	LDA	<FAC1_2		; get FAC1 mantissa2
  3070 FF:3607: 25 5C        	AND	<XOAw_h		; AND with expression 1 high byte
  3071 FF:3609: 4C BD 39     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3072                        
  3073                        ; get first value for OR, AND or EOR
  3074                        
  3075                        GetFirst
  Sun Nov 21 2021 15:13                                                                                                Page 139


  3076 FF:360C: 20 00 38     	JSR	LAB_EVIR		; evaluate integer expression (no sign check)
  3077 FF:360F: A5 AE        	LDA	<FAC1_2		; get FAC1 mantissa2
  3078 FF:3611: 85 5C        	STA	<XOAw_h		; save it
  3079 FF:3613: A5 AF        	LDA	<FAC1_3		; get FAC1 mantissa3
  3080 FF:3615: 85 5B        	STA	<XOAw_l		; save it
  3081 FF:3617: 20 6C 42     	JSR	LAB_279B		; copy FAC2 to FAC1 (get 2nd value in expression)
  3082 FF:361A: 20 00 38     	JSR	LAB_EVIR		; evaluate integer expression (no sign check)
  3083 FF:361D: A5 AF        	LDA	<FAC1_3		; get FAC1 mantissa3
  3084                        LAB_1C95
  3085 FF:361F: 60           	RTS
  3086                        
  3087                        ; perform comparisons
  3088                        
  3089                        ; do < compare
  3090                        
  3091                        LAB_LTHAN
  3092 FF:3620: 20 F4 33     	JSR	LAB_CKTM		; type match check, set C for string
  3093 FF:3623: B0 13        	BCS	LAB_1CAE		; branch if string
  3094                        
  3095                        					; do numeric < compare
  3096 FF:3625: A5 B7        	LDA	<FAC2_s		; get FAC2 sign (b7)
  3097 FF:3627: 09 7F        	ORA	#$7F			; set all non sign bits
  3098 FF:3629: 25 B4        	AND	<FAC2_1		; and FAC2 mantissa1 (AND in sign bit)
  3099 FF:362B: 85 B4        	STA	<FAC2_1		; save FAC2 mantissa1
  3100 FF:362D: A9 B3        	LDA	#<FAC2_e		; set pointer low byte to FAC2
  3101 FF:362F: A0 00        	LDY	#>FAC2_e		; set pointer high byte to FAC2
  3102 FF:3631: 20 B6 46     	JSR	LAB_27F8		; compare FAC1 with FAC2 (AY)
  3103 FF:3634: AA           	TAX				; copy result
  3104 FF:3635: 4C 69 36     	JMP	LAB_1CE1		; go evaluate result
  3105                        
  3106                        					; do string < compare
  3107                        LAB_1CAE
  3108 FF:3638: 46 5F        	LSR	<Dtypef		; clear data type flag, $FF=string, $00=numeric
  3109 FF:363A: C6 9B        	DEC	<comp_f		; clear < bit in compare function flag
  3110 FF:363C: 20 15 3E     	JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
  3111                        					; space returns with A = length, X=pointer low byte,
  3112                        					; Y=pointer high byte
  3113 FF:363F: 85 AC        	STA	<str_ln		; save length
  3114 FF:3641: 86 AD        	STX	<str_pl		; save string pointer low byte
  3115 FF:3643: 84 AE        	STY	<str_ph		; save string pointer high byte
  3116 FF:3645: A5 B5        	LDA	<FAC2_2		; get descriptor pointer low byte
  3117 FF:3647: A4 B6        	LDY	<FAC2_3		; get descriptor pointer high byte
  3118 FF:3649: 20 19 3E     	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
  3119                        					; returns with A = length, X=pointer low byte,
  3120                        					; Y=pointer high byte
  3121 FF:364C: 86 B5        	STX	<FAC2_2		; save string pointer low byte
  3122 FF:364E: 84 B6        	STY	<FAC2_3		; save string pointer high byte
  3123 FF:3650: AA           	TAX				; copy length
  3124 FF:3651: 38           	SEC				; set carry for subtract
  3125 FF:3652: E5 AC        	SBC	<str_ln		; subtract string 1 length
  3126 FF:3654: F0 08        	BEQ	LAB_1CD6		; branch if str 1 length = string 2 length
  3127                        
  3128 FF:3656: A9 01        	LDA	#$01			; set str 1 length > string 2 length
  3129 FF:3658: 90 04        	BCC	LAB_1CD6		; branch if so
  3130                        
  3131 FF:365A: A6 AC        	LDX	<str_ln		; get string 1 length
  3132 FF:365C: A9 FF        	LDA	#$FF			; set str 1 length < string 2 length
  Sun Nov 21 2021 15:13                                                                                                Page 140


  3133                        LAB_1CD6
  3134 FF:365E: 85 B0        	STA	<FAC1_s		; save length compare
  3135 FF:3660: A0 FF        	LDY	#$FF			; set index
  3136 FF:3662: E8           	INX				; adjust for loop
  3137                        LAB_1CDB
  3138 FF:3663: C8           	INY				; increment index
  3139 FF:3664: CA           	DEX				; decrement count
  3140 FF:3665: D0 07        	BNE	LAB_1CE6		; branch if still bytes to do
  3141                        
  3142 FF:3667: A6 B0        	LDX	<FAC1_s		; get length compare back
  3143                        LAB_1CE1
  3144 FF:3669: 30 39        	BMI	LAB_1CF2		; branch if str 1 < str 2
  3145                        
  3146 FF:366B: 18           	CLC				; flag str 1 <= str 2
  3147 FF:366C: 90 36        	BCC	LAB_1CF2		; go evaluate result
  3148                        
  3149                        LAB_1CE6
  3150                        	LDAINDIRECTY FAC2_2		; get string 2 byte
+ 3150 FF:366E: 8B               PHB
+ 3150 FF:366F: DA           	PHX
+ 3150 FF:3670: A2 01            LDX #$01
+ 3150 FF:3672: B5 B5            LDA <FAC2_2,X
+ 3150 FF:3674: C9 00            CMP #$00
+ 3150 FF:3676: D0 04            BNE *+6
+ 3150 FF:3678: A2 00        	LDX #00
+ 3150 FF:367A: DA           	PHX
+ 3150 FF:367B: AB           	PLB
+ 3150 FF:367C: FA               PLX
+ 3150 FF:367D: B1 B5        	LDA	(<FAC2_2),Y		;
+ 3150 FF:367F: 85 04            STA <TMPFLG
+ 3150 FF:3681: AB               PLB
+ 3150 FF:3682: A5 04            LDA <TMPFLG
  3151                        	CMPINDIRECTY FAC1_1		; compare with string 1 byte
+ 3151 FF:3684: 8B               PHB
+ 3151 FF:3685: 48               PHA
+ 3151 FF:3686: DA               PHX
+ 3151 FF:3687: A2 01            LDX #$01
+ 3151 FF:3689: B5 AD            LDA <FAC1_1,X
+ 3151 FF:368B: C9 00            CMP #$00
+ 3151 FF:368D: D0 04            BNE *+6
+ 3151 FF:368F: A2 00        	LDX #00
+ 3151 FF:3691: DA           	PHX
+ 3151 FF:3692: AB           	PLB
+ 3151 FF:3693: FA               PLX
+ 3151 FF:3694: B1 AD            LDA	(<FAC1_1),Y		;
+ 3151 FF:3696: 85 04            STA <TMPFLG
+ 3151 FF:3698: 68               PLA
+ 3151 FF:3699: AB               PLB
+ 3151 FF:369A: C5 04            CMP	<TMPFLG		    ;
  3152 FF:369C: F0 C5        	BEQ	LAB_1CDB		; loop if bytes =
  3153                        
  3154 FF:369E: A2 FF        	LDX	#$FF			; set str 1 < string 2
  3155 FF:36A0: B0 02        	BCS	LAB_1CF2		; branch if so
  3156                        
  3157 FF:36A2: A2 01        	LDX	#$01			;  set str 1 > string 2
  3158                        LAB_1CF2
  3159 FF:36A4: E8           	INX				; x = 0, 1 or 2
  Sun Nov 21 2021 15:13                                                                                                Page 141


  3160 FF:36A5: 8A           	TXA				; copy to A
  3161 FF:36A6: 2A           	ROL	A			; *2 (1, 2 or 4)
  3162 FF:36A7: 25 63        	AND	<Cflag			; AND with comparison evaluation flag
  3163 FF:36A9: F0 02        	BEQ	LAB_1CFB		; branch if 0 (compare is false)
  3164                        
  3165 FF:36AB: A9 FF        	LDA	#$FF			; else set result true
  3166                        LAB_1CFB
  3167 FF:36AD: 4C 99 46     	JMP	LAB_27DB		; save A as integer byte and return
  3168                        
  3169                        LAB_1CFE
  3170 FF:36B0: 20 24 35     	JSR	LAB_1C01		; scan for ",", else do syntax error then warm start
  3171                        
  3172                        ; perform DIM
  3173                        
  3174                        LAB_DIM
  3175 FF:36B3: AA           	TAX				; copy "DIM" flag to X
  3176 FF:36B4: 20 05 37     	JSR	LAB_1D10		; search for variable
  3177 FF:36B7: 22 C2 00 00  	JSL	LAB_GBYT		; scan memory
  3178 FF:36BB: D0 F3        	BNE	LAB_1CFE		; scan for "," and loop if not null
  3179                        
  3180 FF:36BD: 60           	RTS
  3181                        
  3182                        ; perform << (left shift)
  3183                        
  3184                        LAB_LSHIFT
  3185 FF:36BE: 20 F4 36     	JSR	GetPair		; get integer expression and byte (no sign check)
  3186 FF:36C1: A5 AE        	LDA	<FAC1_2		; get expression high byte
  3187 FF:36C3: A6 78        	LDX	<TempB			; get shift count
  3188 FF:36C5: F0 22        	BEQ	NoShift		; branch if zero
  3189                        
  3190 FF:36C7: E0 10        	CPX	#$10			; compare bit count with 16d
  3191 FF:36C9: B0 23        	BCS	TooBig		; branch if >=
  3192                        
  3193                        Ls_loop
  3194 FF:36CB: 06 AF        	ASL	<FAC1_3		; shift low byte
  3195 FF:36CD: 2A           	ROL	A			; shift high byte
  3196 FF:36CE: CA           	DEX				; decrement bit count
  3197 FF:36CF: D0 FA        	BNE	Ls_loop		; loop if shift not complete
  3198                        
  3199 FF:36D1: A4 AF        	LDY	<FAC1_3		; get expression low byte
  3200 FF:36D3: 4C BD 39     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3201                        
  3202                        ; perform >> (right shift)
  3203                        
  3204                        LAB_RSHIFT
  3205 FF:36D6: 20 F4 36     	JSR	GetPair		; get integer expression and byte (no sign check)
  3206 FF:36D9: A5 AE        	LDA	<FAC1_2		; get expression high byte
  3207 FF:36DB: A6 78        	LDX	<TempB			; get shift count
  3208 FF:36DD: F0 0A        	BEQ	NoShift		; branch if zero
  3209                        
  3210 FF:36DF: E0 10        	CPX	#$10			; compare bit count with 16d
  3211 FF:36E1: B0 0B        	BCS	TooBig		; branch if >=
  3212                        
  3213                        Rs_loop
  3214 FF:36E3: 4A           	LSR	A			; shift high byte
  3215 FF:36E4: 66 AF        	ROR	<FAC1_3		; shift low byte
  3216 FF:36E6: CA           	DEX				; decrement bit count
  Sun Nov 21 2021 15:13                                                                                                Page 142


  3217 FF:36E7: D0 FA        	BNE	Rs_loop		; loop if shift not complete
  3218                        
  3219                        NoShift
  3220 FF:36E9: A4 AF        	LDY	<FAC1_3		; get expression low byte
  3221 FF:36EB: 4C BD 39     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3222                        
  3223                        TooBig
  3224 FF:36EE: A9 00        	LDA	#$00			; clear high byte
  3225 FF:36F0: A8           	TAY				; copy to low byte
  3226 FF:36F1: 4C BD 39     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  3227                        
  3228                        GetPair
  3229 FF:36F4: 20 A1 40     	JSR	LAB_EVBY		; evaluate byte expression, result in X
  3230 FF:36F7: 86 78        	STX	<TempB			; save it
  3231 FF:36F9: 20 6C 42     	JSR	LAB_279B		; copy FAC2 to FAC1 (get 2nd value in expression)
  3232 FF:36FC: 4C 00 38     	JMP	LAB_EVIR		; evaluate integer expression (no sign check)
  3233                        
  3234                        ; search for variable
  3235                        
  3236                        ; return pointer to variable in <Cvaral/<Cvarah
  3237                        
  3238                        LAB_GVAR
  3239 FF:36FF: A2 00        	LDX	#$00			; set DIM flag = $00
  3240 FF:3701: 22 C2 00 00  	JSL	LAB_GBYT		; scan memory (1st character)
  3241                        LAB_1D10
  3242 FF:3705: 86 5E        	STX	<Defdim		; save DIM flag
  3243                        LAB_1D12
  3244 FF:3707: 85 93        	STA	<Varnm1		; save 1st character
  3245 FF:3709: 29 7F        	AND	#$7F			; clear FN flag bit
  3246 FF:370B: 20 77 37     	JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
  3247 FF:370E: B0 03        	BCS	LAB_1D1F		; branch if ok
  3248                        
  3249 FF:3710: 4C 28 35     	JMP	LAB_SNER		; else syntax error then warm start
  3250                        
  3251                        					; was variable name so ..
  3252                        LAB_1D1F
  3253 FF:3713: A2 00        	LDX	#$00			; clear 2nd character temp
  3254 FF:3715: 86 5F        	STX	<Dtypef		; clear data type flag, $FF=string, $00=numeric
  3255 FF:3717: 22 BC 00 00  	JSL	LAB_IGBY		; increment and scan memory (2nd character)
  3256 FF:371B: 90 05        	BCC	LAB_1D2D		; branch if character = "0"-"9" (ok)
  3257                        
  3258                        					; 2nd character wasn't "0" to "9" so ..
  3259 FF:371D: 20 77 37     	JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
  3260 FF:3720: 90 0C        	BCC	LAB_1D38		; branch if <"A" or >"Z" (go check if string)
  3261                        
  3262                        LAB_1D2D
  3263 FF:3722: AA           	TAX				; copy 2nd character
  3264                        
  3265                        					; ignore further (valid) characters in the variable name
  3266                        LAB_1D2E
  3267 FF:3723: 22 BC 00 00  	JSL	LAB_IGBY		; increment and scan memory (3rd character)
  3268 FF:3727: 90 FA        	BCC	LAB_1D2E		; loop if character = "0"-"9" (ignore)
  3269                        
  3270 FF:3729: 20 77 37     	JSR	LAB_CASC		; check byte, return C=0 if<"A" or >"Z"
  3271 FF:372C: B0 F5        	BCS	LAB_1D2E		; loop if character = "A"-"Z" (ignore)
  3272                        
  3273                        					; check if string variable
  Sun Nov 21 2021 15:13                                                                                                Page 143


  3274                        LAB_1D38
  3275 FF:372E: C9 24        	CMP	#'$'			; compare with "$"
  3276 FF:3730: D0 0C        	BNE	LAB_1D47		; branch if not string
  3277                        
  3278                        ; to introduce a new variable type (% suffix for integers say) then this branch
  3279                        ; will need to go to that check and then that branch, if it fails, go to LAB_1D47
  3280                        
  3281                        					; type is string
  3282 FF:3732: A9 FF        	LDA	#$FF			; set data type = string
  3283 FF:3734: 85 5F        	STA	<Dtypef		; set data type flag, $FF=string, $00=numeric
  3284 FF:3736: 8A           	TXA				; get 2nd character back
  3285 FF:3737: 09 80        	ORA	#$80			; set top bit (indicate string var)
  3286 FF:3739: AA           	TAX				; copy back to 2nd character temp
  3287 FF:373A: 22 BC 00 00  	JSL	LAB_IGBY		; increment and scan memory
  3288                        
  3289                        ; after we have determined the variable type we need to come back here to determine
  3290                        ; if it's an array of type. this would plug in a%(b[,c[,d]])) integer arrays nicely
  3291                        
  3292                        
  3293                        LAB_1D47				; gets here with character after var name in A
  3294 FF:373E: 86 94        	STX	<Varnm2		; save 2nd character
  3295 FF:3740: 05 61        	ORA	<Sufnxf		; or with subscript/FNX flag (or FN name)
  3296 FF:3742: C9 28        	CMP	#'('			; compare with "("
  3297 FF:3744: D0 03        	BNE	LAB_1D53		; branch if not "("
  3298                        
  3299 FF:3746: 4C 12 38     	JMP	LAB_1E17		; go find, or make, array
  3300                        
  3301                        ; either find or create var
  3302                        ; var name (1st two characters only!) is in <Varnm1,<Varnm2
  3303                        
  3304                        					; variable name wasn't var(... so look for plain var
  3305                        LAB_1D53
  3306 FF:3749: A9 00        	LDA	#$00			; clear A
  3307 FF:374B: 85 61        	STA	<Sufnxf		; clear subscript/FNX flag
  3308 FF:374D: A5 7B        	LDA	<Svarl			; get start of vars low byte
  3309 FF:374F: A6 7C        	LDX	<Svarh			; get start of vars high byte
  3310 FF:3751: A0 00        	LDY	#$00			; clear index
  3311                        LAB_1D5D
  3312 FF:3753: 86 AB        	STX	<Vrschh		; save search address high byte
  3313                        LAB_1D5F
  3314 FF:3755: 85 AA        	STA	<Vrschl		; save search address low byte
  3315 FF:3757: E4 7E        	CPX	<Sarryh		; compare high address with var space end
  3316 FF:3759: D0 04        	BNE	LAB_1D69		; skip next compare if <>
  3317                        
  3318                        					; high addresses were = so compare low addresses
  3319 FF:375B: C5 7D        	CMP	<Sarryl		; compare low address with var space end
  3320 FF:375D: F0 2C        	BEQ	LAB_1D8B		; if not found go make new var
  3321                        
  3322                        LAB_1D69
  3323 FF:375F: A5 93        	LDA	<Varnm1		; get 1st character of var to find
  3324 FF:3761: D1 AA        	CMP (<Vrschl),Y	; compare with variable name 1st character
  3325 FF:3763: D0 08        	BNE	LAB_1D77		; branch if no match
  3326                        
  3327                        					; 1st characters match so compare 2nd characters
  3328 FF:3765: A5 94        	LDA	<Varnm2		; get 2nd character of var to find
  3329 FF:3767: C8           	INY				; index to point to variable name 2nd character
  3330 FF:3768: D1 AA        	CMP (<Vrschl),Y		; compare with variable name 2nd character
  Sun Nov 21 2021 15:13                                                                                                Page 144


  3331 FF:376A: F0 69        	BEQ	LAB_1DD7		; branch if match (found var)
  3332                        
  3333 FF:376C: 88           	DEY				; else decrement index (now = $00)
  3334                        LAB_1D77
  3335 FF:376D: 18           	CLC				; clear carry for add
  3336 FF:376E: A5 AA        	LDA	<Vrschl		; get search address low byte
  3337 FF:3770: 69 06        	ADC	#$06			; +6 (offset to next var name)
  3338 FF:3772: 90 E1        	BCC	LAB_1D5F		; loop if no overflow to high byte
  3339                        
  3340 FF:3774: E8           	INX				; else increment high byte
  3341 FF:3775: D0 DC        	BNE	LAB_1D5D		; loop always (RAM doesn't extend to $FFFF !)
  3342                        
  3343                        ; check byte, return C=0 if<"A" or >"Z" or "a" to "z"
  3344                        
  3345                        LAB_CASC
  3346 FF:3777: C9 61        	CMP	#'a'			; compare with "a"
  3347 FF:3779: B0 0A        	BCS	LAB_1D83		; go check <"z"+1
  3348                        
  3349                        ; check byte, return C=0 if<"A" or >"Z"
  3350                        
  3351                        LAB_1D82
  3352 FF:377B: C9 41        	CMP	#'A'			; compare with "A"
  3353 FF:377D: 90 05        	BCC	LAB_1D8A		; exit if less
  3354                        
  3355                        					; carry is set
  3356 FF:377F: E9 5B        	SBC	#$5B			; subtract "Z"+1
  3357 FF:3781: 38           	SEC				; set carry
  3358 FF:3782: E9 A5        	SBC	#$A5			; subtract $A5 (restore byte)
  3359                        					; carry clear if byte>$5A
  3360                        LAB_1D8A
  3361 FF:3784: 60           	RTS
  3362                        
  3363                        LAB_1D83
  3364 FF:3785: E9 7B        	SBC	#$7B			; subtract "z"+1
  3365 FF:3787: 38           	SEC				; set carry
  3366 FF:3788: E9 85        	SBC	#$85			; subtract $85 (restore byte)
  3367                        					; carry clear if byte>$7A
  3368 FF:378A: 60           	RTS
  3369                        
  3370                        					; reached end of variable mem without match
  3371                        					; .. so create new variable
  3372                        LAB_1D8B
  3373 FF:378B: 68           	PLA				; pop return address low byte
  3374 FF:378C: 48           	PHA				; push return address low byte
  3375             00FF3563   LAB_1C18p2	.EQU LAB_1C18+2
  3376 FF:378D: C9 63        	CMP	#<LAB_1C18p2	; compare with expected calling routine return low byte
  3377 FF:378F: D0 05        	BNE	LAB_1D98		; if not get (var) go create new var
  3378                        
  3379                        ; This will only drop through if the call was from LAB_1C18 and is only called
  3380                        ; from there if it is searching for a variable from the RHS of a LET a=b statement
  3381                        ; it prevents the creation of variables not assigned a value.
  3382                        
  3383                        ; value returned by this is either numeric zero (exponent byte is $00) or null string
  3384                        ; (descriptor length byte is $00). in fact a pointer to any $00 byte would have done.
  3385                        
  3386                        ; doing this saves 6 bytes of variable memory and 168 machine cycles of time
  3387                        
  Sun Nov 21 2021 15:13                                                                                                Page 145


  3388                        ; this is where you would put the undefined variable error call e.g.
  3389                        
  3390                        ;					; variable doesn't exist so flag error
  3391                        ;	LDX	#$24			; error code $24 ("undefined variable" error)
  3392                        ;	JMP	LAB_XERR		; do error #X then warm start
  3393                        
  3394                        ; the above code has been tested and works a treat! (it replaces the three code lines
  3395                        ; below)
  3396                        
  3397                        					; else return dummy null value
  3398 FF:3791: A9 9B        	LDA	#<LAB_1D96		; low byte point to $00,$00
  3399                        					; (uses part of misc constants table)
  3400 FF:3793: A0 18        	LDY	#>LAB_1D96		; high byte point to $00,$00
  3401 FF:3795: 60           	RTS
  3402                        
  3403                        					; create new numeric variable
  3404                        LAB_1D98
  3405 FF:3796: A5 7D        	LDA	<Sarryl		; get var mem end low byte
  3406 FF:3798: A4 7E        	LDY	<Sarryh		; get var mem end high byte
  3407 FF:379A: 85 AA        	STA	<Ostrtl		; save old block start low byte
  3408 FF:379C: 84 AB        	STY	<Ostrth		; save old block start high byte
  3409 FF:379E: A5 7F        	LDA	<Earryl		; get array mem end low byte
  3410 FF:37A0: A4 80        	LDY	<Earryh		; get array mem end high byte
  3411 FF:37A2: 85 A6        	STA	<Obendl		; save old block end low byte
  3412 FF:37A4: 84 A7        	STY	<Obendh		; save old block end high byte
  3413 FF:37A6: 18           	CLC				; clear carry for add
  3414 FF:37A7: 69 06        	ADC	#$06			; +6 (space for one var)
  3415 FF:37A9: 90 01        	BCC	LAB_1DAE		; branch if no overflow to high byte
  3416                        
  3417 FF:37AB: C8           	INY				; else increment high byte
  3418                        LAB_1DAE
  3419 FF:37AC: 85 A4        	STA	<Nbendl		; set new block end low byte
  3420 FF:37AE: 84 A5        	STY	<Nbendh		; set new block end high byte
  3421 FF:37B0: 20 E6 27     	JSR	LAB_11CF		; open up space in memory
  3422 FF:37B3: A5 A4        	LDA	<Nbendl		; get new start low byte
  3423 FF:37B5: A4 A5        	LDY	<Nbendh		; get new start high byte (-$100)
  3424 FF:37B7: C8           	INY				; correct high byte
  3425 FF:37B8: 85 7D        	STA	<Sarryl		; save new var mem end low byte
  3426 FF:37BA: 84 7E        	STY	<Sarryh		; save new var mem end high byte
  3427 FF:37BC: A0 00        	LDY	#$00			; clear index
  3428 FF:37BE: A5 93        	LDA	<Varnm1		; get var name 1st character
  3429 FF:37C0: 91 AA        	STA (<Vrschl),Y		; save var name 1st character
  3430 FF:37C2: C8           	INY				; increment index
  3431 FF:37C3: A5 94        	LDA	<Varnm2		; get var name 2nd character
  3432 FF:37C5: 91 AA        	STA (<Vrschl),Y		; save var name 2nd character
  3433 FF:37C7: A9 00        	LDA	#$00			; clear A
  3434 FF:37C9: C8           	INY				; increment index
  3435 FF:37CA: 91 AA        	STA (<Vrschl),Y		; initialise var byte
  3436 FF:37CC: C8           	INY				; increment index
  3437 FF:37CD: 91 AA        	STA (<Vrschl),Y		; initialise var byte
  3438 FF:37CF: C8           	INY				; increment index
  3439 FF:37D0: 91 AA        	STA (<Vrschl),Y		; initialise var byte
  3440 FF:37D2: C8           	INY				; increment index
  3441 FF:37D3: 91 AA        	STA (<Vrschl),Y		; initialise var byte
  3442                        
  3443                        					; found a match for var ((<Vrschl) = ptr)
  3444                        LAB_1DD7
  Sun Nov 21 2021 15:13                                                                                                Page 146


  3445 FF:37D5: A5 AA        	LDA	<Vrschl		; get var address low byte
  3446 FF:37D7: 18           	CLC				; clear carry for add
  3447 FF:37D8: 69 02        	ADC	#$02			; +2 (offset past var name bytes)
  3448 FF:37DA: A4 AB        	LDY	<Vrschh		; get var address high byte
  3449 FF:37DC: 90 01        	BCC	LAB_1DE1		; branch if no overflow from add
  3450                        
  3451 FF:37DE: C8           	INY				; else increment high byte
  3452                        LAB_1DE1
  3453 FF:37DF: 85 95        	STA	<Cvaral		; save current var address low byte
  3454 FF:37E1: 84 96        	STY	<Cvarah		; save current var address high byte
  3455 FF:37E3: 60           	RTS
  3456                        
  3457                        ; set-up array pointer (<Adatal/h) to first element in array
  3458                        ; set <Adatal,<Adatah to <Astrtl,<Astrth+2*<Dimcnt+#$05
  3459                        
  3460                        LAB_1DE6
  3461 FF:37E4: A5 5D        	LDA	<Dimcnt		; get # of dimensions (1, 2 or 3)
  3462 FF:37E6: 0A           	ASL	A			; *2 (also clears the carry !)
  3463 FF:37E7: 69 05        	ADC	#$05			; +5 (result is 7, 9 or 11 here)
  3464 FF:37E9: 65 AA        	ADC	<Astrtl		; add array start pointer low byte
  3465 FF:37EB: A4 AB        	LDY	<Astrth		; get array pointer high byte
  3466 FF:37ED: 90 01        	BCC	LAB_1DF2		; branch if no overflow
  3467                        
  3468 FF:37EF: C8           	INY				; else increment high byte
  3469                        LAB_1DF2
  3470 FF:37F0: 85 A4        	STA	<Adatal		; save array data pointer low byte
  3471 FF:37F2: 84 A5        	STY	<Adatah		; save array data pointer high byte
  3472 FF:37F4: 60           	RTS
  3473                        
  3474                        ; evaluate integer expression
  3475                        
  3476                        LAB_EVIN
  3477 FF:37F5: 22 BC 00 00  	JSL	LAB_IGBY		; increment and scan memory
  3478 FF:37F9: 20 EE 33     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
  3479                        					; else do type mismatch
  3480                        
  3481                        ; evaluate integer expression (no check)
  3482                        
  3483                        LAB_EVPI
  3484 FF:37FC: A5 B0        	LDA	<FAC1_s		; get FAC1 sign (b7)
  3485 FF:37FE: 30 0D        	BMI	LAB_1E12		; do function call error if -ve
  3486                        
  3487                        ; evaluate integer expression (no sign check)
  3488                        
  3489                        LAB_EVIR
  3490 FF:3800: A5 AC        	LDA	<FAC1_e		; get FAC1 exponent
  3491 FF:3802: C9 90        	CMP	#$90			; compare with exponent = 2^16 (n>2^15)
  3492 FF:3804: 90 09        	BCC	LAB_1E14		; branch if n<2^16 (is ok)
  3493                        
  3494 FF:3806: A9 A2        	LDA	#<LAB_1DF7		; set pointer low byte to -32768
  3495 FF:3808: A0 18        	LDY	#>LAB_1DF7		; set pointer high byte to -32768
  3496 FF:380A: 20 B6 46     	JSR	LAB_27F8		; compare FAC1 with (AY)
  3497                        LAB_1E12
  3498 FF:380D: D0 78        	BNE	LAB_FCER		; if <> do function call error then warm start
  3499                        
  3500                        LAB_1E14
  3501 FF:380F: 4C 53 47     	JMP	LAB_2831		; convert FAC1 floating-to-fixed and return
  Sun Nov 21 2021 15:13                                                                                                Page 147


  3502                        
  3503                        ; find or make array
  3504                        
  3505                        LAB_1E17
  3506 FF:3812: A5 5E        	LDA	<Defdim		; get DIM flag
  3507 FF:3814: 48           	PHA				; push it
  3508 FF:3815: A5 5F        	LDA	<Dtypef		; get data type flag, $FF=string, $00=numeric
  3509 FF:3817: 48           	PHA				; push it
  3510 FF:3818: A0 00        	LDY	#$00			; clear dimensions count
  3511                        
  3512                        ; now get the array dimension(s) and stack it (them) before the data type and DIM flag
  3513                        
  3514                        LAB_1E1F
  3515 FF:381A: 98           	TYA				; copy dimensions count
  3516 FF:381B: 48           	PHA				; save it
  3517 FF:381C: A5 94        	LDA	<Varnm2		; get array name 2nd byte
  3518 FF:381E: 48           	PHA				; save it
  3519 FF:381F: A5 93        	LDA	<Varnm1		; get array name 1st byte
  3520 FF:3821: 48           	PHA				; save it
  3521 FF:3822: 20 F5 37     	JSR	LAB_EVIN		; evaluate integer expression
  3522 FF:3825: 68           	PLA				; pull array name 1st byte
  3523 FF:3826: 85 93        	STA	<Varnm1		; restore array name 1st byte
  3524 FF:3828: 68           	PLA				; pull array name 2nd byte
  3525 FF:3829: 85 94        	STA	<Varnm2		; restore array name 2nd byte
  3526 FF:382B: 68           	PLA				; pull dimensions count
  3527 FF:382C: A8           	TAY				; restore it
  3528 FF:382D: A3 02        	LDA	2,S			; get DIM flag
  3529 FF:382F: 85 FD        	STA <TEMPW		; push it
  3530 FF:3831: A3 01        	LDA	1,S			; get data type flag
  3531 FF:3833: 85 FE        	STA <TEMPW+1	; push it
  3532 FF:3835: A5 AE        	LDA	<FAC1_2		; get this dimension size high byte
  3533 FF:3837: 83 02        	STA	2,S			; stack before flag bytes
  3534 FF:3839: A5 AF        	LDA	<FAC1_3		; get this dimension size low byte
  3535 FF:383B: 83 01        	STA	1,S			; stack before flag bytes
  3536 FF:383D: A5 FD        	LDA <TEMPW
  3537 FF:383F: 48           	PHA
  3538 FF:3840: A5 FE        	LDA <TEMPW+1
  3539 FF:3842: 48           	PHA
  3540 FF:3843: C8           	INY				; increment dimensions count
  3541 FF:3844: 22 C2 00 00  	JSL	LAB_GBYT		; scan memory
  3542 FF:3848: C9 2C        	CMP	#','			; compare with ","
  3543 FF:384A: F0 CE        	BEQ	LAB_1E1F		; if found go do next dimension
  3544                        
  3545 FF:384C: 84 5D        	STY	<Dimcnt		; store dimensions count
  3546 FF:384E: 20 13 35     	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
  3547 FF:3851: 68           	PLA				; pull data type flag
  3548 FF:3852: 85 5F        	STA	<Dtypef		; restore data type flag, $FF=string, $00=numeric
  3549 FF:3854: 68           	PLA				; pull DIM flag
  3550 FF:3855: 85 5E        	STA	<Defdim		; restore DIM flag
  3551 FF:3857: A6 7D        	LDX	<Sarryl		; get array mem start low byte
  3552 FF:3859: A5 7E        	LDA	<Sarryh		; get array mem start high byte
  3553                        
  3554                        ; now check to see if we are at the end of array memory (we would be if there were
  3555                        ; no arrays).
  3556                        
  3557                        LAB_1E5C
  3558 FF:385B: 86 AA        	STX	<Astrtl		; save as array start pointer low byte
  Sun Nov 21 2021 15:13                                                                                                Page 148


  3559 FF:385D: 85 AB        	STA	<Astrth		; save as array start pointer high byte
  3560 FF:385F: C5 80        	CMP	<Earryh		; compare with array mem end high byte
  3561 FF:3861: D0 04        	BNE	LAB_1E68		; branch if not reached array mem end
  3562                        
  3563 FF:3863: E4 7F        	CPX	<Earryl		; else compare with array mem end low byte
  3564 FF:3865: F0 39        	BEQ	LAB_1EA1		; go build array if not found
  3565                        
  3566                        					; search for array
  3567                        LAB_1E68
  3568 FF:3867: A0 00        	LDY	#$00			; clear index
  3569 FF:3869: B1 AA        	LDA (<Astrtl),Y		; get array name first byte
  3570 FF:386B: C8           	INY				; increment index to second name byte
  3571 FF:386C: C5 93        	CMP	<Varnm1		; compare with this array name first byte
  3572 FF:386E: D0 06        	BNE	LAB_1E77		; branch if no match
  3573                        
  3574 FF:3870: A5 94        	LDA	<Varnm2		; else get this array name second byte
  3575 FF:3872: D1 AA        	CMP (<Astrtl),Y		; compare with array name second byte
  3576 FF:3874: F0 16        	BEQ	LAB_1E8D		; array found so branch
  3577                        
  3578                        					; no match
  3579                        LAB_1E77
  3580 FF:3876: C8           	INY				; increment index
  3581 FF:3877: B1 AA        	LDA (<Astrtl),Y		; get array size low byte
  3582 FF:3879: 18           	CLC				; clear carry for add
  3583 FF:387A: 65 AA        	ADC	<Astrtl		; add array start pointer low byte
  3584 FF:387C: AA           	TAX				; copy low byte to X
  3585 FF:387D: C8           	INY				; increment index
  3586 FF:387E: B1 AA        	LDA (<Astrtl),Y		; get array size high byte
  3587 FF:3880: 65 AB        	ADC	<Astrth		; add array mem pointer high byte
  3588 FF:3882: 90 D7        	BCC	LAB_1E5C		; if no overflow go check next array
  3589                        ; do array bounds error
  3590                        
  3591                        LAB_1E85
  3592 FF:3884: A2 10        	LDX	#$10			; error code $10 ("Array bounds" error)
  3593 FF:3886: 2C           	.byte	$2C			; makes next bit BIT LAB_08A2
  3594                        
  3595                        ; do function call error
  3596                        
  3597                        LAB_FCER
  3598 FF:3887: A2 08        	LDX	#$08			; error code $08 ("Function call" error)
  3599                        LAB_1E8A
  3600 FF:3889: 4C C1 28     	JMP	LAB_XERR		; do error #X, then warm start
  3601                        
  3602                        					; found array, are we trying to dimension it?
  3603                        LAB_1E8D
  3604 FF:388C: A2 12        	LDX	#$12			; set error $12 ("Double dimension" error)
  3605 FF:388E: A5 5E        	LDA	<Defdim		; get DIM flag
  3606 FF:3890: D0 F7        	BNE	LAB_1E8A		; if we are trying to dimension it do error #X, then warm
  3607                        					; start
  3608                        
  3609                        ; found the array and we're not dimensioning it so we must find an element in it
  3610                        
  3611 FF:3892: 20 E4 37     	JSR	LAB_1DE6		; set-up array pointer (<Adatal/h) to first element in array
  3612                        					; (<Astrtl,<Astrth points to start of array)
  3613 FF:3895: A5 5D        	LDA	<Dimcnt		; get dimensions count
  3614 FF:3897: A0 04        	LDY	#$04			; set index to array's # of dimensions
  3615 FF:3899: D1 AA        	CMP (<Astrtl),Y		; compare with no of dimensions
  Sun Nov 21 2021 15:13                                                                                                Page 149


  3616 FF:389B: D0 E7        	BNE	LAB_1E85		; if wrong do array bounds error, could do "Wrong
  3617                        					; dimensions" error here .. if we want a different
  3618                        					; error message
  3619                        
  3620 FF:389D: 4C 23 39     	JMP	LAB_1F28		; found array so go get element
  3621                        					; (could jump to LAB_1F28 as all LAB_1F24 does is take
  3622                        					; <Dimcnt and save it at (<Astrtl),Y which is already the
  3623                        					; same or we would have taken the BNE)
  3624                        
  3625                        					; array not found, so build it
  3626                        LAB_1EA1
  3627 FF:38A0: 20 E4 37     	JSR	LAB_1DE6		; set-up array pointer (<Adatal/h) to first element in array
  3628                        					; (<Astrtl,<Astrth points to start of array)
  3629 FF:38A3: 20 90 28     	JSR	LAB_121F		; check available memory, "Out of memory" error if no room
  3630                        					; addr to check is in AY (low/high)
  3631 FF:38A6: A0 00        	LDY	#$00			; clear Y (don't need to clear A)
  3632 FF:38A8: 84 BB        	STY	<Aspth			; clear array data size high byte
  3633 FF:38AA: A5 93        	LDA	<Varnm1		; get variable name 1st byte
  3634 FF:38AC: 91 AA        	STA (<Astrtl),Y		; save array name 1st byte
  3635 FF:38AE: C8           	INY				; increment index
  3636 FF:38AF: A5 94        	LDA	<Varnm2		; get variable name 2nd byte
  3637 FF:38B1: 91 AA        	STA (<Astrtl),Y		; save array name 2nd byte
  3638 FF:38B3: A5 5D        	LDA	<Dimcnt		; get dimensions count
  3639 FF:38B5: A0 04        	LDY	#$04			; index to dimension count
  3640 FF:38B7: 84 BA        	STY	<Asptl			; set array data size low byte (four bytes per element)
  3641 FF:38B9: 91 AA        	STA (<Astrtl),Y		; set array's dimensions count
  3642                        
  3643                        					; now calculate the size of the data space for the array
  3644 FF:38BB: 18           	CLC				; clear carry for add (clear on subsequent loops)
  3645                        LAB_1EC0
  3646 FF:38BC: A2 0B        	LDX	#$0B			; set default dimension value low byte
  3647 FF:38BE: A9 00        	LDA	#$00			; set default dimension value high byte
  3648 FF:38C0: 24 5E        	BIT	<Defdim		; test default DIM flag
  3649 FF:38C2: 50 07        	BVC	LAB_1ED0		; branch if b6 of <Defdim is clear
  3650                        
  3651 FF:38C4: 68           	PLA				; else pull dimension value low byte
  3652 FF:38C5: 69 01        	ADC	#$01			; +1 (allow for zeroeth element)
  3653 FF:38C7: AA           	TAX				; copy low byte to X
  3654 FF:38C8: 68           	PLA				; pull dimension value high byte
  3655 FF:38C9: 69 00        	ADC	#$00			; add carry from low byte
  3656                        
  3657                        LAB_1ED0
  3658 FF:38CB: C8           	INY				; index to dimension value high byte
  3659 FF:38CC: 91 AA        	STA (<Astrtl),Y		; save dimension value high byte
  3660 FF:38CE: C8           	INY				; index to dimension value high byte
  3661 FF:38CF: 8A           	TXA				; get dimension value low byte
  3662 FF:38D0: 91 AA        	STA (<Astrtl),Y		; save dimension value low byte
  3663 FF:38D2: 20 72 39     	JSR	LAB_1F7C		; does XY = (<Astrtl),Y * (<Asptl)
  3664 FF:38D5: 86 BA        	STX	<Asptl			; save array data size low byte
  3665 FF:38D7: 85 BB        	STA	<Aspth			; save array data size high byte
  3666 FF:38D9: A4 71        	LDY	<ut1_pl		; restore index (saved by subroutine)
  3667 FF:38DB: C6 5D        	DEC	<Dimcnt		; decrement dimensions count
  3668 FF:38DD: D0 DD        	BNE	LAB_1EC0		; loop while not = 0
  3669                        
  3670 FF:38DF: 65 A5        	ADC	<Adatah		; add size high byte to first element high byte
  3671                        					; (carry is always clear here)
  3672 FF:38E1: B0 5D        	BCS	LAB_1F45		; if overflow go do "Out of memory" error
  Sun Nov 21 2021 15:13                                                                                                Page 150


  3673                        
  3674 FF:38E3: 85 A5        	STA	<Adatah		; save end of array high byte
  3675 FF:38E5: A8           	TAY				; copy end high byte to Y
  3676 FF:38E6: 8A           	TXA				; get array size low byte
  3677 FF:38E7: 65 A4        	ADC	<Adatal		; add array start low byte
  3678 FF:38E9: 90 03        	BCC	LAB_1EF3		; branch if no carry
  3679                        
  3680 FF:38EB: C8           	INY				; else increment end of array high byte
  3681 FF:38EC: F0 52        	BEQ	LAB_1F45		; if overflow go do "Out of memory" error
  3682                        
  3683                        					; set-up mostly complete, now zero the array
  3684                        LAB_1EF3
  3685 FF:38EE: 20 90 28     	JSR	LAB_121F		; check available memory, "Out of memory" error if no room
  3686                        					; addr to check is in AY (low/high)
  3687 FF:38F1: 85 7F        	STA	<Earryl		; save array mem end low byte
  3688 FF:38F3: 84 80        	STY	<Earryh		; save array mem end high byte
  3689 FF:38F5: A9 00        	LDA	#$00			; clear byte for array clear
  3690 FF:38F7: E6 BB        	INC	<Aspth			; increment array size high byte (now block count)
  3691 FF:38F9: A4 BA        	LDY	<Asptl			; get array size low byte (now index to block)
  3692 FF:38FB: F0 05        	BEQ	LAB_1F07		; branch if low byte = $00
  3693                        
  3694                        LAB_1F02
  3695 FF:38FD: 88           	DEY				; decrement index (do 0 to n-1)
  3696 FF:38FE: 91 A4        	STA (<Adatal),Y		; zero byte
  3697 FF:3900: D0 FB        	BNE	LAB_1F02		; loop until this block done
  3698                        
  3699                        LAB_1F07
  3700 FF:3902: C6 A5        	DEC	<Adatah		; decrement array pointer high byte
  3701 FF:3904: C6 BB        	DEC	<Aspth			; decrement block count high byte
  3702 FF:3906: D0 F5        	BNE	LAB_1F02		; loop until all blocks done
  3703                        
  3704 FF:3908: E6 A5        	INC	<Adatah		; correct for last loop
  3705 FF:390A: 38           	SEC				; set carry for subtract
  3706 FF:390B: A0 02        	LDY	#$02			; index to array size low byte
  3707 FF:390D: A5 7F        	LDA	<Earryl		; get array mem end low byte
  3708 FF:390F: E5 AA        	SBC	<Astrtl		; subtract array start low byte
  3709 FF:3911: 91 AA        	STA (<Astrtl),Y		; save array size low byte
  3710 FF:3913: C8           	INY				; index to array size high byte
  3711 FF:3914: A5 80        	LDA	<Earryh		; get array mem end high byte
  3712 FF:3916: E5 AB        	SBC	<Astrth		; subtract array start high byte
  3713 FF:3918: 91 AA        	STA (<Astrtl),Y		; save array size high byte
  3714 FF:391A: A5 5E        	LDA	<Defdim		; get default DIM flag
  3715 FF:391C: D0 53        	BNE	LAB_1F7B		; exit (RET) if this was a DIM command
  3716                        					; else, find element
  3717 FF:391E: C8           	INY				; index to # of dimensions
  3718                        
  3719                        LAB_1F24
  3720 FF:391F: B1 AA        	LDA (<Astrtl),Y		; get array's dimension count
  3721 FF:3921: 85 5D        	STA	<Dimcnt		; save it
  3722                        
  3723                        ; we have found, or built, the array. now we need to find the element
  3724                        
  3725                        LAB_1F28
  3726 FF:3923: A9 00        	LDA	#$00			; clear byte
  3727 FF:3925: 85 BA        	STA	<Asptl			; clear array data pointer low byte
  3728                        LAB_1F2C
  3729 FF:3927: 85 BB        	STA	<Aspth			; save array data pointer high byte
  Sun Nov 21 2021 15:13                                                                                                Page 151


  3730 FF:3929: C8           	INY				; increment index (point to array bound high byte)
  3731 FF:392A: 68           	PLA				; pull array index low byte
  3732 FF:392B: AA           	TAX				; copy to X
  3733 FF:392C: 85 AE        	STA	<FAC1_2		; save index low byte to FAC1 mantissa2
  3734 FF:392E: 68           	PLA				; pull array index high byte
  3735 FF:392F: 85 AF        	STA	<FAC1_3		; save index high byte to FAC1 mantissa3
  3736 FF:3931: D1 AA        	CMP (<Astrtl),Y		; compare with array bound high byte
  3737 FF:3933: 90 0E        	BCC	LAB_1F48		; branch if within bounds
  3738                        
  3739 FF:3935: D0 06        	BNE	LAB_1F42		; if outside bounds do array bounds error
  3740                        
  3741                        					; else high byte was = so test low bytes
  3742 FF:3937: C8           	INY				; index to array bound low byte
  3743 FF:3938: 8A           	TXA				; get array index low byte
  3744 FF:3939: D1 AA        	CMP (<Astrtl),Y		; compare with array bound low byte
  3745 FF:393B: 90 07        	BCC	LAB_1F49		; branch if within bounds
  3746                        
  3747                        LAB_1F42
  3748 FF:393D: 4C 84 38     	JMP	LAB_1E85		; else do array bounds error
  3749                        
  3750                        LAB_1F45
  3751 FF:3940: 4C BF 28     	JMP	LAB_OMER		; do "Out of memory" error then warm start
  3752                        
  3753                        LAB_1F48
  3754 FF:3943: C8           	INY				; index to array bound low byte
  3755                        LAB_1F49
  3756 FF:3944: A5 BB        	LDA	<Aspth			; get array data pointer high byte
  3757 FF:3946: 05 BA        	ORA	<Asptl			; OR with array data pointer low byte
  3758 FF:3948: F0 0A        	BEQ	LAB_1F5A		; branch if array data pointer = null (skip multiply)
  3759                        
  3760 FF:394A: 20 72 39     	JSR	LAB_1F7C		; does XY = (<Astrtl),Y * (<Asptl)
  3761 FF:394D: 8A           	TXA				; get result low byte
  3762 FF:394E: 65 AE        	ADC	<FAC1_2		; add index low byte from FAC1 mantissa2
  3763 FF:3950: AA           	TAX				; save result low byte
  3764 FF:3951: 98           	TYA				; get result high byte
  3765 FF:3952: A4 71        	LDY	<ut1_pl		; restore index
  3766                        LAB_1F5A
  3767 FF:3954: 65 AF        	ADC	<FAC1_3		; add index high byte from FAC1 mantissa3
  3768 FF:3956: 86 BA        	STX	<Asptl			; save array data pointer low byte
  3769 FF:3958: C6 5D        	DEC	<Dimcnt		; decrement dimensions count
  3770 FF:395A: D0 CB        	BNE	LAB_1F2C		; loop if dimensions still to do
  3771                        
  3772 FF:395C: 06 BA        	ASL	<Asptl			; array data pointer low byte * 2
  3773 FF:395E: 2A           	ROL	A			; array data pointer high byte * 2
  3774 FF:395F: 06 BA        	ASL	<Asptl			; array data pointer low byte * 4
  3775 FF:3961: 2A           	ROL	A			; array data pointer high byte * 4
  3776 FF:3962: A8           	TAY				; copy high byte
  3777 FF:3963: A5 BA        	LDA	<Asptl			; get low byte
  3778 FF:3965: 65 A4        	ADC	<Adatal		; add array data start pointer low byte
  3779 FF:3967: 85 95        	STA	<Cvaral		; save as current var address low byte
  3780 FF:3969: 98           	TYA				; get high byte back
  3781 FF:396A: 65 A5        	ADC	<Adatah		; add array data start pointer high byte
  3782 FF:396C: 85 96        	STA	<Cvarah		; save as current var address high byte
  3783 FF:396E: A8           	TAY				; copy high byte to Y
  3784 FF:396F: A5 95        	LDA	<Cvaral		; get current var address low byte
  3785                        LAB_1F7B
  3786 FF:3971: 60           	RTS
  Sun Nov 21 2021 15:13                                                                                                Page 152


  3787                        
  3788                        ; does XY = (<Astrtl),Y * (<Asptl)
  3789                        
  3790                        LAB_1F7C
  3791 FF:3972: 84 71        	STY	<ut1_pl		; save index
  3792 FF:3974: B1 AA        	LDA (<Astrtl),Y		; get dimension size low byte
  3793 FF:3976: 85 76        	STA	<dims_l		; save dimension size low byte
  3794 FF:3978: 88           	DEY				; decrement index
  3795 FF:3979: B1 AA        	LDA (<Astrtl),Y		; get dimension size high byte
  3796 FF:397B: 85 77        	STA	<dims_h		; save dimension size high byte
  3797                        
  3798 FF:397D: A9 10        	LDA	#$10			; count = $10 (16 bit multiply)
  3799 FF:397F: 85 A8        	STA	<numbit		; save bit count
  3800 FF:3981: A2 00        	LDX	#$00			; clear result low byte
  3801 FF:3983: A0 00        	LDY	#$00			; clear result high byte
  3802                        LAB_1F8F
  3803 FF:3985: 8A           	TXA				; get result low byte
  3804 FF:3986: 0A           	ASL	A			; *2
  3805 FF:3987: AA           	TAX				; save result low byte
  3806 FF:3988: 98           	TYA				; get result high byte
  3807 FF:3989: 2A           	ROL	A			; *2
  3808 FF:398A: A8           	TAY				; save result high byte
  3809 FF:398B: B0 B3        	BCS	LAB_1F45		; if overflow go do "Out of memory" error
  3810                        
  3811 FF:398D: 06 BA        	ASL	<Asptl			; shift multiplier low byte
  3812 FF:398F: 26 BB        	ROL	<Aspth			; shift multiplier high byte
  3813 FF:3991: 90 11        	BCC	LAB_1FA8		; skip add if no carry
  3814                        
  3815 FF:3993: 18           	CLC				; else clear carry for add
  3816 FF:3994: 8A           	TXA				; get result low byte
  3817 FF:3995: 65 76        	ADC	<dims_l		; add dimension size low byte
  3818 FF:3997: AA           	TAX				; save result low byte
  3819 FF:3998: 98           	TYA				; get result high byte
  3820 FF:3999: 65 77        	ADC	<dims_h		; add dimension size high byte
  3821 FF:399B: A8           	TAY				; save result high byte
  3822 FF:399C: B0 03        	BCS	LAB_1F45_1		; if overflow go do "Out of memory" error
  3823 FF:399E: 4C A4 39     	JMP LAB_1FA8
  3824                        LAB_1F45_1
  3825 FF:39A1: 4C 40 39     	JMP LAB_1F45
  3826                        LAB_1FA8
  3827 FF:39A4: C6 A8        	DEC	<numbit		; decrement bit count
  3828 FF:39A6: D0 DD        	BNE	LAB_1F8F		; loop until all done
  3829                        
  3830 FF:39A8: 60           	RTS
  3831                        
  3832                        ; perform FRE()
  3833                        
  3834                        LAB_FRE
  3835 FF:39A9: A5 5F        	LDA	<Dtypef		; get data type flag, $FF=string, $00=numeric
  3836 FF:39AB: 10 03        	BPL	LAB_1FB4		; branch if numeric
  3837                        
  3838 FF:39AD: 20 15 3E     	JSR	LAB_22B6		; pop string off descriptor stack, or from top of string
  3839                        					; space returns with A = length, X=$71=pointer low byte,
  3840                        					; Y=$72=pointer high byte
  3841                        
  3842                        					; FRE(n) was numeric so do this
  3843                        LAB_1FB4
  Sun Nov 21 2021 15:13                                                                                                Page 153


  3844 FF:39B0: 20 EB 3B     	JSR	LAB_GARB		; go do garbage collection
  3845 FF:39B3: 38           	SEC				; set carry for subtract
  3846 FF:39B4: A5 81        	LDA	<Sstorl		; get bottom of string space low byte
  3847 FF:39B6: E5 7F        	SBC	<Earryl		; subtract array mem end low byte
  3848 FF:39B8: A8           	TAY				; copy result to Y
  3849 FF:39B9: A5 82        	LDA	<Sstorh		; get bottom of string space high byte
  3850 FF:39BB: E5 80        	SBC	<Earryh		; subtract array mem end high byte
  3851                        
  3852                        ; save and convert integer AY to FAC1
  3853                        
  3854                        LAB_AYFC
  3855 FF:39BD: 46 5F        	LSR	<Dtypef		; clear data type flag, $FF=string, $00=numeric
  3856 FF:39BF: 85 AD        	STA	<FAC1_1		; save FAC1 mantissa1
  3857 FF:39C1: 84 AE        	STY	<FAC1_2		; save FAC1 mantissa2
  3858 FF:39C3: A2 90        	LDX	#$90			; set exponent=2^16 (integer)
  3859 FF:39C5: 4C A1 46     	JMP	LAB_27E3		; set exp=X, clear <FAC1_3, normalise and return
  3860                        
  3861                        ; perform POS()
  3862                        
  3863                        LAB_POS
  3864 FF:39C8: A4 0E        	LDY	<TPos			; get terminal position
  3865                        
  3866                        ; convert Y to byte in FAC1
  3867                        
  3868                        LAB_1FD0
  3869 FF:39CA: A9 00        	LDA	#$00			; clear high byte
  3870 FF:39CC: F0 EF        	BEQ	LAB_AYFC		; always save and convert integer AY to FAC1 and return
  3871                        
  3872                        ; check not Direct (used by DEF and INPUT)
  3873                        
  3874                        LAB_CKRN
  3875 FF:39CE: A6 88        	LDX	<Clineh		; get current line high byte
  3876 FF:39D0: E8           	INX				; increment it
  3877 FF:39D1: F0 03        	BEQ LAB_1FD9
  3878 FF:39D3: 4C 71 39     	JMP	LAB_1F7B		; return if can continue not direct mode
  3879                        
  3880                        					; else do illegal direct error
  3881                        LAB_1FD9
  3882 FF:39D6: A2 16        	LDX	#$16			; error code $16 ("Illegal direct" error)
  3883                        LAB_1FDB
  3884 FF:39D8: 4C C1 28     	JMP	LAB_XERR		; go do error #X, then warm start
  3885                        
  3886                        ; perform DEF
  3887                        
  3888                        LAB_DEF
  3889 FF:39DB: 20 0C 3A     	JSR	LAB_200B		; check FNx syntax
  3890 FF:39DE: 85 9C        	STA	<func_l		; save function pointer low byte
  3891 FF:39E0: 84 9D        	STY	<func_h		; save function pointer high byte
  3892 FF:39E2: 20 CE 39     	JSR	LAB_CKRN		; check not Direct (back here if ok)
  3893 FF:39E5: 20 20 35     	JSR	LAB_1BFE		; scan for "(" , else do syntax error then warm start
  3894 FF:39E8: A9 80        	LDA	#$80			; set flag for FNx
  3895 FF:39EA: 85 61        	STA	<Sufnxf		; save subscript/FNx flag
  3896 FF:39EC: 20 FF 36     	JSR	LAB_GVAR		; get (var) address
  3897 FF:39EF: 20 F1 33     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  3898 FF:39F2: 20 13 35     	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
  3899 FF:39F5: A9 D6        	LDA	#TK_EQUAL		; get = token
  3900 FF:39F7: 20 15 35     	JSR	LAB_SCCA		; scan for CHR$(A), else do syntax error then warm start
  Sun Nov 21 2021 15:13                                                                                                Page 154


  3901 FF:39FA: A5 96        	LDA	<Cvarah		; get current var address high byte
  3902 FF:39FC: 48           	PHA				; push it
  3903 FF:39FD: A5 95        	LDA	<Cvaral		; get current var address low byte
  3904 FF:39FF: 48           	PHA				; push it
  3905 FF:3A00: A5 C4        	LDA	<Bpntrh		; get BASIC execute pointer high byte
  3906 FF:3A02: 48           	PHA				; push it
  3907 FF:3A03: A5 C3        	LDA	<Bpntrl		; get BASIC execute pointer low byte
  3908 FF:3A05: 48           	PHA				; push it
  3909 FF:3A06: 20 5B 2E     	JSR	LAB_DATA		; go perform DATA
  3910 FF:3A09: 4C B8 3A     	JMP	LAB_207A		; put execute pointer and variable pointer into function
  3911                        					; and return
  3912                        
  3913                        ; check FNx syntax
  3914                        
  3915                        LAB_200B
  3916 FF:3A0C: A9 C3        	LDA	#TK_FN		; get FN" token
  3917 FF:3A0E: 20 15 35     	JSR	LAB_SCCA		; scan for CHR$(A) , else do syntax error then warm start
  3918                        					; return character after A
  3919 FF:3A11: 09 80        	ORA	#$80			; set FN flag bit
  3920 FF:3A13: 85 61        	STA	<Sufnxf		; save FN flag so array variable test fails
  3921 FF:3A15: 20 07 37     	JSR	LAB_1D12		; search for FN variable
  3922 FF:3A18: 4C F1 33     	JMP	LAB_CTNM		; check if source is numeric and return, else do type
  3923                        					; mismatch
  3924                        
  3925                        					; Evaluate FNx
  3926                        LAB_201E
  3927 FF:3A1B: 20 0C 3A     	JSR	LAB_200B		; check FNx syntax
  3928 FF:3A1E: 48           	PHA				; push function pointer low byte
  3929 FF:3A1F: 98           	TYA				; copy function pointer high byte
  3930 FF:3A20: 48           	PHA				; push function pointer high byte
  3931 FF:3A21: 20 20 35     	JSR	LAB_1BFE		; scan for "(", else do syntax error then warm start
  3932 FF:3A24: 20 02 34     	JSR	LAB_EVEX		; evaluate expression
  3933 FF:3A27: 20 13 35     	JSR	LAB_1BFB		; scan for ")", else do syntax error then warm start
  3934 FF:3A2A: 20 F1 33     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  3935 FF:3A2D: 68           	PLA				; pop function pointer high byte
  3936 FF:3A2E: 85 9D        	STA	<func_h		; restore it
  3937 FF:3A30: 68           	PLA				; pop function pointer low byte
  3938 FF:3A31: 85 9C        	STA	<func_l		; restore it
  3939 FF:3A33: A2 20        	LDX	#$20			; error code $20 ("Undefined function" error)
  3940 FF:3A35: A0 03        	LDY	#$03			; index to variable pointer high byte
  3941 FF:3A37: B1 9C        	LDA (<func_l),Y		; get variable pointer high byte
  3942 FF:3A39: F0 9D        	BEQ	LAB_1FDB		; if zero go do undefined function error
  3943                        
  3944 FF:3A3B: 85 96        	STA	<Cvarah		; save variable address high byte
  3945 FF:3A3D: 88           	DEY				; index to variable address low byte
  3946 FF:3A3E: B1 9C        	LDA (<func_l),Y		; get variable address low byte
  3947 FF:3A40: 85 95        	STA	<Cvaral		; save variable address low byte
  3948 FF:3A42: AA           	TAX				; copy address low byte
  3949                        
  3950                        					; now stack the function variable value before use
  3951 FF:3A43: C8           	INY				; index to mantissa_3
  3952                        LAB_2043
  3953                        	LDAINDIRECTY Cvaral		; get byte from variable
+ 3953 FF:3A44: 8B               PHB
+ 3953 FF:3A45: DA           	PHX
+ 3953 FF:3A46: A2 01            LDX #$01
+ 3953 FF:3A48: B5 95            LDA <Cvaral,X
  Sun Nov 21 2021 15:13                                                                                                Page 155


+ 3953 FF:3A4A: C9 00            CMP #$00
+ 3953 FF:3A4C: D0 04            BNE *+6
+ 3953 FF:3A4E: A2 00        	LDX #00
+ 3953 FF:3A50: DA           	PHX
+ 3953 FF:3A51: AB           	PLB
+ 3953 FF:3A52: FA               PLX
+ 3953 FF:3A53: B1 95        	LDA	(<Cvaral),Y		;
+ 3953 FF:3A55: 85 04            STA <TMPFLG
+ 3953 FF:3A57: AB               PLB
+ 3953 FF:3A58: A5 04            LDA <TMPFLG
  3954 FF:3A5A: 48           	PHA				; stack it
  3955 FF:3A5B: 88           	DEY				; decrement index
  3956 FF:3A5C: 10 E6        	BPL	LAB_2043		; loop until variable stacked
  3957                        
  3958 FF:3A5E: A4 96        	LDY	<Cvarah		; get variable address high byte
  3959 FF:3A60: 20 F6 45     	JSR	LAB_2778		; pack FAC1 (function expression value) into (XY)
  3960                        					; (function variable), return Y=0, always
  3961 FF:3A63: A5 C4        	LDA	<Bpntrh		; get BASIC execute pointer high byte
  3962 FF:3A65: 48           	PHA				; push it
  3963 FF:3A66: A5 C3        	LDA	<Bpntrl		; get BASIC execute pointer low byte
  3964 FF:3A68: 48           	PHA				; push it
  3965                        	LDAINDIRECTY func_l		; get function execute pointer low byte
+ 3965 FF:3A69: 8B               PHB
+ 3965 FF:3A6A: DA           	PHX
+ 3965 FF:3A6B: A2 01            LDX #$01
+ 3965 FF:3A6D: B5 9C            LDA <func_l,X
+ 3965 FF:3A6F: C9 00            CMP #$00
+ 3965 FF:3A71: D0 04            BNE *+6
+ 3965 FF:3A73: A2 00        	LDX #00
+ 3965 FF:3A75: DA           	PHX
+ 3965 FF:3A76: AB           	PLB
+ 3965 FF:3A77: FA               PLX
+ 3965 FF:3A78: B1 9C        	LDA	(<func_l),Y		;
+ 3965 FF:3A7A: 85 04            STA <TMPFLG
+ 3965 FF:3A7C: AB               PLB
+ 3965 FF:3A7D: A5 04            LDA <TMPFLG
  3966 FF:3A7F: 85 C3        	STA	<Bpntrl		; save as BASIC execute pointer low byte
  3967 FF:3A81: C8           	INY				; index to high byte
  3968                        	LDAINDIRECTY func_l		; get function execute pointer high byte
+ 3968 FF:3A82: 8B               PHB
+ 3968 FF:3A83: DA           	PHX
+ 3968 FF:3A84: A2 01            LDX #$01
+ 3968 FF:3A86: B5 9C            LDA <func_l,X
+ 3968 FF:3A88: C9 00            CMP #$00
+ 3968 FF:3A8A: D0 04            BNE *+6
+ 3968 FF:3A8C: A2 00        	LDX #00
+ 3968 FF:3A8E: DA           	PHX
+ 3968 FF:3A8F: AB           	PLB
+ 3968 FF:3A90: FA               PLX
+ 3968 FF:3A91: B1 9C        	LDA	(<func_l),Y		;
+ 3968 FF:3A93: 85 04            STA <TMPFLG
+ 3968 FF:3A95: AB               PLB
+ 3968 FF:3A96: A5 04            LDA <TMPFLG
  3969 FF:3A98: 85 C4        	STA	<Bpntrh		; save as BASIC execute pointer high byte
  3970 FF:3A9A: A5 96        	LDA	<Cvarah		; get variable address high byte
  3971 FF:3A9C: 48           	PHA				; push it
  3972 FF:3A9D: A5 95        	LDA	<Cvaral		; get variable address low byte
  Sun Nov 21 2021 15:13                                                                                                Page 156


  3973 FF:3A9F: 48           	PHA				; push it
  3974 FF:3AA0: 20 EE 33     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
  3975                        					; else do type mismatch
  3976 FF:3AA3: 68           	PLA				; pull variable address low byte
  3977 FF:3AA4: 85 9C        	STA	<func_l		; save variable address low byte
  3978 FF:3AA6: 68           	PLA				; pull variable address high byte
  3979 FF:3AA7: 85 9D        	STA	<func_h		; save variable address high byte
  3980 FF:3AA9: 22 C2 00 00  	JSL	LAB_GBYT		; scan memory
  3981 FF:3AAD: F0 03        	BEQ	LAB_2074		; branch if null (should be [EOL] marker)
  3982                        
  3983 FF:3AAF: 4C 28 35     	JMP	LAB_SNER		; else syntax error then warm start
  3984                        
  3985                        ; restore <Bpntrl,<Bpntrh and function variable from stack
  3986                        
  3987                        LAB_2074
  3988 FF:3AB2: 68           	PLA				; pull BASIC execute pointer low byte
  3989 FF:3AB3: 85 C3        	STA	<Bpntrl		; restore BASIC execute pointer low byte
  3990 FF:3AB5: 68           	PLA				; pull BASIC execute pointer high byte
  3991 FF:3AB6: 85 C4        	STA	<Bpntrh		; restore BASIC execute pointer high byte
  3992                        
  3993                        ; put execute pointer and variable pointer into function
  3994                        
  3995                        LAB_207A
  3996 FF:3AB8: A0 00        	LDY	#$00			; clear index
  3997 FF:3ABA: 68           	PLA				; pull BASIC execute pointer low byte
  3998                        	STAINDIRECTY func_l		; save to function
+ 3998 FF:3ABB: 8B               PHB
+ 3998 FF:3ABC: DA           	PHX
+ 3998 FF:3ABD: 48               PHA
+ 3998 FF:3ABE: A2 01            LDX #$01
+ 3998 FF:3AC0: B5 9C            LDA <func_l,X
+ 3998 FF:3AC2: C9 00            CMP #$00
+ 3998 FF:3AC4: D0 04            BNE *+6
+ 3998 FF:3AC6: A2 00        	LDX #00
+ 3998 FF:3AC8: DA           	PHX
+ 3998 FF:3AC9: AB           	PLB
+ 3998 FF:3ACA: 68               PLA
+ 3998 FF:3ACB: FA               PLX
+ 3998 FF:3ACC: 91 9C        	STA	(<func_l),Y		;
+ 3998 FF:3ACE: AB           	PLB
+ 3998 FF:3ACF: 85 04            STA <TMPFLG
  3999 FF:3AD1: C8           	INY				; increment index
  4000 FF:3AD2: 68           	PLA				; pull BASIC execute pointer high byte
  4001                        	STAINDIRECTY func_l		; save to function
+ 4001 FF:3AD3: 8B               PHB
+ 4001 FF:3AD4: DA           	PHX
+ 4001 FF:3AD5: 48               PHA
+ 4001 FF:3AD6: A2 01            LDX #$01
+ 4001 FF:3AD8: B5 9C            LDA <func_l,X
+ 4001 FF:3ADA: C9 00            CMP #$00
+ 4001 FF:3ADC: D0 04            BNE *+6
+ 4001 FF:3ADE: A2 00        	LDX #00
+ 4001 FF:3AE0: DA           	PHX
+ 4001 FF:3AE1: AB           	PLB
+ 4001 FF:3AE2: 68               PLA
+ 4001 FF:3AE3: FA               PLX
+ 4001 FF:3AE4: 91 9C        	STA	(<func_l),Y		;
  Sun Nov 21 2021 15:13                                                                                                Page 157


+ 4001 FF:3AE6: AB           	PLB
+ 4001 FF:3AE7: 85 04            STA <TMPFLG
  4002 FF:3AE9: C8           	INY				; increment index
  4003 FF:3AEA: 68           	PLA				; pull current var address low byte
  4004                        	STAINDIRECTY func_l		; save to function
+ 4004 FF:3AEB: 8B               PHB
+ 4004 FF:3AEC: DA           	PHX
+ 4004 FF:3AED: 48               PHA
+ 4004 FF:3AEE: A2 01            LDX #$01
+ 4004 FF:3AF0: B5 9C            LDA <func_l,X
+ 4004 FF:3AF2: C9 00            CMP #$00
+ 4004 FF:3AF4: D0 04            BNE *+6
+ 4004 FF:3AF6: A2 00        	LDX #00
+ 4004 FF:3AF8: DA           	PHX
+ 4004 FF:3AF9: AB           	PLB
+ 4004 FF:3AFA: 68               PLA
+ 4004 FF:3AFB: FA               PLX
+ 4004 FF:3AFC: 91 9C        	STA	(<func_l),Y		;
+ 4004 FF:3AFE: AB           	PLB
+ 4004 FF:3AFF: 85 04            STA <TMPFLG
  4005 FF:3B01: C8           	INY				; increment index
  4006 FF:3B02: 68           	PLA				; pull current var address high byte
  4007                        	STAINDIRECTY func_l		; save to function
+ 4007 FF:3B03: 8B               PHB
+ 4007 FF:3B04: DA           	PHX
+ 4007 FF:3B05: 48               PHA
+ 4007 FF:3B06: A2 01            LDX #$01
+ 4007 FF:3B08: B5 9C            LDA <func_l,X
+ 4007 FF:3B0A: C9 00            CMP #$00
+ 4007 FF:3B0C: D0 04            BNE *+6
+ 4007 FF:3B0E: A2 00        	LDX #00
+ 4007 FF:3B10: DA           	PHX
+ 4007 FF:3B11: AB           	PLB
+ 4007 FF:3B12: 68               PLA
+ 4007 FF:3B13: FA               PLX
+ 4007 FF:3B14: 91 9C        	STA	(<func_l),Y		;
+ 4007 FF:3B16: AB           	PLB
+ 4007 FF:3B17: 85 04            STA <TMPFLG
  4008 FF:3B19: 60           	RTS
  4009                        
  4010                        ; perform STR$()
  4011                        
  4012                        LAB_STRS
  4013 FF:3B1A: 20 F1 33     	JSR	LAB_CTNM		; check if source is numeric, else do type mismatch
  4014 FF:3B1D: 20 B6 48     	JSR	LAB_296E		; convert FAC1 to string
  4015 FF:3B20: A9 F0        	LDA	#<Decssp1		; set result string low pointer
  4016 FF:3B22: A0 00        	LDY	#>Decssp1		; set result string high pointer
  4017 FF:3B24: F0 12        	BEQ	LAB_20AE		; print null terminated string to <Sutill/<Sutilh
  4018                        
  4019                        ; Do string vector
  4020                        ; copy <des_pl/h to <des_2l/h and make string space A bytes long
  4021                        
  4022                        LAB_209C
  4023 FF:3B26: A6 AE        	LDX	<des_pl		; get descriptor pointer low byte
  4024 FF:3B28: A4 AF        	LDY	<des_ph		; get descriptor pointer high byte
  4025 FF:3B2A: 86 9E        	STX	<des_2l		; save descriptor pointer low byte
  4026 FF:3B2C: 84 9F        	STY	<des_2h		; save descriptor pointer high byte
  Sun Nov 21 2021 15:13                                                                                                Page 158


  4027                        
  4028                        ; make string space A bytes long
  4029                        ; A=length, X=<Sutill=ptr low byte, Y=<Sutilh=ptr high byte
  4030                        
  4031                        LAB_MSSP
  4032 FF:3B2E: 20 B9 3B     	JSR	LAB_2115		; make space in string memory for string A long
  4033                        					; return X=<Sutill=ptr low byte, Y=<Sutilh=ptr high byte
  4034 FF:3B31: 86 AD        	STX	<str_pl		; save string pointer low byte
  4035 FF:3B33: 84 AE        	STY	<str_ph		; save string pointer high byte
  4036 FF:3B35: 85 AC        	STA	<str_ln		; save length
  4037 FF:3B37: 60           	RTS
  4038                        
  4039                        ; Scan, set up string
  4040                        ; print " terminated string to <Sutill/<Sutilh
  4041                        
  4042                        LAB_20AE
  4043 FF:3B38: A2 22        	LDX	#$22			; set terminator to "
  4044 FF:3B3A: 86 5B        	STX	<Srchc			; set search character (terminator 1)
  4045 FF:3B3C: 86 5C        	STX	<Asrch			; set terminator 2
  4046                        
  4047                        ; print [<Srchc] or [<Asrch] terminated string to <Sutill/<Sutilh
  4048                        ; source is AY
  4049                        
  4050                        LAB_20B4
  4051 FF:3B3E: 85 B8        	STA	<ssptr_l		; store string start low byte
  4052 FF:3B40: 84 B9        	STY	<ssptr_h		; store string start high byte
  4053 FF:3B42: 85 AD        	STA	<str_pl		; save string pointer low byte
  4054 FF:3B44: 84 AE        	STY	<str_ph		; save string pointer high byte
  4055 FF:3B46: A0 FF        	LDY	#$FF			; set length to -1
  4056                        LAB_20BE
  4057 FF:3B48: C8           	INY				; increment length
  4058                        
  4059                        	LDAINDIRECTY ssptr_l		; get byte from string
+ 4059 FF:3B49: 8B               PHB
+ 4059 FF:3B4A: DA           	PHX
+ 4059 FF:3B4B: A2 01            LDX #$01
+ 4059 FF:3B4D: B5 B8            LDA <ssptr_l,X
+ 4059 FF:3B4F: C9 00            CMP #$00
+ 4059 FF:3B51: D0 04            BNE *+6
+ 4059 FF:3B53: A2 00        	LDX #00
+ 4059 FF:3B55: DA           	PHX
+ 4059 FF:3B56: AB           	PLB
+ 4059 FF:3B57: FA               PLX
+ 4059 FF:3B58: B1 B8        	LDA	(<ssptr_l),Y		;
+ 4059 FF:3B5A: 85 04            STA <TMPFLG
+ 4059 FF:3B5C: AB               PLB
+ 4059 FF:3B5D: A5 04            LDA <TMPFLG
  4060 FF:3B5F: C9 00        	CMP #$00
  4061 FF:3B61: F0 0C        	BEQ	LAB_20CF		; exit loop if null byte [EOS]
  4062                        
  4063 FF:3B63: C5 5B        	CMP	<Srchc			; compare with search character (terminator 1)
  4064 FF:3B65: F0 04        	BEQ	LAB_20CB		; branch if terminator
  4065                        
  4066 FF:3B67: C5 5C        	CMP	<Asrch			; compare with terminator 2
  4067 FF:3B69: D0 DD        	BNE	LAB_20BE		; loop if not terminator 2
  4068                        
  4069                        LAB_20CB
  Sun Nov 21 2021 15:13                                                                                                Page 159


  4070 FF:3B6B: C9 22        	CMP	#$22			; compare with "
  4071 FF:3B6D: F0 01        	BEQ	LAB_20D0		; branch if " (carry set if = !)
  4072                        
  4073                        LAB_20CF
  4074 FF:3B6F: 18           	CLC				; clear carry for add (only if [EOL] terminated string)
  4075                        LAB_20D0
  4076 FF:3B70: 84 AC        	STY	<str_ln		; save length in FAC1 exponent
  4077 FF:3B72: 98           	TYA				; copy length to A
  4078 FF:3B73: 65 B8        	ADC	<ssptr_l		; add string start low byte
  4079 FF:3B75: 85 BA        	STA	<Sendl			; save string end low byte
  4080 FF:3B77: A6 B9        	LDX	<ssptr_h		; get string start high byte
  4081 FF:3B79: 90 01        	BCC	LAB_20DC		; branch if no low byte overflow
  4082                        
  4083 FF:3B7B: E8           	INX				; else increment high byte
  4084                        LAB_20DC
  4085 FF:3B7C: 86 BB        	STX	<Sendh			; save string end high byte
  4086 FF:3B7E: A5 B9        	LDA	<ssptr_h		; get string start high byte
  4087                        
  4088                        
  4089                        ; *** begin RAM above code / Ibuff above EhBASIC patch V2 ***
  4090                        ; *** replace
  4091                        ;      CMP	#((BASICBEGIN&$FF00)>>8)  ; compare with BASICBEGIN, FORMERLY (>Ram_base) start 
                    of program memory
  4092                        ;      BCS   LAB_RTST          ; branch if not in utility area
  4093                        ; *** with
  4094 FF:3B80: F0 04              BEQ   LAB_MVST          ; fix STR$() using page zero via LAB_296E
  4095 FF:3B82: C9 21              CMP   #>Ibuffs          ; compare with location of input buffer page
  4096 FF:3B84: D0 0B              BNE   LAB_RTST          ; branch if not in utility area
  4097                        LAB_MVST
  4098                        ; *** end   RAM above code / Ibuff above EhBASIC patch V2 ***
  4099                        
  4100                        
  4101 FF:3B86: 98           	TYA				; copy length to A
  4102 FF:3B87: 20 26 3B     	JSR	LAB_209C		; copy <des_pl/h to <des_2l/h and make string space A bytes
  4103                        					; long
  4104 FF:3B8A: A6 B8        	LDX	<ssptr_l		; get string start low byte
  4105 FF:3B8C: A4 B9        	LDY	<ssptr_h		; get string start high byte
  4106 FF:3B8E: 20 CE 3D     	JSR	LAB_2298		; store string A bytes long from XY to (<Sutill)
  4107                        ; check for space on descriptor stack then ..
  4108                        ; put string address and length on descriptor stack and update stack pointers
  4109                        
  4110                        LAB_RTST
  4111 FF:3B91: A6 65        	LDX	<next_s		; get string stack pointer
  4112 FF:3B93: E0 71        	CPX	#<des_sk+$09		; compare with max+1
  4113 FF:3B95: D0 05        	BNE	LAB_20F8		; branch if space on string stack
  4114                        
  4115                        					; else do string too complex error
  4116 FF:3B97: A2 1C        	LDX	#$1C			; error code $1C ("String too complex" error)
  4117                        LAB_20F5
  4118 FF:3B99: 4C C1 28     	JMP	LAB_XERR		; do error #X, then warm start
  4119                        
  4120                        ; put string address and length on descriptor stack and update stack pointers
  4121                        
  4122                        LAB_20F8
  4123 FF:3B9C: A5 AC        	LDA	<str_ln		; get string length
  4124 FF:3B9E: 95 00        	STA	<PLUS_0,X		; put on string stack
  4125 FF:3BA0: A5 AD        	LDA	<str_pl		; get string pointer low byte
  Sun Nov 21 2021 15:13                                                                                                Page 160


  4126 FF:3BA2: 95 01        	STA	<PLUS_1,X		; put on string stack
  4127 FF:3BA4: A5 AE        	LDA	<str_ph		; get string pointer high byte
  4128 FF:3BA6: 95 02        	STA	<PLUS_2,X		; put on string stack
  4129 FF:3BA8: A0 00        	LDY	#$00			; clear Y
  4130 FF:3BAA: 86 AE        	STX	<des_pl		; save string descriptor pointer low byte
  4131 FF:3BAC: 84 AF        	STY	<des_ph		; save string descriptor pointer high byte (always $00)
  4132 FF:3BAE: 88           	DEY				; Y = $FF
  4133 FF:3BAF: 84 5F        	STY	<Dtypef		; save data type flag, $FF=string
  4134 FF:3BB1: 86 66        	STX	<last_sl		; save old stack pointer (current top item)
  4135 FF:3BB3: E8           	INX				; update stack pointer
  4136 FF:3BB4: E8           	INX				; update stack pointer
  4137 FF:3BB5: E8           	INX				; update stack pointer
  4138 FF:3BB6: 86 65        	STX	<next_s		; save new top item value
  4139 FF:3BB8: 60           	RTS
  4140                        
  4141                        ; Build descriptor
  4142                        ; make space in string memory for string A long
  4143                        ; return X=<Sutill=ptr low byte, Y=<Sutill=ptr high byte
  4144                        
  4145                        LAB_2115
  4146 FF:3BB9: 46 60        	LSR	<Gclctd		; clear garbage collected flag (b7)
  4147                        
  4148                        					; make space for string A long
  4149                        LAB_2117
  4150 FF:3BBB: 48           	PHA				; save string length
  4151 FF:3BBC: 49 FF        	EOR	#$FF			; complement it
  4152 FF:3BBE: 38           	SEC				; set carry for subtract (twos comp add)
  4153 FF:3BBF: 65 81        	ADC	<Sstorl		; add bottom of string space low byte (subtract length)
  4154 FF:3BC1: A4 82        	LDY	<Sstorh		; get bottom of string space high byte
  4155 FF:3BC3: B0 01        	BCS	LAB_2122		; skip decrement if no underflow
  4156                        
  4157 FF:3BC5: 88           	DEY				; decrement bottom of string space high byte
  4158                        LAB_2122
  4159 FF:3BC6: C4 80        	CPY	<Earryh		; compare with array mem end high byte
  4160 FF:3BC8: 90 11        	BCC	LAB_2137		; do out of memory error if less
  4161                        
  4162 FF:3BCA: D0 04        	BNE	LAB_212C		; if not = skip next test
  4163                        
  4164 FF:3BCC: C5 7F        	CMP	<Earryl		; compare with array mem end low byte
  4165 FF:3BCE: 90 0B        	BCC	LAB_2137		; do out of memory error if less
  4166                        
  4167                        LAB_212C
  4168 FF:3BD0: 85 81        	STA	<Sstorl		; save bottom of string space low byte
  4169 FF:3BD2: 84 82        	STY	<Sstorh		; save bottom of string space high byte
  4170 FF:3BD4: 85 83        	STA	<Sutill		; save string utility ptr low byte
  4171 FF:3BD6: 84 84        	STY	<Sutilh		; save string utility ptr high byte
  4172 FF:3BD8: AA           	TAX				; copy low byte to X
  4173 FF:3BD9: 68           	PLA				; get string length back
  4174 FF:3BDA: 60           	RTS
  4175                        
  4176                        LAB_2137
  4177 FF:3BDB: A2 0C        	LDX	#$0C			; error code $0C ("Out of memory" error)
  4178 FF:3BDD: A5 60        	LDA	<Gclctd		; get garbage collected flag
  4179 FF:3BDF: 30 B8        	BMI	LAB_20F5		; if set then do error code X
  4180                        
  4181 FF:3BE1: 20 EB 3B     	JSR	LAB_GARB		; else go do garbage collection
  4182 FF:3BE4: A9 80        	LDA	#$80			; flag for garbage collected
  Sun Nov 21 2021 15:13                                                                                                Page 161


  4183 FF:3BE6: 85 60        	STA	<Gclctd		; set garbage collected flag
  4184 FF:3BE8: 68           	PLA				; pull length
  4185 FF:3BE9: D0 D0        	BNE	LAB_2117		; go try again (loop always, length should never be = $00)
  4186                        
  4187                        ; garbage collection routine
  4188                        
  4189                        LAB_GARB
  4190 FF:3BEB: A6 85        	LDX	<Ememl			; get end of mem low byte
  4191 FF:3BED: A5 86        	LDA	<Ememh			; get end of mem high byte
  4192                        
  4193                        ; re-run routine from last ending
  4194                        
  4195                        LAB_214B
  4196 FF:3BEF: 86 81        	STX	<Sstorl		; set string storage low byte
  4197 FF:3BF1: 85 82        	STA	<Sstorh		; set string storage high byte
  4198 FF:3BF3: A0 00        	LDY	#$00			; clear index
  4199 FF:3BF5: 84 9D        	STY	<garb_h		; clear working pointer high byte (flag no strings to move)
  4200 FF:3BF7: A5 7F        	LDA	<Earryl		; get array mem end low byte
  4201 FF:3BF9: A6 80        	LDX	<Earryh		; get array mem end high byte
  4202 FF:3BFB: 85 AA        	STA	<Histrl		; save as highest string low byte
  4203 FF:3BFD: 86 AB        	STX	<Histrh		; save as highest string high byte
  4204 FF:3BFF: A9 68        	LDA	#<des_sk		; set descriptor stack pointer
  4205 FF:3C01: 85 71        	STA	<ut1_pl		; save descriptor stack pointer low byte
  4206 FF:3C03: 84 72        	STY	<ut1_ph		; save descriptor stack pointer high byte ($00)
  4207                        LAB_2161
  4208 FF:3C05: C5 65        	CMP	<next_s		; compare with descriptor stack pointer
  4209 FF:3C07: F0 05        	BEQ	LAB_216A		; branch if =
  4210                        
  4211 FF:3C09: 20 6F 3C     	JSR	LAB_21D7		; go garbage collect descriptor stack
  4212 FF:3C0C: F0 F7        	BEQ	LAB_2161		; loop always
  4213                        
  4214                        					; done stacked strings, now do string vars
  4215                        LAB_216A
  4216 FF:3C0E: 06 A0        	ASL	<g_step		; set step size = $06
  4217 FF:3C10: A5 7B        	LDA	<Svarl			; get start of vars low byte
  4218 FF:3C12: A6 7C        	LDX	<Svarh			; get start of vars high byte
  4219 FF:3C14: 85 71        	STA	<ut1_pl		; save as pointer low byte
  4220 FF:3C16: 86 72        	STX	<ut1_ph		; save as pointer high byte
  4221                        LAB_2176
  4222 FF:3C18: E4 7E        	CPX	<Sarryh		; compare start of arrays high byte
  4223 FF:3C1A: D0 04        	BNE	LAB_217E		; branch if no high byte match
  4224                        
  4225 FF:3C1C: C5 7D        	CMP	<Sarryl		; else compare start of arrays low byte
  4226 FF:3C1E: F0 05        	BEQ	LAB_2183		; branch if = var mem end
  4227                        
  4228                        LAB_217E
  4229 FF:3C20: 20 69 3C     	JSR	LAB_21D1		; go garbage collect strings
  4230 FF:3C23: F0 F3        	BEQ	LAB_2176		; loop always
  4231                        
  4232                        					; done string vars, now do string arrays
  4233                        LAB_2183
  4234 FF:3C25: 85 A4        	STA	<Nbendl		; save start of arrays low byte as working pointer
  4235 FF:3C27: 86 A5        	STX	<Nbendh		; save start of arrays high byte as working pointer
  4236 FF:3C29: A9 04        	LDA	#$04			; set step size
  4237 FF:3C2B: 85 A0        	STA	<g_step		; save step size
  4238                        LAB_218B
  4239 FF:3C2D: A5 A4        	LDA	<Nbendl		; get pointer low byte
  Sun Nov 21 2021 15:13                                                                                                Page 162


  4240 FF:3C2F: A6 A5        	LDX	<Nbendh		; get pointer high byte
  4241                        LAB_218F
  4242 FF:3C31: E4 80        	CPX	<Earryh		; compare with array mem end high byte
  4243 FF:3C33: D0 04        	BNE	LAB_219A		; branch if not at end
  4244                        
  4245 FF:3C35: C5 7F        	CMP	<Earryl		; else compare with array mem end low byte
  4246 FF:3C37: F0 75        	BEQ	LAB_2216		; tidy up and exit if at end
  4247                        
  4248                        LAB_219A
  4249 FF:3C39: 85 71        	STA	<ut1_pl		; save pointer low byte
  4250 FF:3C3B: 86 72        	STX	<ut1_ph		; save pointer high byte
  4251 FF:3C3D: A0 02        	LDY	#$02			; set index
  4252 FF:3C3F: B1 71        	LDA (<ut1_pl),Y		; get array size low byte
  4253 FF:3C41: 65 A4        	ADC	<Nbendl		; add start of this array low byte
  4254 FF:3C43: 85 A4        	STA	<Nbendl		; save start of next array low byte
  4255 FF:3C45: C8           	INY				; increment index
  4256 FF:3C46: B1 71        	LDA (<ut1_pl),Y		; get array size high byte
  4257 FF:3C48: 65 A5        	ADC	<Nbendh		; add start of this array high byte
  4258 FF:3C4A: 85 A5        	STA	<Nbendh		; save start of next array high byte
  4259 FF:3C4C: A0 01        	LDY	#$01			; set index
  4260 FF:3C4E: B1 71        	LDA (<ut1_pl),Y		; get name second byte
  4261 FF:3C50: 10 DB        	BPL	LAB_218B		; skip if not string array
  4262                        
  4263                        ; was string array so ..
  4264                        
  4265 FF:3C52: A0 04        	LDY	#$04			; set index
  4266 FF:3C54: B1 71        	LDA (<ut1_pl),Y		; get # of dimensions
  4267 FF:3C56: 0A           	ASL	A			; *2
  4268 FF:3C57: 69 05        	ADC	#$05			; +5 (array header size)
  4269 FF:3C59: 20 A1 3C     	JSR	LAB_2208		; go set up for first element
  4270                        LAB_21C4
  4271 FF:3C5C: E4 A5        	CPX	<Nbendh		; compare with start of next array high byte
  4272 FF:3C5E: D0 04        	BNE	LAB_21CC		; branch if <> (go do this array)
  4273                        
  4274 FF:3C60: C5 A4        	CMP	<Nbendl		; else compare element pointer low byte with next array
  4275                        					; low byte
  4276 FF:3C62: F0 CD        	BEQ	LAB_218F		; if equal then go do next array
  4277                        
  4278                        LAB_21CC
  4279 FF:3C64: 20 6F 3C     	JSR	LAB_21D7		; go defrag array strings
  4280 FF:3C67: F0 F3        	BEQ	LAB_21C4		; go do next array string (loop always)
  4281                        
  4282                        ; defrag string variables
  4283                        ; enter with XA = variable pointer
  4284                        ; return with XA = next variable pointer
  4285                        
  4286                        LAB_21D1
  4287 FF:3C69: C8           	INY				; increment index (Y was $00)
  4288 FF:3C6A: B1 71        	LDA (<ut1_pl),Y		; get var name byte 2
  4289 FF:3C6C: 10 30        	BPL	LAB_2206		; if not string, step pointer to next var and return
  4290                        
  4291 FF:3C6E: C8           	INY				; else increment index
  4292                        LAB_21D7
  4293 FF:3C6F: B1 71        	LDA (<ut1_pl),Y		; get string length
  4294 FF:3C71: F0 2B        	BEQ	LAB_2206		; if null, step pointer to next string and return
  4295                        
  4296 FF:3C73: C8           	INY				; else increment index
  Sun Nov 21 2021 15:13                                                                                                Page 163


  4297 FF:3C74: B1 71        	LDA (<ut1_pl),Y		; get string pointer low byte
  4298 FF:3C76: AA           	TAX				; copy to X
  4299 FF:3C77: C8           	INY				; increment index
  4300 FF:3C78: B1 71        	LDA (<ut1_pl),Y		; get string pointer high byte
  4301 FF:3C7A: C5 82        	CMP	<Sstorh		; compare bottom of string space high byte
  4302 FF:3C7C: 90 06        	BCC	LAB_21EC		; branch if less
  4303                        
  4304 FF:3C7E: D0 1E        	BNE	LAB_2206		; if greater, step pointer to next string and return
  4305                        
  4306                        					; high bytes were = so compare low bytes
  4307 FF:3C80: E4 81        	CPX	<Sstorl		; compare bottom of string space low byte
  4308 FF:3C82: B0 1A        	BCS	LAB_2206		; if >=, step pointer to next string and return
  4309                        
  4310                        					; string pointer is < string storage pointer (pos in mem)
  4311                        LAB_21EC
  4312 FF:3C84: C5 AB        	CMP	<Histrh		; compare to highest string high byte
  4313 FF:3C86: 90 17        	BCC	LAB_2207		; if <, step pointer to next string and return
  4314                        
  4315 FF:3C88: D0 04        	BNE	LAB_21F6		; if > update pointers, step to next and return
  4316                        
  4317                        					; high bytes were = so compare low bytes
  4318 FF:3C8A: E4 AA        	CPX	<Histrl		; compare to highest string low byte
  4319 FF:3C8C: 90 11        	BCC	LAB_2207		; if <, step pointer to next string and return
  4320                        
  4321                        					; string is in string memory space
  4322                        LAB_21F6
  4323 FF:3C8E: 86 AA        	STX	<Histrl		; save as new highest string low byte
  4324 FF:3C90: 85 AB        	STA	<Histrh		; save as new highest string high byte
  4325 FF:3C92: A5 71        	LDA	<ut1_pl		; get start of vars(descriptors) low byte
  4326 FF:3C94: A6 72        	LDX	<ut1_ph		; get start of vars(descriptors) high byte
  4327 FF:3C96: 85 9C        	STA	<garb_l		; save as working pointer low byte
  4328 FF:3C98: 86 9D        	STX	<garb_h		; save as working pointer high byte
  4329 FF:3C9A: 88           	DEY				; decrement index DIFFERS
  4330 FF:3C9B: 88           	DEY				; decrement index (should point to descriptor start)
  4331 FF:3C9C: 84 A2        	STY	<g_indx		; save index pointer
  4332                        
  4333                        					; step pointer to next string
  4334                        LAB_2206
  4335 FF:3C9E: 18           	CLC				; clear carry for add
  4336                        LAB_2207
  4337 FF:3C9F: A5 A0        	LDA	<g_step		; get step size
  4338                        LAB_2208
  4339 FF:3CA1: 65 71        	ADC	<ut1_pl		; add pointer low byte
  4340 FF:3CA3: 85 71        	STA	<ut1_pl		; save pointer low byte
  4341 FF:3CA5: 90 02        	BCC	LAB_2211		; branch if no overflow
  4342                        
  4343 FF:3CA7: E6 72        	INC	<ut1_ph		; else increment high byte
  4344                        LAB_2211
  4345 FF:3CA9: A6 72        	LDX	<ut1_ph		; get pointer high byte
  4346 FF:3CAB: A0 00        	LDY	#$00			; clear Y
  4347 FF:3CAD: 60           	RTS
  4348                        
  4349                        ; search complete, now either exit or set-up and move string
  4350                        
  4351                        LAB_2216
  4352 FF:3CAE: C6 A0        	DEC	<g_step		; decrement step size (now $03 for descriptor stack)
  4353 FF:3CB0: A6 9D        	LDX	<garb_h		; get string to move high byte
  Sun Nov 21 2021 15:13                                                                                                Page 164


  4354 FF:3CB2: F0 F5        	BEQ	LAB_2211		; exit if nothing to move
  4355                        
  4356 FF:3CB4: A4 A2        	LDY	<g_indx		; get index byte back (points to descriptor)
  4357 FF:3CB6: 18           	CLC				; clear carry for add
  4358                        	LDAINDIRECTY garb_l		; get string length
+ 4358 FF:3CB7: 8B               PHB
+ 4358 FF:3CB8: DA           	PHX
+ 4358 FF:3CB9: A2 01            LDX #$01
+ 4358 FF:3CBB: B5 9C            LDA <garb_l,X
+ 4358 FF:3CBD: C9 00            CMP #$00
+ 4358 FF:3CBF: D0 04            BNE *+6
+ 4358 FF:3CC1: A2 00        	LDX #00
+ 4358 FF:3CC3: DA           	PHX
+ 4358 FF:3CC4: AB           	PLB
+ 4358 FF:3CC5: FA               PLX
+ 4358 FF:3CC6: B1 9C        	LDA	(<garb_l),Y		;
+ 4358 FF:3CC8: 85 04            STA <TMPFLG
+ 4358 FF:3CCA: AB               PLB
+ 4358 FF:3CCB: A5 04            LDA <TMPFLG
  4359 FF:3CCD: 65 AA        	ADC	<Histrl		; add highest string low byte
  4360 FF:3CCF: 85 A6        	STA	<Obendl		; save old block end low pointer
  4361 FF:3CD1: A5 AB        	LDA	<Histrh		; get highest string high byte
  4362 FF:3CD3: 69 00        	ADC	#$00			; add any carry
  4363 FF:3CD5: 85 A7        	STA	<Obendh		; save old block end high byte
  4364 FF:3CD7: A5 81        	LDA	<Sstorl		; get bottom of string space low byte
  4365 FF:3CD9: A6 82        	LDX	<Sstorh		; get bottom of string space high byte
  4366 FF:3CDB: 85 A4        	STA	<Nbendl		; save new block end low byte
  4367 FF:3CDD: 86 A5        	STX	<Nbendh		; save new block end high byte
  4368 FF:3CDF: 20 ED 27     	JSR	LAB_11D6		; open up space in memory, don't set array end
  4369 FF:3CE2: A4 A2        	LDY	<g_indx		; get index byte
  4370 FF:3CE4: C8           	INY				; point to descriptor low byte
  4371 FF:3CE5: A5 A4        	LDA	<Nbendl		; get string pointer low byte
  4372                        	STAINDIRECTY garb_l		; save new string pointer low byte
+ 4372 FF:3CE7: 8B               PHB
+ 4372 FF:3CE8: DA           	PHX
+ 4372 FF:3CE9: 48               PHA
+ 4372 FF:3CEA: A2 01            LDX #$01
+ 4372 FF:3CEC: B5 9C            LDA <garb_l,X
+ 4372 FF:3CEE: C9 00            CMP #$00
+ 4372 FF:3CF0: D0 04            BNE *+6
+ 4372 FF:3CF2: A2 00        	LDX #00
+ 4372 FF:3CF4: DA           	PHX
+ 4372 FF:3CF5: AB           	PLB
+ 4372 FF:3CF6: 68               PLA
+ 4372 FF:3CF7: FA               PLX
+ 4372 FF:3CF8: 91 9C        	STA	(<garb_l),Y		;
+ 4372 FF:3CFA: AB           	PLB
+ 4372 FF:3CFB: 85 04            STA <TMPFLG
  4373 FF:3CFD: AA           	TAX				; copy string pointer low byte
  4374 FF:3CFE: E6 A5        	INC	<Nbendh		; correct high byte (move sets high byte -1)
  4375 FF:3D00: A5 A5        	LDA	<Nbendh		; get new string pointer high byte
  4376 FF:3D02: C8           	INY				; point to descriptor high byte
  4377                        	STAINDIRECTY garb_l		; save new string pointer high byte
+ 4377 FF:3D03: 8B               PHB
+ 4377 FF:3D04: DA           	PHX
+ 4377 FF:3D05: 48               PHA
+ 4377 FF:3D06: A2 01            LDX #$01
  Sun Nov 21 2021 15:13                                                                                                Page 165


+ 4377 FF:3D08: B5 9C            LDA <garb_l,X
+ 4377 FF:3D0A: C9 00            CMP #$00
+ 4377 FF:3D0C: D0 04            BNE *+6
+ 4377 FF:3D0E: A2 00        	LDX #00
+ 4377 FF:3D10: DA           	PHX
+ 4377 FF:3D11: AB           	PLB
+ 4377 FF:3D12: 68               PLA
+ 4377 FF:3D13: FA               PLX
+ 4377 FF:3D14: 91 9C        	STA	(<garb_l),Y		;
+ 4377 FF:3D16: AB           	PLB
+ 4377 FF:3D17: 85 04            STA <TMPFLG
  4378 FF:3D19: 4C EF 3B     	JMP	LAB_214B		; re-run routine from last ending
  4379                        					; (but don't collect this string)
  4380                        
  4381                        ; concatenate
  4382                        ; add strings, string 1 is in descriptor <des_pl, string 2 is in line
  4383                        
  4384                        LAB_224D
  4385 FF:3D1C: A5 AF        	LDA	<des_ph		; get descriptor pointer high byte
  4386 FF:3D1E: 48           	PHA				; put on stack
  4387 FF:3D1F: A5 AE        	LDA	<des_pl		; get descriptor pointer low byte
  4388 FF:3D21: 48           	PHA				; put on stack
  4389 FF:3D22: 20 F0 34     	JSR	LAB_GVAL		; get value from line
  4390 FF:3D25: 20 F3 33     	JSR	LAB_CTST		; check if source is string, else do type mismatch
  4391 FF:3D28: 68           	PLA				; get descriptor pointer low byte back
  4392 FF:3D29: 85 B8        	STA	<ssptr_l		; set pointer low byte
  4393 FF:3D2B: 68           	PLA				; get descriptor pointer high byte back
  4394 FF:3D2C: 85 B9        	STA	<ssptr_h		; set pointer high byte
  4395 FF:3D2E: A0 00        	LDY	#$00			; clear index
  4396                        	LDAINDIRECTY ssptr_l		; get length_1 from descriptor
+ 4396 FF:3D30: 8B               PHB
+ 4396 FF:3D31: DA           	PHX
+ 4396 FF:3D32: A2 01            LDX #$01
+ 4396 FF:3D34: B5 B8            LDA <ssptr_l,X
+ 4396 FF:3D36: C9 00            CMP #$00
+ 4396 FF:3D38: D0 04            BNE *+6
+ 4396 FF:3D3A: A2 00        	LDX #00
+ 4396 FF:3D3C: DA           	PHX
+ 4396 FF:3D3D: AB           	PLB
+ 4396 FF:3D3E: FA               PLX
+ 4396 FF:3D3F: B1 B8        	LDA	(<ssptr_l),Y		;
+ 4396 FF:3D41: 85 04            STA <TMPFLG
+ 4396 FF:3D43: AB               PLB
+ 4396 FF:3D44: A5 04            LDA <TMPFLG
  4397 FF:3D46: 18           	CLC				; clear carry for add
  4398                        	ADCINDIRECTY des_pl		; add length_2
+ 4398 FF:3D47: 8B               PHB
+ 4398 FF:3D48: 48               PHA
+ 4398 FF:3D49: DA               PHX
+ 4398 FF:3D4A: A2 01            LDX #$01
+ 4398 FF:3D4C: B5 AE            LDA <des_pl,X
+ 4398 FF:3D4E: C9 00            CMP #$00
+ 4398 FF:3D50: D0 04            BNE *+6
+ 4398 FF:3D52: A2 00        	LDX #00
+ 4398 FF:3D54: DA           	PHX
+ 4398 FF:3D55: AB           	PLB
+ 4398 FF:3D56: FA               PLX
  Sun Nov 21 2021 15:13                                                                                                Page 166


+ 4398 FF:3D57: B1 AE            LDA	(<des_pl),Y		;
+ 4398 FF:3D59: 85 04            STA <TMPFLG
+ 4398 FF:3D5B: 68               PLA
+ 4398 FF:3D5C: AB               PLB
+ 4398 FF:3D5D: 18               CLC
+ 4398 FF:3D5E: 65 04            ADC	<TMPFLG 		;
  4399 FF:3D60: 90 05        	BCC	LAB_226D		; branch if no overflow
  4400                        
  4401 FF:3D62: A2 1A        	LDX	#$1A			; else set error code $1A ("String too long" error)
  4402 FF:3D64: 4C C1 28     	JMP	LAB_XERR		; do error #X, then warm start
  4403                        
  4404                        LAB_226D
  4405 FF:3D67: 20 26 3B     	JSR	LAB_209C		; copy <des_pl/h to <des_2l/h and make string space A bytes
  4406                        					; long
  4407 FF:3D6A: 20 84 3D     	JSR	LAB_228A		; copy string from descriptor (<sdescr) to (<Sutill)
  4408 FF:3D6D: A5 9E        	LDA	<des_2l		; get descriptor pointer low byte
  4409 FF:3D6F: A4 9F        	LDY	<des_2h		; get descriptor pointer high byte
  4410 FF:3D71: 20 19 3E     	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
  4411                        					; returns with A = length, <ut1_pl = pointer low byte,
  4412                        					; <ut1_ph = pointer high byte
  4413 FF:3D74: 20 D2 3D     	JSR	LAB_229C		; store string A bytes long from (<ut1_pl) to (<Sutill)
  4414 FF:3D77: A5 B8        	LDA	<ssptr_l		;.set descriptor pointer low byte
  4415 FF:3D79: A4 B9        	LDY	<ssptr_h		;.set descriptor pointer high byte
  4416 FF:3D7B: 20 19 3E     	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
  4417                        					; returns with A = length, X=<ut1_pl=pointer low byte,
  4418                        					; Y=<ut1_ph=pointer high byte
  4419 FF:3D7E: 20 91 3B     	JSR	LAB_RTST		; check for space on descriptor stack then put string
  4420                        					; address and length on descriptor stack and update stack
  4421                        					; pointers
  4422 FF:3D81: 4C 19 34     	JMP	LAB_1ADB		;.continue evaluation
  4423                        
  4424                        ; copy string from descriptor (<sdescr) to (<Sutill)
  4425                        
  4426                        LAB_228A
  4427 FF:3D84: A0 00        	LDY	#$00			; clear index
  4428                        	LDAINDIRECTY sdescr		; get string length
+ 4428 FF:3D86: 8B               PHB
+ 4428 FF:3D87: DA           	PHX
+ 4428 FF:3D88: A2 01            LDX #$01
+ 4428 FF:3D8A: B5 B8            LDA <sdescr,X
+ 4428 FF:3D8C: C9 00            CMP #$00
+ 4428 FF:3D8E: D0 04            BNE *+6
+ 4428 FF:3D90: A2 00        	LDX #00
+ 4428 FF:3D92: DA           	PHX
+ 4428 FF:3D93: AB           	PLB
+ 4428 FF:3D94: FA               PLX
+ 4428 FF:3D95: B1 B8        	LDA	(<sdescr),Y		;
+ 4428 FF:3D97: 85 04            STA <TMPFLG
+ 4428 FF:3D99: AB               PLB
+ 4428 FF:3D9A: A5 04            LDA <TMPFLG
  4429 FF:3D9C: 48           	PHA				; save on stack
  4430 FF:3D9D: C8           	INY				; increment index
  4431                        	LDAINDIRECTY sdescr		; get source string pointer low byte
+ 4431 FF:3D9E: 8B               PHB
+ 4431 FF:3D9F: DA           	PHX
+ 4431 FF:3DA0: A2 01            LDX #$01
+ 4431 FF:3DA2: B5 B8            LDA <sdescr,X
  Sun Nov 21 2021 15:13                                                                                                Page 167


+ 4431 FF:3DA4: C9 00            CMP #$00
+ 4431 FF:3DA6: D0 04            BNE *+6
+ 4431 FF:3DA8: A2 00        	LDX #00
+ 4431 FF:3DAA: DA           	PHX
+ 4431 FF:3DAB: AB           	PLB
+ 4431 FF:3DAC: FA               PLX
+ 4431 FF:3DAD: B1 B8        	LDA	(<sdescr),Y		;
+ 4431 FF:3DAF: 85 04            STA <TMPFLG
+ 4431 FF:3DB1: AB               PLB
+ 4431 FF:3DB2: A5 04            LDA <TMPFLG
  4432 FF:3DB4: AA           	TAX				; copy to X
  4433 FF:3DB5: C8           	INY				; increment index
  4434                        	LDAINDIRECTY sdescr		; get source string pointer high byte
+ 4434 FF:3DB6: 8B               PHB
+ 4434 FF:3DB7: DA           	PHX
+ 4434 FF:3DB8: A2 01            LDX #$01
+ 4434 FF:3DBA: B5 B8            LDA <sdescr,X
+ 4434 FF:3DBC: C9 00            CMP #$00
+ 4434 FF:3DBE: D0 04            BNE *+6
+ 4434 FF:3DC0: A2 00        	LDX #00
+ 4434 FF:3DC2: DA           	PHX
+ 4434 FF:3DC3: AB           	PLB
+ 4434 FF:3DC4: FA               PLX
+ 4434 FF:3DC5: B1 B8        	LDA	(<sdescr),Y		;
+ 4434 FF:3DC7: 85 04            STA <TMPFLG
+ 4434 FF:3DC9: AB               PLB
+ 4434 FF:3DCA: A5 04            LDA <TMPFLG
  4435 FF:3DCC: A8           	TAY				; copy to Y
  4436 FF:3DCD: 68           	PLA				; get length back
  4437                        
  4438                        ; store string A bytes long from YX to (<Sutill)
  4439                        
  4440                        LAB_2298
  4441 FF:3DCE: 86 71        	STX	<ut1_pl		; save source string pointer low byte
  4442 FF:3DD0: 84 72        	STY	<ut1_ph		; save source string pointer high byte
  4443                        
  4444                        ; store string A bytes long from (<ut1_pl) to (<Sutill)
  4445                        
  4446                        LAB_229C
  4447 FF:3DD2: AA           	TAX				; copy length to index (don't count with Y)
  4448 FF:3DD3: F0 3C        	BEQ	LAB_22B2		; branch if = $0 (null string) no need to add zero length
  4449                        
  4450 FF:3DD5: A0 00        	LDY	#$00			; zero pointer (copy forward)
  4451                        LAB_22A0
  4452                        	LDAINDIRECTY ut1_pl		; get source byte
+ 4452 FF:3DD7: 8B               PHB
+ 4452 FF:3DD8: DA           	PHX
+ 4452 FF:3DD9: A2 01            LDX #$01
+ 4452 FF:3DDB: B5 71            LDA <ut1_pl,X
+ 4452 FF:3DDD: C9 00            CMP #$00
+ 4452 FF:3DDF: D0 04            BNE *+6
+ 4452 FF:3DE1: A2 00        	LDX #00
+ 4452 FF:3DE3: DA           	PHX
+ 4452 FF:3DE4: AB           	PLB
+ 4452 FF:3DE5: FA               PLX
+ 4452 FF:3DE6: B1 71        	LDA	(<ut1_pl),Y		;
+ 4452 FF:3DE8: 85 04            STA <TMPFLG
  Sun Nov 21 2021 15:13                                                                                                Page 168


+ 4452 FF:3DEA: AB               PLB
+ 4452 FF:3DEB: A5 04            LDA <TMPFLG
  4453                        	STAINDIRECTY Sutill		; save destination byte
+ 4453 FF:3DED: 8B               PHB
+ 4453 FF:3DEE: DA           	PHX
+ 4453 FF:3DEF: 48               PHA
+ 4453 FF:3DF0: A2 01            LDX #$01
+ 4453 FF:3DF2: B5 83            LDA <Sutill,X
+ 4453 FF:3DF4: C9 00            CMP #$00
+ 4453 FF:3DF6: D0 04            BNE *+6
+ 4453 FF:3DF8: A2 00        	LDX #00
+ 4453 FF:3DFA: DA           	PHX
+ 4453 FF:3DFB: AB           	PLB
+ 4453 FF:3DFC: 68               PLA
+ 4453 FF:3DFD: FA               PLX
+ 4453 FF:3DFE: 91 83        	STA	(<Sutill),Y		;
+ 4453 FF:3E00: AB           	PLB
+ 4453 FF:3E01: 85 04            STA <TMPFLG
  4454                        
  4455 FF:3E03: C8           	INY				; increment index
  4456 FF:3E04: CA           	DEX				; decrement counter
  4457 FF:3E05: D0 D0        	BNE	LAB_22A0		; loop while <> 0
  4458                        
  4459 FF:3E07: 98           	TYA				; restore length from Y
  4460                        LAB_22A9
  4461 FF:3E08: 18           	CLC				; clear carry for add
  4462 FF:3E09: 65 83        	ADC	<Sutill		; add string utility ptr low byte
  4463 FF:3E0B: 85 83        	STA	<Sutill		; save string utility ptr low byte
  4464 FF:3E0D: 90 02        	BCC	LAB_22B2		; branch if no carry
  4465                        
  4466 FF:3E0F: E6 84        	INC	<Sutilh		; else increment string utility ptr high byte
  4467                        LAB_22B2
  4468 FF:3E11: 60           	RTS
  4469                        
  4470                        ; evaluate string
  4471                        
  4472                        LAB_EVST
  4473 FF:3E12: 20 F3 33     	JSR	LAB_CTST		; check if source is string, else do type mismatch
  4474                        
  4475                        ; pop string off descriptor stack, or from top of string space
  4476                        ; returns with A = length, X=pointer low byte, Y=pointer high byte
  4477                        
  4478                        LAB_22B6
  4479 FF:3E15: A5 AE        	LDA	<des_pl		; get descriptor pointer low byte
  4480 FF:3E17: A4 AF        	LDY	<des_ph		; get descriptor pointer high byte
  4481                        
  4482                        ; pop (YA) descriptor off stack or from top of string space
  4483                        ; returns with A = length, X=<ut1_pl=pointer low byte, Y=<ut1_ph=pointer high byte
  4484                        
  4485                        LAB_22BA
  4486 FF:3E19: 85 71        	STA	<ut1_pl		; save descriptor pointer low byte
  4487 FF:3E1B: 84 72        	STY	<ut1_ph		; save descriptor pointer high byte
  4488 FF:3E1D: 20 86 3E     	JSR	LAB_22EB	; clean descriptor stack, YA = pointer
  4489 FF:3E20: 08           	PHP				; save status flags
  4490 FF:3E21: A0 00        	LDY	#$00		; clear index
  4491                        	LDAINDIRECTY ut1_pl		; get length from string descriptor
+ 4491 FF:3E23: 8B               PHB
  Sun Nov 21 2021 15:13                                                                                                Page 169


+ 4491 FF:3E24: DA           	PHX
+ 4491 FF:3E25: A2 01            LDX #$01
+ 4491 FF:3E27: B5 71            LDA <ut1_pl,X
+ 4491 FF:3E29: C9 00            CMP #$00
+ 4491 FF:3E2B: D0 04            BNE *+6
+ 4491 FF:3E2D: A2 00        	LDX #00
+ 4491 FF:3E2F: DA           	PHX
+ 4491 FF:3E30: AB           	PLB
+ 4491 FF:3E31: FA               PLX
+ 4491 FF:3E32: B1 71        	LDA	(<ut1_pl),Y		;
+ 4491 FF:3E34: 85 04            STA <TMPFLG
+ 4491 FF:3E36: AB               PLB
+ 4491 FF:3E37: A5 04            LDA <TMPFLG
  4492 FF:3E39: 48           	PHA				; put on stack
  4493 FF:3E3A: C8           	INY				; increment index
  4494                        	LDAINDIRECTY ut1_pl		; get string pointer low byte from descriptor
+ 4494 FF:3E3B: 8B               PHB
+ 4494 FF:3E3C: DA           	PHX
+ 4494 FF:3E3D: A2 01            LDX #$01
+ 4494 FF:3E3F: B5 71            LDA <ut1_pl,X
+ 4494 FF:3E41: C9 00            CMP #$00
+ 4494 FF:3E43: D0 04            BNE *+6
+ 4494 FF:3E45: A2 00        	LDX #00
+ 4494 FF:3E47: DA           	PHX
+ 4494 FF:3E48: AB           	PLB
+ 4494 FF:3E49: FA               PLX
+ 4494 FF:3E4A: B1 71        	LDA	(<ut1_pl),Y		;
+ 4494 FF:3E4C: 85 04            STA <TMPFLG
+ 4494 FF:3E4E: AB               PLB
+ 4494 FF:3E4F: A5 04            LDA <TMPFLG
  4495 FF:3E51: AA           	TAX				; copy to X
  4496 FF:3E52: C8           	INY				; increment index
  4497                        	LDAINDIRECTY ut1_pl		; get string pointer high byte from descriptor
+ 4497 FF:3E53: 8B               PHB
+ 4497 FF:3E54: DA           	PHX
+ 4497 FF:3E55: A2 01            LDX #$01
+ 4497 FF:3E57: B5 71            LDA <ut1_pl,X
+ 4497 FF:3E59: C9 00            CMP #$00
+ 4497 FF:3E5B: D0 04            BNE *+6
+ 4497 FF:3E5D: A2 00        	LDX #00
+ 4497 FF:3E5F: DA           	PHX
+ 4497 FF:3E60: AB           	PLB
+ 4497 FF:3E61: FA               PLX
+ 4497 FF:3E62: B1 71        	LDA	(<ut1_pl),Y		;
+ 4497 FF:3E64: 85 04            STA <TMPFLG
+ 4497 FF:3E66: AB               PLB
+ 4497 FF:3E67: A5 04            LDA <TMPFLG
  4498 FF:3E69: A8           	TAY				; copy to Y
  4499 FF:3E6A: 68           	PLA				; get string length back
  4500 FF:3E6B: 28           	PLP				; restore status
  4501 FF:3E6C: D0 13        	BNE	LAB_22E6		; branch if pointer <> <last_sl,<last_sh
  4502                        
  4503 FF:3E6E: C4 82        	CPY	<Sstorh		; compare bottom of string space high byte
  4504 FF:3E70: D0 0F        	BNE	LAB_22E6		; branch if <>
  4505                        
  4506 FF:3E72: E4 81        	CPX	<Sstorl		; else compare bottom of string space low byte
  4507 FF:3E74: D0 0B        	BNE	LAB_22E6		; branch if <>
  Sun Nov 21 2021 15:13                                                                                                Page 170


  4508                        
  4509 FF:3E76: 48           	PHA				; save string length
  4510 FF:3E77: 18           	CLC				; clear carry for add
  4511 FF:3E78: 65 81        	ADC	<Sstorl		; add bottom of string space low byte
  4512 FF:3E7A: 85 81        	STA	<Sstorl		; save bottom of string space low byte
  4513 FF:3E7C: 90 02        	BCC	LAB_22E5		; skip increment if no overflow
  4514                        
  4515 FF:3E7E: E6 82        	INC	<Sstorh		; increment bottom of string space high byte
  4516                        LAB_22E5
  4517 FF:3E80: 68           	PLA				; restore string length
  4518                        LAB_22E6
  4519 FF:3E81: 86 71        	STX	<ut1_pl		; save string pointer low byte
  4520 FF:3E83: 84 72        	STY	<ut1_ph		; save string pointer high byte
  4521 FF:3E85: 60           	RTS
  4522                        
  4523                        ; clean descriptor stack, YA = pointer
  4524                        ; checks if AY is on the descriptor stack, if so does a stack discard
  4525                        
  4526                        LAB_22EB
  4527 FF:3E86: C4 67        	CPY	<last_sh		; compare pointer high byte
  4528 FF:3E88: D0 0C        	BNE	LAB_22FB		; exit if <>
  4529                        
  4530 FF:3E8A: C5 66        	CMP	<last_sl		; compare pointer low byte
  4531 FF:3E8C: D0 08        	BNE	LAB_22FB		; exit if <>
  4532                        
  4533 FF:3E8E: 85 65        	STA	<next_s		; save descriptor stack pointer
  4534 FF:3E90: E9 03        	SBC	#$03			; -3
  4535 FF:3E92: 85 66        	STA	<last_sl		; save low byte -3
  4536 FF:3E94: A0 00        	LDY	#$00			; clear high byte
  4537                        LAB_22FB
  4538 FF:3E96: 60           	RTS
  4539                        
  4540                        ; perform CHR$()
  4541                        
  4542                        LAB_CHRS
  4543 FF:3E97: 20 A1 40     	JSR	LAB_EVBY		; evaluate byte expression, result in X
  4544 FF:3E9A: 8A           	TXA				; copy to A
  4545 FF:3E9B: 48           	PHA				; save character
  4546 FF:3E9C: A9 01        	LDA	#$01			; string is single byte
  4547 FF:3E9E: 20 2E 3B     	JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
  4548                        					; X=$AD=<Sutill=ptr low byte, Y=$AE=<Sutilh=ptr high byte
  4549 FF:3EA1: 68           	PLA				; get character back
  4550 FF:3EA2: A0 00        	LDY	#$00			; clear index
  4551                        	STAINDIRECTY str_pl		; save byte in string (byte IS string!)
+ 4551 FF:3EA4: 8B               PHB
+ 4551 FF:3EA5: DA           	PHX
+ 4551 FF:3EA6: 48               PHA
+ 4551 FF:3EA7: A2 01            LDX #$01
+ 4551 FF:3EA9: B5 AD            LDA <str_pl,X
+ 4551 FF:3EAB: C9 00            CMP #$00
+ 4551 FF:3EAD: D0 04            BNE *+6
+ 4551 FF:3EAF: A2 00        	LDX #00
+ 4551 FF:3EB1: DA           	PHX
+ 4551 FF:3EB2: AB           	PLB
+ 4551 FF:3EB3: 68               PLA
+ 4551 FF:3EB4: FA               PLX
+ 4551 FF:3EB5: 91 AD        	STA	(<str_pl),Y		;
  Sun Nov 21 2021 15:13                                                                                                Page 171


+ 4551 FF:3EB7: AB           	PLB
+ 4551 FF:3EB8: 85 04            STA <TMPFLG
  4552 FF:3EBA: 4C 91 3B     	JMP	LAB_RTST		; check for space on descriptor stack then put string
  4553                        					; address and length on descriptor stack and update stack
  4554                        					; pointers
  4555                        
  4556                        ; perform LEFT$()
  4557                        
  4558                        LAB_LEFT
  4559 FF:3EBD: 48           	PHA				; push byte parameter
  4560 FF:3EBE: 20 75 3F     	JSR	LAB_236F		; pull string data and byte parameter from stack
  4561                        					; return pointer in <des_2l/h, byte in A (and X), Y=0
  4562                        	CMPINDIRECTY des_2l		; compare byte parameter with string length
+ 4562 FF:3EC1: 8B               PHB
+ 4562 FF:3EC2: 48               PHA
+ 4562 FF:3EC3: DA               PHX
+ 4562 FF:3EC4: A2 01            LDX #$01
+ 4562 FF:3EC6: B5 9E            LDA <des_2l,X
+ 4562 FF:3EC8: C9 00            CMP #$00
+ 4562 FF:3ECA: D0 04            BNE *+6
+ 4562 FF:3ECC: A2 00        	LDX #00
+ 4562 FF:3ECE: DA           	PHX
+ 4562 FF:3ECF: AB           	PLB
+ 4562 FF:3ED0: FA               PLX
+ 4562 FF:3ED1: B1 9E            LDA	(<des_2l),Y		;
+ 4562 FF:3ED3: 85 04            STA <TMPFLG
+ 4562 FF:3ED5: 68               PLA
+ 4562 FF:3ED6: AB               PLB
+ 4562 FF:3ED7: C5 04            CMP	<TMPFLG		    ;
  4563 FF:3ED9: 98           	TYA				; clear A
  4564 FF:3EDA: F0 1F        	BEQ	LAB_2316		; go do string copy (branch always)
  4565                        
  4566                        ; perform RIGHT$()
  4567                        
  4568                        LAB_RIGHT
  4569 FF:3EDC: 48           	PHA				; push byte parameter
  4570 FF:3EDD: 20 75 3F     	JSR	LAB_236F		; pull string data and byte parameter from stack
  4571                        					; return pointer in <des_2l/h, byte in A (and X), Y=0
  4572                        	FETCHINDIRECTY des_2l		; subtract string length
+ 4572 FF:3EE0: 8B               PHB
+ 4572 FF:3EE1: 48           	PHA
+ 4572 FF:3EE2: DA               PHX
+ 4572 FF:3EE3: A2 01            LDX #$01
+ 4572 FF:3EE5: B5 9E            LDA <des_2l,X
+ 4572 FF:3EE7: C9 00            CMP #$00
+ 4572 FF:3EE9: D0 04            BNE *+6
+ 4572 FF:3EEB: A2 00        	LDX #00
+ 4572 FF:3EED: DA           	PHX
+ 4572 FF:3EEE: AB           	PLB
+ 4572 FF:3EEF: FA               PLX
+ 4572 FF:3EF0: B1 9E            LDA	(<des_2l),Y		;
+ 4572 FF:3EF2: 85 04            STA <TMPFLG
+ 4572 FF:3EF4: 68               PLA
+ 4572 FF:3EF5: AB               PLB
  4573 FF:3EF6: 18           	CLC				; clear carry for add-1
  4574 FF:3EF7: E5 04        	SBC	<TMPFLG		; REDO SBC WITH CARRY CLEARED (ARTIFACT FROM 816 CONVERSION)
  4575 FF:3EF9: 49 FF        	EOR	#$FF			; invert it (A=LEN(expression$)-l)
  Sun Nov 21 2021 15:13                                                                                                Page 172


  4576                        
  4577                        LAB_2316
  4578 FF:3EFB: 90 18        	BCC	LAB_231C		; branch if string length > byte parameter
  4579                        
  4580                        	LDAINDIRECTY des_2l		; else make parameter = length
+ 4580 FF:3EFD: 8B               PHB
+ 4580 FF:3EFE: DA           	PHX
+ 4580 FF:3EFF: A2 01            LDX #$01
+ 4580 FF:3F01: B5 9E            LDA <des_2l,X
+ 4580 FF:3F03: C9 00            CMP #$00
+ 4580 FF:3F05: D0 04            BNE *+6
+ 4580 FF:3F07: A2 00        	LDX #00
+ 4580 FF:3F09: DA           	PHX
+ 4580 FF:3F0A: AB           	PLB
+ 4580 FF:3F0B: FA               PLX
+ 4580 FF:3F0C: B1 9E        	LDA	(<des_2l),Y		;
+ 4580 FF:3F0E: 85 04            STA <TMPFLG
+ 4580 FF:3F10: AB               PLB
+ 4580 FF:3F11: A5 04            LDA <TMPFLG
  4581 FF:3F13: AA           	TAX				; copy to byte parameter copy
  4582 FF:3F14: 98           	TYA				; clear string start offset
  4583                        LAB_231C
  4584 FF:3F15: 48           	PHA				; save string start offset
  4585                        LAB_231D
  4586 FF:3F16: 8A           	TXA				; copy byte parameter (or string length if <)
  4587                        LAB_231E
  4588 FF:3F17: 48           	PHA				; save string length
  4589 FF:3F18: 20 2E 3B     	JSR	LAB_MSSP		; make string space A bytes long A=$AC=length,
  4590                        					; X=$AD=<Sutill=ptr low byte, Y=$AE=<Sutilh=ptr high byte
  4591 FF:3F1B: A5 9E        	LDA	<des_2l		; get descriptor pointer low byte
  4592 FF:3F1D: A4 9F        	LDY	<des_2h		; get descriptor pointer high byte
  4593 FF:3F1F: 20 19 3E     	JSR	LAB_22BA		; pop (YA) descriptor off stack or from top of string space
  4594                        					; returns with A = length, X=<ut1_pl=pointer low byte,
  4595                        					; Y=<ut1_ph=pointer high byte
  4596 FF:3F22: 68           	PLA				; get string length back
  4597 FF:3F23: A8           	TAY				; copy length to Y
  4598 FF:3F24: 68           	PLA				; get string start offset back
  4599 FF:3F25: 18           	CLC				; clear carry for add
  4600 FF:3F26: 65 71        	ADC	<ut1_pl		; add start offset to string start pointer low byte
  4601 FF:3F28: 85 71        	STA	<ut1_pl		; save string start pointer low byte
  4602 FF:3F2A: 90 02        	BCC	LAB_2335		; branch if no overflow
  4603                        
  4604 FF:3F2C: E6 72        	INC	<ut1_ph		; else increment string start pointer high byte
  4605                        LAB_2335
  4606 FF:3F2E: 98           	TYA				; copy length to A
  4607 FF:3F2F: 20 D2 3D     	JSR	LAB_229C		; store string A bytes long from (<ut1_pl) to (<Sutill)
  4608 FF:3F32: 4C 91 3B     	JMP	LAB_RTST		; check for space on descriptor stack then put string
  4609                        					; address and length on descriptor stack and update stack
  4610                        					; pointers
  4611                        
  4612                        ; perform MID$()
  4613                        
  4614                        LAB_MIDS
  4615 FF:3F35: 48           	PHA				; push byte parameter
  4616 FF:3F36: A9 FF        	LDA	#$FF			; set default length = 255
  4617 FF:3F38: 85 AF        	STA	<mids_l		; save default length
  4618 FF:3F3A: 22 C2 00 00  	JSL	LAB_GBYT		; scan memory
  Sun Nov 21 2021 15:13                                                                                                Page 173


  4619 FF:3F3E: C9 29        	CMP	#')'			; compare with ")"
  4620 FF:3F40: F0 06        	BEQ	LAB_2358		; branch if = ")" (skip second byte get)
  4621                        
  4622 FF:3F42: 20 24 35     	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
  4623 FF:3F45: 20 9E 40     	JSR	LAB_GTBY		; get byte parameter (use copy in <mids_l)
  4624                        LAB_2358
  4625 FF:3F48: 20 75 3F     	JSR	LAB_236F		; pull string data and byte parameter from stack
  4626                        					; return pointer in <des_2l/h, byte in A (and X), Y=0
  4627 FF:3F4B: CA           	DEX				; decrement start index
  4628 FF:3F4C: 8A           	TXA				; copy to A
  4629 FF:3F4D: 48           	PHA				; save string start offset
  4630                        	FETCHINDIRECTY des_2l
+ 4630 FF:3F4E: 8B               PHB
+ 4630 FF:3F4F: 48           	PHA
+ 4630 FF:3F50: DA               PHX
+ 4630 FF:3F51: A2 01            LDX #$01
+ 4630 FF:3F53: B5 9E            LDA <des_2l,X
+ 4630 FF:3F55: C9 00            CMP #$00
+ 4630 FF:3F57: D0 04            BNE *+6
+ 4630 FF:3F59: A2 00        	LDX #00
+ 4630 FF:3F5B: DA           	PHX
+ 4630 FF:3F5C: AB           	PLB
+ 4630 FF:3F5D: FA               PLX
+ 4630 FF:3F5E: B1 9E            LDA	(<des_2l),Y		;
+ 4630 FF:3F60: 85 04            STA <TMPFLG
+ 4630 FF:3F62: 68               PLA
+ 4630 FF:3F63: AB               PLB
  4631 FF:3F64: 18           	CLC				; clear carry for sub-1
  4632 FF:3F65: A2 00        	LDX	#$00			; clear output string length
  4633 FF:3F67: E5 04        	SBC	<TMPFLG		; subtract string length
  4634 FF:3F69: B0 AB        	BCS	LAB_231D		; if start>string length go do null string
  4635                        
  4636 FF:3F6B: 49 FF        	EOR	#$FF			; complement -length
  4637 FF:3F6D: C5 AF        	CMP	<mids_l		; compare byte parameter
  4638 FF:3F6F: 90 A6        	BCC	LAB_231E		; if length>remaining string go do RIGHT$
  4639                        
  4640 FF:3F71: A5 AF        	LDA	<mids_l		; get length byte
  4641 FF:3F73: B0 A2        	BCS	LAB_231E		; go do string copy (branch always)
  4642                        
  4643                        ; pull string data and byte parameter from stack
  4644                        ; return pointer in <des_2l/h, byte in A (and X), Y=0
  4645                        
  4646                        LAB_236F
  4647 FF:3F75: 20 13 35     	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
  4648 FF:3F78: 68           	PLA				; pull return address low byte (return address)
  4649 FF:3F79: 85 A2        	STA	<Fnxjpl		; save functions jump vector low byte
  4650 FF:3F7B: 68           	PLA				; pull return address high byte (return address)
  4651 FF:3F7C: 85 A3        	STA	<Fnxjph		; save functions jump vector high byte
  4652 FF:3F7E: 68           	PLA				; pull byte parameter
  4653 FF:3F7F: AA           	TAX				; copy byte parameter to X
  4654 FF:3F80: 68           	PLA				; pull string pointer low byte
  4655 FF:3F81: 85 9E        	STA	<des_2l		; save it
  4656 FF:3F83: 68           	PLA				; pull string pointer high byte
  4657 FF:3F84: 85 9F        	STA	<des_2h		; save it
  4658 FF:3F86: A0 00        	LDY	#$00			; clear index
  4659 FF:3F88: 8A           	TXA				; copy byte parameter
  4660                        	LBEQ	LAB_23A8		; if null do function call error then warm start
  Sun Nov 21 2021 15:13                                                                                                Page 174


+ 4660 FF:3F89: D0 03             bne *+5
+ 4660 FF:3F8B: 4C 97 40          jmp LAB_23A8
  4661                        
  4662 FF:3F8E: E6 A2        	INC	<Fnxjpl		; increment function jump vector low byte
  4663                        					; (JSR pushes return addr-1. this is all very nice
  4664                        					; but will go tits up if either call is on a page
  4665                        					; boundary!)
  4666 FF:3F90: 6C A2 00     	JMP	(Fnxjpl)		; in effect, RTS
  4667                        
  4668                        ; perform LCASE$()
  4669                        
  4670                        LAB_LCASE
  4671 FF:3F93: 20 12 3E     	JSR	LAB_EVST		; evaluate string
  4672 FF:3F96: 85 AC        	STA	<str_ln		; set string length
  4673 FF:3F98: A8           	TAY				; copy length to Y
  4674                        	LBEQ	NoString		; branch if null string
+ 4674 FF:3F99: D0 03             bne *+5
+ 4674 FF:3F9B: 4C 26 40          jmp NoString
  4675                        
  4676 FF:3F9E: 20 2E 3B     	JSR	LAB_MSSP		; make string space A bytes long A=length,
  4677                        					; X=<Sutill=ptr low byte, Y=<Sutilh=ptr high byte
  4678 FF:3FA1: 86 AD        	STX	<str_pl		; save string pointer low byte
  4679 FF:3FA3: 84 AE        	STY	<str_ph		; save string pointer high byte
  4680 FF:3FA5: A8           	TAY				; get string length back
  4681                        
  4682                        LC_loop
  4683 FF:3FA6: 88           	DEY				; decrement index
  4684                        	LDAINDIRECTY ut1_pl		; get byte from string
+ 4684 FF:3FA7: 8B               PHB
+ 4684 FF:3FA8: DA           	PHX
+ 4684 FF:3FA9: A2 01            LDX #$01
+ 4684 FF:3FAB: B5 71            LDA <ut1_pl,X
+ 4684 FF:3FAD: C9 00            CMP #$00
+ 4684 FF:3FAF: D0 04            BNE *+6
+ 4684 FF:3FB1: A2 00        	LDX #00
+ 4684 FF:3FB3: DA           	PHX
+ 4684 FF:3FB4: AB           	PLB
+ 4684 FF:3FB5: FA               PLX
+ 4684 FF:3FB6: B1 71        	LDA	(<ut1_pl),Y		;
+ 4684 FF:3FB8: 85 04            STA <TMPFLG
+ 4684 FF:3FBA: AB               PLB
+ 4684 FF:3FBB: A5 04            LDA <TMPFLG
  4685 FF:3FBD: 20 7B 37     	JSR	LAB_1D82		; is character "A" to "Z"
  4686 FF:3FC0: 90 02        	BCC	NoUcase		; branch if not upper case alpha
  4687                        
  4688 FF:3FC2: 09 20        	ORA	#$20			; convert upper to lower case
  4689                        NoUcase
  4690                        	STAINDIRECTY Sutill		; save byte back to string
+ 4690 FF:3FC4: 8B               PHB
+ 4690 FF:3FC5: DA           	PHX
+ 4690 FF:3FC6: 48               PHA
+ 4690 FF:3FC7: A2 01            LDX #$01
+ 4690 FF:3FC9: B5 83            LDA <Sutill,X
+ 4690 FF:3FCB: C9 00            CMP #$00
+ 4690 FF:3FCD: D0 04            BNE *+6
+ 4690 FF:3FCF: A2 00        	LDX #00
+ 4690 FF:3FD1: DA           	PHX
  Sun Nov 21 2021 15:13                                                                                                Page 175


+ 4690 FF:3FD2: AB           	PLB
+ 4690 FF:3FD3: 68               PLA
+ 4690 FF:3FD4: FA               PLX
+ 4690 FF:3FD5: 91 83        	STA	(<Sutill),Y		;
+ 4690 FF:3FD7: AB           	PLB
+ 4690 FF:3FD8: 85 04            STA <TMPFLG
  4691 FF:3FDA: 98           	TYA				; test index
  4692 FF:3FDB: D0 C9        	BNE	LC_loop		; loop if not all done
  4693                        
  4694 FF:3FDD: F0 47        	BEQ	NoString		; tidy up and exit, branch always
  4695                        
  4696                        ; perform UCASE$()
  4697                        
  4698                        LAB_UCASE
  4699 FF:3FDF: 20 12 3E     	JSR	LAB_EVST		; evaluate string
  4700 FF:3FE2: 85 AC        	STA	<str_ln		; set string length
  4701 FF:3FE4: A8           	TAY				; copy length to Y
  4702 FF:3FE5: F0 3F        	BEQ	NoString		; branch if null string
  4703                        
  4704 FF:3FE7: 20 2E 3B     	JSR	LAB_MSSP		; make string space A bytes long A=length,
  4705                        					; X=<Sutill=ptr low byte, Y=<Sutilh=ptr high byte
  4706 FF:3FEA: 86 AD        	STX	<str_pl		; save string pointer low byte
  4707 FF:3FEC: 84 AE        	STY	<str_ph		; save string pointer high byte
  4708 FF:3FEE: A8           	TAY				; get string length back
  4709                        
  4710                        UC_loop
  4711 FF:3FEF: 88           	DEY				; decrement index
  4712                        	LDAINDIRECTY ut1_pl		; get byte from string
+ 4712 FF:3FF0: 8B               PHB
+ 4712 FF:3FF1: DA           	PHX
+ 4712 FF:3FF2: A2 01            LDX #$01
+ 4712 FF:3FF4: B5 71            LDA <ut1_pl,X
+ 4712 FF:3FF6: C9 00            CMP #$00
+ 4712 FF:3FF8: D0 04            BNE *+6
+ 4712 FF:3FFA: A2 00        	LDX #00
+ 4712 FF:3FFC: DA           	PHX
+ 4712 FF:3FFD: AB           	PLB
+ 4712 FF:3FFE: FA               PLX
+ 4712 FF:3FFF: B1 71        	LDA	(<ut1_pl),Y		;
+ 4712 FF:4001: 85 04            STA <TMPFLG
+ 4712 FF:4003: AB               PLB
+ 4712 FF:4004: A5 04            LDA <TMPFLG
  4713 FF:4006: 20 77 37     	JSR	LAB_CASC		; is character "a" to "z" (or "A" to "Z")
  4714 FF:4009: 90 02        	BCC	NoLcase		; branch if not alpha
  4715                        
  4716 FF:400B: 29 DF        	AND	#$DF			; convert lower to upper case
  4717                        NoLcase
  4718                        	STAINDIRECTY Sutill		; save byte back to string
+ 4718 FF:400D: 8B               PHB
+ 4718 FF:400E: DA           	PHX
+ 4718 FF:400F: 48               PHA
+ 4718 FF:4010: A2 01            LDX #$01
+ 4718 FF:4012: B5 83            LDA <Sutill,X
+ 4718 FF:4014: C9 00            CMP #$00
+ 4718 FF:4016: D0 04            BNE *+6
+ 4718 FF:4018: A2 00        	LDX #00
+ 4718 FF:401A: DA           	PHX
  Sun Nov 21 2021 15:13                                                                                                Page 176


+ 4718 FF:401B: AB           	PLB
+ 4718 FF:401C: 68               PLA
+ 4718 FF:401D: FA               PLX
+ 4718 FF:401E: 91 83        	STA	(<Sutill),Y		;
+ 4718 FF:4020: AB           	PLB
+ 4718 FF:4021: 85 04            STA <TMPFLG
  4719 FF:4023: 98           	TYA				; test index
  4720 FF:4024: D0 C9        	BNE	UC_loop		; loop if not all done
  4721                        
  4722                        NoString
  4723 FF:4026: 4C 91 3B     	JMP	LAB_RTST		; check for space on descriptor stack then put string
  4724                        					; address and length on descriptor stack and update stack
  4725                        					; pointers
  4726                        
  4727                        ; perform SADD()
  4728                        
  4729                        LAB_SADD
  4730 FF:4029: 22 BC 00 00  	JSL	LAB_IGBY		; increment and scan memory
  4731 FF:402D: 20 FF 36     	JSR	LAB_GVAR		; get var address
  4732                        
  4733 FF:4030: 20 13 35     	JSR	LAB_1BFB		; scan for ")", else do syntax error then warm start
  4734 FF:4033: 20 F3 33     	JSR	LAB_CTST		; check if source is string, else do type mismatch
  4735                        
  4736 FF:4036: A0 02        	LDY	#$02			; index to string pointer high byte
  4737                        	LDAINDIRECTY Cvaral		; get string pointer high byte
+ 4737 FF:4038: 8B               PHB
+ 4737 FF:4039: DA           	PHX
+ 4737 FF:403A: A2 01            LDX #$01
+ 4737 FF:403C: B5 95            LDA <Cvaral,X
+ 4737 FF:403E: C9 00            CMP #$00
+ 4737 FF:4040: D0 04            BNE *+6
+ 4737 FF:4042: A2 00        	LDX #00
+ 4737 FF:4044: DA           	PHX
+ 4737 FF:4045: AB           	PLB
+ 4737 FF:4046: FA               PLX
+ 4737 FF:4047: B1 95        	LDA	(<Cvaral),Y		;
+ 4737 FF:4049: 85 04            STA <TMPFLG
+ 4737 FF:404B: AB               PLB
+ 4737 FF:404C: A5 04            LDA <TMPFLG
  4738 FF:404E: AA           	TAX				; copy string pointer high byte to X
  4739 FF:404F: 88           	DEY				; index to string pointer low byte
  4740                        	LDAINDIRECTY Cvaral		; get string pointer low byte
+ 4740 FF:4050: 8B               PHB
+ 4740 FF:4051: DA           	PHX
+ 4740 FF:4052: A2 01            LDX #$01
+ 4740 FF:4054: B5 95            LDA <Cvaral,X
+ 4740 FF:4056: C9 00            CMP #$00
+ 4740 FF:4058: D0 04            BNE *+6
+ 4740 FF:405A: A2 00        	LDX #00
+ 4740 FF:405C: DA           	PHX
+ 4740 FF:405D: AB           	PLB
+ 4740 FF:405E: FA               PLX
+ 4740 FF:405F: B1 95        	LDA	(<Cvaral),Y		;
+ 4740 FF:4061: 85 04            STA <TMPFLG
+ 4740 FF:4063: AB               PLB
+ 4740 FF:4064: A5 04            LDA <TMPFLG
  4741 FF:4066: A8           	TAY				; copy string pointer low byte to Y
  Sun Nov 21 2021 15:13                                                                                                Page 177


  4742 FF:4067: 8A           	TXA				; copy string pointer high byte to A
  4743 FF:4068: 4C BD 39     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  4744                        
  4745                        ; perform LEN()
  4746                        
  4747                        LAB_LENS
  4748 FF:406B: 20 71 40     	JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
  4749 FF:406E: 4C CA 39     	JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
  4750                        
  4751                        ; evaluate string, get length in Y
  4752                        
  4753                        LAB_ESGL
  4754 FF:4071: 20 12 3E     	JSR	LAB_EVST		; evaluate string
  4755 FF:4074: A8           	TAY				; copy length to Y
  4756 FF:4075: 60           	RTS
  4757                        
  4758                        ; perform ASC()
  4759                        
  4760                        LAB_ASC
  4761 FF:4076: 20 71 40     	JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
  4762 FF:4079: F0 1C        	BEQ	LAB_23A8		; if null do function call error then warm start
  4763                        
  4764 FF:407B: A0 00        	LDY	#$00			; set index to first character
  4765                        	LDAINDIRECTY ut1_pl		; get byte
+ 4765 FF:407D: 8B               PHB
+ 4765 FF:407E: DA           	PHX
+ 4765 FF:407F: A2 01            LDX #$01
+ 4765 FF:4081: B5 71            LDA <ut1_pl,X
+ 4765 FF:4083: C9 00            CMP #$00
+ 4765 FF:4085: D0 04            BNE *+6
+ 4765 FF:4087: A2 00        	LDX #00
+ 4765 FF:4089: DA           	PHX
+ 4765 FF:408A: AB           	PLB
+ 4765 FF:408B: FA               PLX
+ 4765 FF:408C: B1 71        	LDA	(<ut1_pl),Y		;
+ 4765 FF:408E: 85 04            STA <TMPFLG
+ 4765 FF:4090: AB               PLB
+ 4765 FF:4091: A5 04            LDA <TMPFLG
  4766 FF:4093: A8           	TAY				; copy to Y
  4767 FF:4094: 4C CA 39     	JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
  4768                        
  4769                        ; do function call error then warm start
  4770                        
  4771                        LAB_23A8
  4772 FF:4097: 4C 87 38     	JMP	LAB_FCER		; do function call error then warm start
  4773                        
  4774                        ; scan and get byte parameter
  4775                        
  4776                        LAB_SGBY
  4777 FF:409A: 22 BC 00 00  	JSL	LAB_IGBY		; increment and scan memory
  4778                        
  4779                        ; get byte parameter
  4780                        
  4781                        LAB_GTBY
  4782 FF:409E: 20 EE 33     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
  4783                        					; else do type mismatch
  4784                        
  Sun Nov 21 2021 15:13                                                                                                Page 178


  4785                        ; evaluate byte expression, result in X
  4786                        
  4787                        LAB_EVBY
  4788 FF:40A1: 20 FC 37     	JSR	LAB_EVPI		; evaluate integer expression (no check)
  4789                        
  4790 FF:40A4: A4 AE        	LDY	<FAC1_2		; get FAC1 mantissa2
  4791 FF:40A6: D0 EF        	BNE	LAB_23A8		; if top byte <> 0 do function call error then warm start
  4792                        
  4793 FF:40A8: A6 AF        	LDX	<FAC1_3		; get FAC1 mantissa3
  4794 FF:40AA: 22 C2 00 00  	JSL	LAB_GBYT		; scan memory and return
  4795 FF:40AE: 60           	RTS
  4796                        
  4797                        ; perform VAL()
  4798                        
  4799                        LAB_VAL
  4800 FF:40AF: 20 71 40     	JSR	LAB_ESGL		; evaluate string, get length in A (and Y)
  4801 FF:40B2: D0 03        	BNE	LAB_23C5		; branch if not null string
  4802                        
  4803                        					; string was null so set result = $00
  4804 FF:40B4: 4C FF 42     	JMP	LAB_24F1		; clear FAC1 exponent and sign and return
  4805                        
  4806                        LAB_23C5
  4807 FF:40B7: A6 C3        	LDX	<Bpntrl		; get BASIC execute pointer low byte
  4808 FF:40B9: A4 C4        	LDY	<Bpntrh		; get BASIC execute pointer high byte
  4809 FF:40BB: 86 BA        	STX	<Btmpl			; save BASIC execute pointer low byte
  4810 FF:40BD: 84 BB        	STY	<Btmph			; save BASIC execute pointer high byte
  4811 FF:40BF: A6 71        	LDX	<ut1_pl		; get string pointer low byte
  4812 FF:40C1: 86 C3        	STX	<Bpntrl		; save as BASIC execute pointer low byte
  4813 FF:40C3: 18           	CLC				; clear carry
  4814 FF:40C4: 65 71        	ADC	<ut1_pl		; add string length
  4815 FF:40C6: 85 73        	STA	<ut2_pl		; save string end low byte
  4816 FF:40C8: A5 72        	LDA	<ut1_ph		; get string pointer high byte
  4817 FF:40CA: 85 C4        	STA	<Bpntrh		; save as BASIC execute pointer high byte
  4818 FF:40CC: 69 00        	ADC	#$00			; add carry to high byte
  4819 FF:40CE: 85 74        	STA	<ut2_ph		; save string end high byte
  4820 FF:40D0: A0 00        	LDY	#$00			; set index to $00
  4821                        	LDAINDIRECTY ut2_pl		; get string end +1 byte
+ 4821 FF:40D2: 8B               PHB
+ 4821 FF:40D3: DA           	PHX
+ 4821 FF:40D4: A2 01            LDX #$01
+ 4821 FF:40D6: B5 73            LDA <ut2_pl,X
+ 4821 FF:40D8: C9 00            CMP #$00
+ 4821 FF:40DA: D0 04            BNE *+6
+ 4821 FF:40DC: A2 00        	LDX #00
+ 4821 FF:40DE: DA           	PHX
+ 4821 FF:40DF: AB           	PLB
+ 4821 FF:40E0: FA               PLX
+ 4821 FF:40E1: B1 73        	LDA	(<ut2_pl),Y		;
+ 4821 FF:40E3: 85 04            STA <TMPFLG
+ 4821 FF:40E5: AB               PLB
+ 4821 FF:40E6: A5 04            LDA <TMPFLG
  4822 FF:40E8: 48           	PHA				; push it
  4823 FF:40E9: 98           	TYA				; clear A
  4824                        	STAINDIRECTY ut2_pl		; terminate string with $00
+ 4824 FF:40EA: 8B               PHB
+ 4824 FF:40EB: DA           	PHX
+ 4824 FF:40EC: 48               PHA
  Sun Nov 21 2021 15:13                                                                                                Page 179


+ 4824 FF:40ED: A2 01            LDX #$01
+ 4824 FF:40EF: B5 73            LDA <ut2_pl,X
+ 4824 FF:40F1: C9 00            CMP #$00
+ 4824 FF:40F3: D0 04            BNE *+6
+ 4824 FF:40F5: A2 00        	LDX #00
+ 4824 FF:40F7: DA           	PHX
+ 4824 FF:40F8: AB           	PLB
+ 4824 FF:40F9: 68               PLA
+ 4824 FF:40FA: FA               PLX
+ 4824 FF:40FB: 91 73        	STA	(<ut2_pl),Y		;
+ 4824 FF:40FD: AB           	PLB
+ 4824 FF:40FE: 85 04            STA <TMPFLG
  4825 FF:4100: 22 C2 00 00  	JSL	LAB_GBYT		; scan memory
  4826 FF:4104: 20 A9 47     	JSR	LAB_2887		; get FAC1 from string
  4827 FF:4107: 68           	PLA				; restore string end +1 byte
  4828 FF:4108: A0 00        	LDY	#$00			; set index to zero
  4829                        	STAINDIRECTY ut2_pl		; put string end byte back
+ 4829 FF:410A: 8B               PHB
+ 4829 FF:410B: DA           	PHX
+ 4829 FF:410C: 48               PHA
+ 4829 FF:410D: A2 01            LDX #$01
+ 4829 FF:410F: B5 73            LDA <ut2_pl,X
+ 4829 FF:4111: C9 00            CMP #$00
+ 4829 FF:4113: D0 04            BNE *+6
+ 4829 FF:4115: A2 00        	LDX #00
+ 4829 FF:4117: DA           	PHX
+ 4829 FF:4118: AB           	PLB
+ 4829 FF:4119: 68               PLA
+ 4829 FF:411A: FA               PLX
+ 4829 FF:411B: 91 73        	STA	(<ut2_pl),Y		;
+ 4829 FF:411D: AB           	PLB
+ 4829 FF:411E: 85 04            STA <TMPFLG
  4830                        
  4831                        ; restore BASIC execute pointer from temp (<Btmpl/<Btmph)
  4832                        
  4833                        LAB_23F3
  4834 FF:4120: A6 BA        	LDX	<Btmpl			; get BASIC execute pointer low byte back
  4835 FF:4122: A4 BB        	LDY	<Btmph			; get BASIC execute pointer high byte back
  4836 FF:4124: 86 C3        	STX	<Bpntrl		; save BASIC execute pointer low byte
  4837 FF:4126: 84 C4        	STY	<Bpntrh		; save BASIC execute pointer high byte
  4838 FF:4128: 60           	RTS
  4839                        
  4840                        ; get two parameters for POKE or WAIT
  4841                        
  4842                        LAB_GADB
  4843 FF:4129: 20 EE 33     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
  4844                        					; else do type mismatch
  4845 FF:412C: 20 42 41     	JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
  4846                        
  4847                        ; scan for "," and get byte, else do Syntax error then warm start
  4848                        
  4849                        LAB_SCGB
  4850 FF:412F: 20 24 35     	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
  4851 FF:4132: A5 12        	LDA	<Itemph		; save temporary integer high byte
  4852 FF:4134: 48           	PHA				; on stack
  4853 FF:4135: A5 11        	LDA	<Itempl		; save temporary integer low byte
  4854 FF:4137: 48           	PHA				; on stack
  Sun Nov 21 2021 15:13                                                                                                Page 180


  4855 FF:4138: 20 9E 40     	JSR	LAB_GTBY		; get byte parameter
  4856 FF:413B: 68           	PLA				; pull low byte
  4857 FF:413C: 85 11        	STA	<Itempl		; restore temporary integer low byte
  4858 FF:413E: 68           	PLA				; pull high byte
  4859 FF:413F: 85 12        	STA	<Itemph		; restore temporary integer high byte
  4860 FF:4141: 60           	RTS
  4861                        
  4862                        ; convert float to fixed routine. accepts any value that fits in 24 bits, +ve or
  4863                        ; -ve and converts it into a right truncated integer in <Itempl and <Itemph
  4864                        
  4865                        ; save unsigned 16 bit integer part of FAC1 in temporary integer
  4866                        
  4867                        LAB_F2FX
  4868 FF:4142: A5 AC        	LDA	<FAC1_e		; get FAC1 exponent
  4869 FF:4144: C9 98        	CMP	#$98			; compare with exponent = 2^24
  4870 FF:4146: B0 03        	BCS	LAB_23A8_1		; do function call error then warm start
  4871 FF:4148: 4C 4E 41     	jmp LAB_F2FU
  4872                        LAB_23A8_1:
  4873 FF:414B: 4C 97 40     	jmp LAB_23A8
  4874                        LAB_F2FU
  4875 FF:414E: 20 53 47     	JSR	LAB_2831		; convert FAC1 floating-to-fixed
  4876 FF:4151: A5 AE        	LDA	<FAC1_2		; get FAC1 mantissa2
  4877 FF:4153: A4 AF        	LDY	<FAC1_3		; get FAC1 mantissa3
  4878 FF:4155: 84 11        	STY	<Itempl		; save temporary integer low byte
  4879 FF:4157: 85 12        	STA	<Itemph		; save temporary integer high byte
  4880 FF:4159: 60           	RTS
  4881                        
  4882                        ; perform PEEK()
  4883                        
  4884                        LAB_PEEK
  4885 FF:415A: 20 42 41     	JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
  4886 FF:415D: A2 00        	LDX	#$00			; clear index
  4887 FF:415F: 8B           	PHB
  4888                        	setbank 0
+ 4888 FF:4160: DA               PHX
+ 4888 FF:4161: A2 00        	LDX #0
+ 4888 FF:4163: DA           	PHX
+ 4888 FF:4164: AB           	PLB
+ 4888 FF:4165: FA               PLX
  4889 FF:4166: A1 11        	LDA (<Itempl,X)		; get byte via temporary integer (addr)
  4890 FF:4168: AB           	plb
  4891 FF:4169: A8           	TAY				; copy byte to Y
  4892 FF:416A: 4C CA 39     	JMP	LAB_1FD0		; convert Y to byte in FAC1 and return
  4893                        
  4894                        ; perform POKE
  4895                        
  4896                        LAB_POKE
  4897 FF:416D: 20 29 41     	JSR	LAB_GADB		; get two parameters for POKE or WAIT
  4898 FF:4170: 8A           	TXA				; copy byte argument to A
  4899 FF:4171: A2 00        	LDX	#$00			; clear index
  4900 FF:4173: 8B           	PHB
  4901                        	setbank 0
+ 4901 FF:4174: DA               PHX
+ 4901 FF:4175: A2 00        	LDX #0
+ 4901 FF:4177: DA           	PHX
+ 4901 FF:4178: AB           	PLB
+ 4901 FF:4179: FA               PLX
  Sun Nov 21 2021 15:13                                                                                                Page 181


  4902 FF:417A: 81 11        	STA (<Itempl,X)		; save byte via temporary integer (addr)
  4903 FF:417C: AB           	plb
  4904 FF:417D: 60           	RTS
  4905                        
  4906                        ; perform SYS
  4907                        
  4908                        LAB_SYS
  4909 FF:417E: 20 EE 33     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
  4910                        					; else do type mismatch
  4911 FF:4181: 20 42 41     	JSR	LAB_F2FX		; save integer part of FAC1 in temporary integer
  4912                        
  4913 FF:4184: A5 11        	LDA	<Itempl
  4914 FF:4186: 85 0B        	STA 	<Usrjpl
  4915 FF:4188: A5 12        	LDA	<Itemph
  4916 FF:418A: 85 0C        	STA 	<Usrjph
  4917 FF:418C: 22 0A 00 00  	JSL 	Usrjmp
  4918 FF:4190: 60           	RTS
  4919                        
  4920                        ; perform SWAP
  4921                        
  4922                        LAB_SWAP
  4923 FF:4191: 20 FF 36     	JSR	LAB_GVAR		; get var1 address
  4924 FF:4194: 85 97        	STA	<Lvarpl		; save var1 address low byte
  4925 FF:4196: 84 98        	STY	<Lvarph		; save var1 address high byte
  4926 FF:4198: A5 5F        	LDA	<Dtypef		; get data type flag, $FF=string, $00=numeric
  4927 FF:419A: 48           	PHA				; save data type flag
  4928                        
  4929 FF:419B: 20 24 35     	JSR	LAB_1C01		; scan for "," , else do syntax error then warm start
  4930 FF:419E: 20 FF 36     	JSR	LAB_GVAR		; get var2 address (pointer in <Cvaral/h)
  4931 FF:41A1: 68           	PLA				; pull var1 data type flag
  4932 FF:41A2: 45 5F        	EOR	<Dtypef		; compare with var2 data type
  4933 FF:41A4: 10 60        	BPL	SwapErr		; exit if not both the same type
  4934                        
  4935 FF:41A6: A0 03        	LDY	#$03			; four bytes to swap (either value or descriptor+1)
  4936                        SwapLp
  4937                        	LDAINDIRECTY Lvarpl		; get byte from var1
+ 4937 FF:41A8: 8B               PHB
+ 4937 FF:41A9: DA           	PHX
+ 4937 FF:41AA: A2 01            LDX #$01
+ 4937 FF:41AC: B5 97            LDA <Lvarpl,X
+ 4937 FF:41AE: C9 00            CMP #$00
+ 4937 FF:41B0: D0 04            BNE *+6
+ 4937 FF:41B2: A2 00        	LDX #00
+ 4937 FF:41B4: DA           	PHX
+ 4937 FF:41B5: AB           	PLB
+ 4937 FF:41B6: FA               PLX
+ 4937 FF:41B7: B1 97        	LDA	(<Lvarpl),Y		;
+ 4937 FF:41B9: 85 04            STA <TMPFLG
+ 4937 FF:41BB: AB               PLB
+ 4937 FF:41BC: A5 04            LDA <TMPFLG
  4938 FF:41BE: AA           	TAX				; save var1 byte
  4939                        	LDAINDIRECTY Cvaral		; get byte from var2
+ 4939 FF:41BF: 8B               PHB
+ 4939 FF:41C0: DA           	PHX
+ 4939 FF:41C1: A2 01            LDX #$01
+ 4939 FF:41C3: B5 95            LDA <Cvaral,X
+ 4939 FF:41C5: C9 00            CMP #$00
  Sun Nov 21 2021 15:13                                                                                                Page 182


+ 4939 FF:41C7: D0 04            BNE *+6
+ 4939 FF:41C9: A2 00        	LDX #00
+ 4939 FF:41CB: DA           	PHX
+ 4939 FF:41CC: AB           	PLB
+ 4939 FF:41CD: FA               PLX
+ 4939 FF:41CE: B1 95        	LDA	(<Cvaral),Y		;
+ 4939 FF:41D0: 85 04            STA <TMPFLG
+ 4939 FF:41D2: AB               PLB
+ 4939 FF:41D3: A5 04            LDA <TMPFLG
  4940                        	STAINDIRECTY Lvarpl		; save byte to var1
+ 4940 FF:41D5: 8B               PHB
+ 4940 FF:41D6: DA           	PHX
+ 4940 FF:41D7: 48               PHA
+ 4940 FF:41D8: A2 01            LDX #$01
+ 4940 FF:41DA: B5 97            LDA <Lvarpl,X
+ 4940 FF:41DC: C9 00            CMP #$00
+ 4940 FF:41DE: D0 04            BNE *+6
+ 4940 FF:41E0: A2 00        	LDX #00
+ 4940 FF:41E2: DA           	PHX
+ 4940 FF:41E3: AB           	PLB
+ 4940 FF:41E4: 68               PLA
+ 4940 FF:41E5: FA               PLX
+ 4940 FF:41E6: 91 97        	STA	(<Lvarpl),Y		;
+ 4940 FF:41E8: AB           	PLB
+ 4940 FF:41E9: 85 04            STA <TMPFLG
  4941 FF:41EB: 8A           	TXA				; restore var1 byte
  4942                        	STAINDIRECTY Cvaral		; save byte to var2
+ 4942 FF:41EC: 8B               PHB
+ 4942 FF:41ED: DA           	PHX
+ 4942 FF:41EE: 48               PHA
+ 4942 FF:41EF: A2 01            LDX #$01
+ 4942 FF:41F1: B5 95            LDA <Cvaral,X
+ 4942 FF:41F3: C9 00            CMP #$00
+ 4942 FF:41F5: D0 04            BNE *+6
+ 4942 FF:41F7: A2 00        	LDX #00
+ 4942 FF:41F9: DA           	PHX
+ 4942 FF:41FA: AB           	PLB
+ 4942 FF:41FB: 68               PLA
+ 4942 FF:41FC: FA               PLX
+ 4942 FF:41FD: 91 95        	STA	(<Cvaral),Y		;
+ 4942 FF:41FF: AB           	PLB
+ 4942 FF:4200: 85 04            STA <TMPFLG
  4943 FF:4202: 88           	DEY				; decrement index
  4944 FF:4203: 10 A3        	BPL	SwapLp		; loop until done
  4945                        
  4946 FF:4205: 60           	RTS
  4947                        
  4948                        SwapErr
  4949 FF:4206: 4C FD 33     	JMP	LAB_1ABC		; do "Type mismatch" error then warm start
  4950                        
  4951                        ; perform CALL
  4952                        
  4953                        LAB_CALL
  4954 FF:4209: 20 EE 33     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
  4955                        					; else do type mismatch
  4956 FF:420C: 20 42 41     	JSR	LAB_F2FX		; convert floating-to-fixed
  4957 FF:420F: A9 42        	LDA	#>CallExit		; set return address high byte
  Sun Nov 21 2021 15:13                                                                                                Page 183


  4958 FF:4211: 48           	PHA				; put on stack
  4959 FF:4212: A9 17        	LDA	#<CallExit-1	; set return address low byte
  4960 FF:4214: 48           	PHA				; put on stack
  4961 FF:4215: 6C 11 00     	JMP	(Itempl)		; do indirect jump to user routine
  4962                        
  4963                        ; if the called routine exits correctly then it will return to here. this will then get
  4964                        ; the next byte for the interpreter and return
  4965                        
  4966                        CallExit
  4967 FF:4218: 22 C2 00 00  	JSL	LAB_GBYT		; scan memory and return
  4968 FF:421C: 60           	rts
  4969                        ; perform WAIT
  4970                        
  4971                        LAB_WAIT
  4972 FF:421D: 20 29 41     	JSR	LAB_GADB		; get two parameters for POKE or WAIT
  4973 FF:4220: 86 97        	STX	<Frnxtl		; save byte
  4974 FF:4222: A2 00        	LDX	#$00			; clear mask
  4975 FF:4224: 22 C2 00 00  	JSL	LAB_GBYT		; scan memory
  4976 FF:4228: F0 03        	BEQ	LAB_2441		; skip if no third argument
  4977                        
  4978 FF:422A: 20 2F 41     	JSR	LAB_SCGB		; scan for "," and get byte, else SN error then warm start
  4979                        LAB_2441
  4980 FF:422D: 86 98        	STX	<Frnxth		; save EOR argument
  4981                        LAB_2445
  4982                        	LDAINDIRECTY Itempl		; get byte via temporary integer (addr)
+ 4982 FF:422F: 8B               PHB
+ 4982 FF:4230: DA           	PHX
+ 4982 FF:4231: A2 01            LDX #$01
+ 4982 FF:4233: B5 11            LDA <Itempl,X
+ 4982 FF:4235: C9 00            CMP #$00
+ 4982 FF:4237: D0 04            BNE *+6
+ 4982 FF:4239: A2 00        	LDX #00
+ 4982 FF:423B: DA           	PHX
+ 4982 FF:423C: AB           	PLB
+ 4982 FF:423D: FA               PLX
+ 4982 FF:423E: B1 11        	LDA	(<Itempl),Y		;
+ 4982 FF:4240: 85 04            STA <TMPFLG
+ 4982 FF:4242: AB               PLB
+ 4982 FF:4243: A5 04            LDA <TMPFLG
  4983 FF:4245: 45 98        	EOR	<Frnxth		; EOR with second argument (mask)
  4984 FF:4247: 25 97        	AND	<Frnxtl		; AND with first argument (byte)
  4985 FF:4249: F0 E4        	BEQ	LAB_2445		; loop if result is zero
  4986                        
  4987                        LAB_244D
  4988 FF:424B: 60           	RTS
  4989                        
  4990                        ; perform subtraction, FAC1 from (AY)
  4991                        
  4992                        LAB_2455
  4993 FF:424C: 20 3A 44     	JSR	LAB_264D		; unpack memory (AY) into FAC2
  4994                        
  4995                        ; perform subtraction, FAC1 from FAC2
  4996                        
  4997                        LAB_SUBTRACT
  4998 FF:424F: A5 B0        	LDA	<FAC1_s		; get FAC1 sign (b7)
  4999 FF:4251: 49 FF        	EOR	#$FF			; complement it
  5000 FF:4253: 85 B0        	STA	<FAC1_s		; save FAC1 sign (b7)
  Sun Nov 21 2021 15:13                                                                                                Page 184


  5001 FF:4255: 45 B7        	EOR	<FAC2_s		; EOR with FAC2 sign (b7)
  5002 FF:4257: 85 B8        	STA	<FAC_sc		; save sign compare (FAC1 EOR FAC2)
  5003 FF:4259: A5 AC        	LDA	<FAC1_e		; get FAC1 exponent
  5004 FF:425B: 4C 6A 42     	JMP	LAB_ADD		; go add FAC2 to FAC1
  5005                        
  5006                        ; perform addition
  5007                        
  5008                        LAB_2467
  5009 FF:425E: 20 89 43     	JSR	LAB_257B		; shift FACX A times right (>8 shifts)
  5010 FF:4261: 90 4D        	BCC	LAB_24A8		;.go subtract mantissas
  5011                        
  5012                        ; add 0.5 to FAC1
  5013                        
  5014                        LAB_244E
  5015 FF:4263: A9 A3        	LDA	#<LAB_2A96		; set 0.5 pointer low byte
  5016 FF:4265: A0 18        	LDY	#>LAB_2A96		; set 0.5 pointer high byte
  5017                        
  5018                        ; add (AY) to FAC1
  5019                        
  5020                        LAB_246C
  5021 FF:4267: 20 3A 44     	JSR	LAB_264D		; unpack memory (AY) into FAC2
  5022                        
  5023                        ; add FAC2 to FAC1
  5024                        
  5025                        LAB_ADD
  5026 FF:426A: D0 10        	BNE	LAB_2474		; branch if FAC1 was not zero
  5027                        
  5028                        ; copy FAC2 to FAC1
  5029                        
  5030                        LAB_279B
  5031 FF:426C: A5 B7        	LDA	<FAC2_s		; get FAC2 sign (b7)
  5032                        
  5033                        ; save FAC1 sign and copy ABS(FAC2) to FAC1
  5034                        
  5035                        LAB_279D
  5036 FF:426E: 85 B0        	STA	<FAC1_s		; save FAC1 sign (b7)
  5037 FF:4270: A2 04        	LDX	#$04			; 4 bytes to copy
  5038                        LAB_27A1
  5039 FF:4272: B5 B2        	LDA	<FAC1_o,X		; get byte from FAC2,X
  5040 FF:4274: 95 AB        	STA	<FAC1_e-1,X		; save byte at FAC1,X
  5041 FF:4276: CA           	DEX				; decrement count
  5042 FF:4277: D0 F9        	BNE	LAB_27A1		; loop if not all done
  5043                        
  5044 FF:4279: 86 B9        	STX	<FAC1_r		; clear FAC1 rounding byte
  5045 FF:427B: 60           	RTS
  5046                        
  5047                        					; FAC1 is non zero
  5048                        LAB_2474
  5049 FF:427C: A6 B9        	LDX	<FAC1_r		; get FAC1 rounding byte
  5050 FF:427E: 86 A3        	STX	<FAC2_r		; save as FAC2 rounding byte
  5051 FF:4280: A2 B3        	LDX	#<FAC2_e		; set index to FAC2 exponent addr
  5052 FF:4282: A5 B3        	LDA	<FAC2_e		; get FAC2 exponent
  5053                        LAB_247C
  5054 FF:4284: A8           	TAY				; copy exponent
  5055 FF:4285: F0 C4        	BEQ	LAB_244D		; exit if zero
  5056 FF:4287: 38           	SEC				; set carry for subtract
  5057 FF:4288: E5 AC        	SBC	<FAC1_e		; subtract FAC1 exponent
  Sun Nov 21 2021 15:13                                                                                                Page 185


  5058 FF:428A: F0 24        	BEQ	LAB_24A8		; branch if = (go add mantissa)
  5059 FF:428C: 90 12        	BCC	LAB_2498		; branch if <
  5060                        					; FAC2>FAC1
  5061 FF:428E: 84 AC        	STY	<FAC1_e		; save FAC1 exponent
  5062 FF:4290: A4 B7        	LDY	<FAC2_s		; get FAC2 sign (b7)
  5063 FF:4292: 84 B0        	STY	<FAC1_s		; save FAC1 sign (b7)
  5064 FF:4294: 49 FF        	EOR	#$FF			; complement A
  5065 FF:4296: 69 00        	ADC	#$00			; +1 (twos complement, carry is set)
  5066 FF:4298: A0 00        	LDY	#$00			; clear Y
  5067 FF:429A: 84 A3        	STY	<FAC2_r		; clear FAC2 rounding byte
  5068 FF:429C: A2 AC        	LDX	#<FAC1_e		; set index to FAC1 exponent addr
  5069 FF:429E: D0 04        	BNE	LAB_249C		; branch always
  5070                        LAB_2498
  5071 FF:42A0: A0 00        	LDY	#$00			; clear Y
  5072 FF:42A2: 84 B9        	STY	<FAC1_r		; clear FAC1 rounding byte
  5073                        LAB_249C
  5074 FF:42A4: C9 F9        	CMP	#$F9			; compare exponent diff with $F9
  5075 FF:42A6: 30 B6        	BMI	LAB_2467		; branch if range $79-$F8
  5076 FF:42A8: A8           	TAY				; copy exponent difference to Y
  5077 FF:42A9: A5 B9        	LDA	<FAC1_r		; get FAC1 rounding byte
  5078 FF:42AB: 56 01        	LSR	<PLUS_1,X		; shift FAC? mantissa1
  5079 FF:42AD: 20 A0 43     	JSR	LAB_2592		; shift FACX Y times right
  5080                        					; exponents are equal now do mantissa subtract
  5081                        LAB_24A8
  5082 FF:42B0: 24 B8        	BIT	<FAC_sc		; test sign compare (FAC1 EOR FAC2)
  5083 FF:42B2: 10 52        	BPL	LAB_24F8		; if = add FAC2 mantissa to FAC1 mantissa and return
  5084                        
  5085 FF:42B4: A0 AC        	LDY	#<FAC1_e		; set index to FAC1 exponent addr
  5086 FF:42B6: E0 B3        	CPX	#<FAC2_e		; compare X to FAC2 exponent addr
  5087 FF:42B8: F0 02        	BEQ	LAB_24B4		; branch if =
  5088                        
  5089 FF:42BA: A0 B3        	LDY	#<FAC2_e		; else set index to FAC2 exponent addr
  5090                        
  5091                        					; subtract smaller from bigger (take sign of bigger)
  5092                        LAB_24B4
  5093 FF:42BC: 38           	SEC				; set carry for subtract
  5094 FF:42BD: 49 FF        	EOR	#$FF			; ones complement A
  5095 FF:42BF: 65 A3        	ADC	<FAC2_r		; add FAC2 rounding byte
  5096 FF:42C1: 85 B9        	STA	<FAC1_r		; save FAC1 rounding byte
  5097 FF:42C3: DA           	phx
  5098 FF:42C4: BB           	tyx
  5099 FF:42C5: B5 03        	LDA	<PLUS_3,X		; get FACY mantissa3
  5100 FF:42C7: FA           	plx
  5101 FF:42C8: F5 03        	SBC	<PLUS_3,X		; subtract FACX mantissa3
  5102 FF:42CA: 85 AF        	STA	<FAC1_3		; save FAC1 mantissa3
  5103 FF:42CC: DA           	phx
  5104 FF:42CD: BB           	tyx
  5105 FF:42CE: B5 02        	LDA	<PLUS_2,x		; get FACY mantissa2
  5106 FF:42D0: FA           	plx
  5107 FF:42D1: F5 02        	SBC	<PLUS_2,X		; subtract FACX mantissa2
  5108 FF:42D3: 85 AE        	STA	<FAC1_2		; save FAC1 mantissa2
  5109 FF:42D5: DA           	phx
  5110 FF:42D6: BB           	tyx
  5111 FF:42D7: B5 01        	LDA	<PLUS_1,x		; get FACY mantissa1
  5112 FF:42D9: FA           	plx
  5113 FF:42DA: F5 01        	SBC	<PLUS_1,X		; subtract FACX mantissa1
  5114 FF:42DC: 85 AD        	STA	<FAC1_1		; save FAC1 mantissa1
  Sun Nov 21 2021 15:13                                                                                                Page 186


  5115                        
  5116                        ; do ABS and normalise FAC1
  5117                        
  5118                        LAB_24D0
  5119 FF:42DE: B0 03        	BCS	LAB_24D5		; branch if number is +ve
  5120                        
  5121 FF:42E0: 20 45 43     	JSR	LAB_2537		; negate FAC1
  5122                        
  5123                        ; normalise FAC1
  5124                        
  5125                        LAB_24D5
  5126 FF:42E3: A0 00        	LDY	#$00			; clear Y
  5127 FF:42E5: 98           	TYA				; clear A
  5128 FF:42E6: 18           	CLC				; clear carry for add
  5129                        LAB_24D9
  5130 FF:42E7: A6 AD        	LDX	<FAC1_1		; get FAC1 mantissa1
  5131 FF:42E9: D0 3E        	BNE	LAB_251B		; if not zero normalise FAC1
  5132                        
  5133 FF:42EB: A6 AE        	LDX	<FAC1_2		; get FAC1 mantissa2
  5134 FF:42ED: 86 AD        	STX	<FAC1_1		; save FAC1 mantissa1
  5135 FF:42EF: A6 AF        	LDX	<FAC1_3		; get FAC1 mantissa3
  5136 FF:42F1: 86 AE        	STX	<FAC1_2		; save FAC1 mantissa2
  5137 FF:42F3: A6 B9        	LDX	<FAC1_r		; get FAC1 rounding byte
  5138 FF:42F5: 86 AF        	STX	<FAC1_3		; save FAC1 mantissa3
  5139 FF:42F7: 84 B9        	STY	<FAC1_r		; clear FAC1 rounding byte
  5140 FF:42F9: 69 08        	ADC	#$08			; add x to exponent offset
  5141 FF:42FB: C9 18        	CMP	#$18			; compare with $18 (max offset, all bits would be =0)
  5142 FF:42FD: D0 E8        	BNE	LAB_24D9		; loop if not max
  5143                        
  5144                        ; clear FAC1 exponent and sign
  5145                        
  5146                        LAB_24F1
  5147 FF:42FF: A9 00        	LDA	#$00			; clear A
  5148                        LAB_24F3
  5149 FF:4301: 85 AC        	STA	<FAC1_e		; set FAC1 exponent
  5150                        
  5151                        ; save FAC1 sign
  5152                        
  5153                        LAB_24F5
  5154 FF:4303: 85 B0        	STA	<FAC1_s		; save FAC1 sign (b7)
  5155 FF:4305: 60           	RTS
  5156                        
  5157                        ; add FAC2 mantissa to FAC1 mantissa
  5158                        
  5159                        LAB_24F8
  5160 FF:4306: 65 A3        	ADC	<FAC2_r		; add FAC2 rounding byte
  5161 FF:4308: 85 B9        	STA	<FAC1_r		; save FAC1 rounding byte
  5162 FF:430A: A5 AF        	LDA	<FAC1_3		; get FAC1 mantissa3
  5163 FF:430C: 65 B6        	ADC	<FAC2_3		; add FAC2 mantissa3
  5164 FF:430E: 85 AF        	STA	<FAC1_3		; save FAC1 mantissa3
  5165 FF:4310: A5 AE        	LDA	<FAC1_2		; get FAC1 mantissa2
  5166 FF:4312: 65 B5        	ADC	<FAC2_2		; add FAC2 mantissa2
  5167 FF:4314: 85 AE        	STA	<FAC1_2		; save FAC1 mantissa2
  5168 FF:4316: A5 AD        	LDA	<FAC1_1		; get FAC1 mantissa1
  5169 FF:4318: 65 B4        	ADC	<FAC2_1		; add FAC2 mantissa1
  5170 FF:431A: 85 AD        	STA	<FAC1_1		; save FAC1 mantissa1
  5171 FF:431C: B0 1A        	BCS	LAB_252A		; if carry then normalise FAC1 for C=1
  Sun Nov 21 2021 15:13                                                                                                Page 187


  5172                        
  5173 FF:431E: 60           	RTS				; else just exit
  5174                        
  5175                        LAB_2511
  5176 FF:431F: 69 01        	ADC	#$01			; add 1 to exponent offset
  5177 FF:4321: 06 B9        	ASL	<FAC1_r		; shift FAC1 rounding byte
  5178 FF:4323: 26 AF        	ROL	<FAC1_3		; shift FAC1 mantissa3
  5179 FF:4325: 26 AE        	ROL	<FAC1_2		; shift FAC1 mantissa2
  5180 FF:4327: 26 AD        	ROL	<FAC1_1		; shift FAC1 mantissa1
  5181                        
  5182                        ; normalise FAC1
  5183                        
  5184                        LAB_251B
  5185 FF:4329: 10 F4        	BPL	LAB_2511		; loop if not normalised
  5186                        
  5187 FF:432B: 38           	SEC				; set carry for subtract
  5188 FF:432C: E5 AC        	SBC	<FAC1_e		; subtract FAC1 exponent
  5189 FF:432E: B0 CF        	BCS	LAB_24F1		; branch if underflow (set result = $0)
  5190                        
  5191 FF:4330: 49 FF        	EOR	#$FF			; complement exponent
  5192 FF:4332: 69 01        	ADC	#$01			; +1 (twos complement)
  5193 FF:4334: 85 AC        	STA	<FAC1_e		; save FAC1 exponent
  5194                        
  5195                        ; test and normalise FAC1 for C=0/1
  5196                        
  5197                        LAB_2528
  5198 FF:4336: 90 0C        	BCC	LAB_2536		; exit if no overflow
  5199                        
  5200                        ; normalise FAC1 for C=1
  5201                        
  5202                        LAB_252A
  5203 FF:4338: E6 AC        	INC	<FAC1_e		; increment FAC1 exponent
  5204 FF:433A: F0 36        	BEQ	LAB_2564		; if zero do overflow error and warm start
  5205                        
  5206 FF:433C: 66 AD        	ROR	<FAC1_1		; shift FAC1 mantissa1
  5207 FF:433E: 66 AE        	ROR	<FAC1_2		; shift FAC1 mantissa2
  5208 FF:4340: 66 AF        	ROR	<FAC1_3		; shift FAC1 mantissa3
  5209 FF:4342: 66 B9        	ROR	<FAC1_r		; shift FAC1 rounding byte
  5210                        LAB_2536
  5211 FF:4344: 60           	RTS
  5212                        
  5213                        ; negate FAC1
  5214                        
  5215                        LAB_2537
  5216 FF:4345: A5 B0        	LDA	<FAC1_s		; get FAC1 sign (b7)
  5217 FF:4347: 49 FF        	EOR	#$FF			; complement it
  5218 FF:4349: 85 B0        	STA	<FAC1_s		; save FAC1 sign (b7)
  5219                        
  5220                        ; twos complement FAC1 mantissa
  5221                        
  5222                        LAB_253D
  5223 FF:434B: A5 AD        	LDA	<FAC1_1		; get FAC1 mantissa1
  5224 FF:434D: 49 FF        	EOR	#$FF			; complement it
  5225 FF:434F: 85 AD        	STA	<FAC1_1		; save FAC1 mantissa1
  5226 FF:4351: A5 AE        	LDA	<FAC1_2		; get FAC1 mantissa2
  5227 FF:4353: 49 FF        	EOR	#$FF			; complement it
  5228 FF:4355: 85 AE        	STA	<FAC1_2		; save FAC1 mantissa2
  Sun Nov 21 2021 15:13                                                                                                Page 188


  5229 FF:4357: A5 AF        	LDA	<FAC1_3		; get FAC1 mantissa3
  5230 FF:4359: 49 FF        	EOR	#$FF			; complement it
  5231 FF:435B: 85 AF        	STA	<FAC1_3		; save FAC1 mantissa3
  5232 FF:435D: A5 B9        	LDA	<FAC1_r		; get FAC1 rounding byte
  5233 FF:435F: 49 FF        	EOR	#$FF			; complement it
  5234 FF:4361: 85 B9        	STA	<FAC1_r		; save FAC1 rounding byte
  5235 FF:4363: E6 B9        	INC	<FAC1_r		; increment FAC1 rounding byte
  5236 FF:4365: D0 0A        	BNE	LAB_2563		; exit if no overflow
  5237                        
  5238                        ; increment FAC1 mantissa
  5239                        
  5240                        LAB_2559
  5241 FF:4367: E6 AF        	INC	<FAC1_3		; increment FAC1 mantissa3
  5242 FF:4369: D0 06        	BNE	LAB_2563		; finished if no rollover
  5243                        
  5244 FF:436B: E6 AE        	INC	<FAC1_2		; increment FAC1 mantissa2
  5245 FF:436D: D0 02        	BNE	LAB_2563		; finished if no rollover
  5246                        
  5247 FF:436F: E6 AD        	INC	<FAC1_1		; increment FAC1 mantissa1
  5248                        LAB_2563
  5249 FF:4371: 60           	RTS
  5250                        
  5251                        ; do overflow error (overflow exit)
  5252                        
  5253                        LAB_2564
  5254 FF:4372: A2 0A        	LDX	#$0A			; error code $0A ("Overflow" error)
  5255 FF:4374: 4C C1 28     	JMP	LAB_XERR		; do error #X, then warm start
  5256                        
  5257                        ; shift FCAtemp << A+8 times
  5258                        
  5259                        LAB_2569
  5260 FF:4377: A2 74        	LDX	#<FACt_1-1		; set offset to FACtemp
  5261                        LAB_256B
  5262 FF:4379: B4 03        	LDY	<PLUS_3,X		; get FACX mantissa3
  5263 FF:437B: 84 B9        	STY	<FAC1_r			; save as FAC1 rounding byte
  5264 FF:437D: B4 02        	LDY	<PLUS_2,X		; get FACX mantissa2
  5265 FF:437F: 94 03        	STY <PLUS_3,X		; save FACX mantissa3
  5266 FF:4381: B4 01        	LDY	<PLUS_1,X		; get FACX mantissa1
  5267 FF:4383: 94 02        	STY <PLUS_2,X		; save FACX mantissa2
  5268 FF:4385: A4 B2        	LDY	<FAC1_o			; get FAC1 overflow byte
  5269 FF:4387: 94 01        	STY <PLUS_1,X 		; save FACX mantissa1
  5270                        
  5271                        ; shift FACX -A times right (> 8 shifts)
  5272                        
  5273                        LAB_257B
  5274 FF:4389: 69 08        	ADC	#$08			; add 8 to shift count
  5275 FF:438B: 30 EC        	BMI	LAB_256B		; go do 8 shift if still -ve
  5276                        
  5277 FF:438D: F0 EA        	BEQ	LAB_256B		; go do 8 shift if zero
  5278                        
  5279 FF:438F: E9 08        	SBC	#$08			; else subtract 8 again
  5280 FF:4391: A8           	TAY				; save count to Y
  5281 FF:4392: A5 B9        	LDA	<FAC1_r		; get FAC1 rounding byte
  5282 FF:4394: B0 12        	BCS	LAB_259A		;.
  5283                        
  5284                        LAB_2588
  5285 FF:4396: 16 01        	ASL	<PLUS_1,X		; shift FACX mantissa1
  Sun Nov 21 2021 15:13                                                                                                Page 189


  5286 FF:4398: 90 02        	BCC	LAB_258E		; branch if +ve
  5287                        
  5288 FF:439A: F6 01        	INC	<PLUS_1,X		; this sets b7 eventually
  5289                        LAB_258E
  5290 FF:439C: 76 01        	ROR	<PLUS_1,X		; shift FACX mantissa1 (correct for ASL)
  5291 FF:439E: 76 01        	ROR	<PLUS_1,X		; shift FACX mantissa1 (put carry in b7)
  5292                        
  5293                        ; shift FACX Y times right
  5294                        
  5295                        LAB_2592
  5296 FF:43A0: 76 02        	ROR	<PLUS_2,X		; shift FACX mantissa2
  5297 FF:43A2: 76 03        	ROR	<PLUS_3,X		; shift FACX mantissa3
  5298 FF:43A4: 6A           	ROR	A			; shift FACX rounding byte
  5299 FF:43A5: C8           	INY				; increment exponent diff
  5300 FF:43A6: D0 EE        	BNE	LAB_2588		; branch if range adjust not complete
  5301                        
  5302                        LAB_259A
  5303 FF:43A8: 18           	CLC				; just clear it
  5304 FF:43A9: 60           	RTS
  5305                        
  5306                        ; perform LOG()
  5307                        
  5308                        LAB_LOG
  5309 FF:43AA: 20 88 46     	JSR	LAB_27CA		; test sign and zero
  5310 FF:43AD: F0 02        	BEQ	LAB_25C4		; if zero do function call error then warm start
  5311                        
  5312 FF:43AF: 10 03        	BPL	LAB_25C7		; skip error if +ve
  5313                        
  5314                        LAB_25C4
  5315 FF:43B1: 4C 87 38     	JMP	LAB_FCER		; do function call error then warm start (-ve)
  5316                        
  5317                        LAB_25C7
  5318 FF:43B4: A5 AC        	LDA	<FAC1_e		; get FAC1 exponent
  5319 FF:43B6: E9 7F        	SBC	#$7F			; normalise it
  5320 FF:43B8: 48           	PHA				; save it
  5321 FF:43B9: A9 80        	LDA	#$80			; set exponent to zero
  5322 FF:43BB: 85 AC        	STA	<FAC1_e		; save FAC1 exponent
  5323 FF:43BD: A9 23        	LDA	#<LAB_25AD		; set 1/root2 pointer low byte
  5324 FF:43BF: A0 18        	LDY	#>LAB_25AD		; set 1/root2 pointer high byte
  5325 FF:43C1: 20 67 42     	JSR	LAB_246C		; add (AY) to FAC1 (1/root2)
  5326 FF:43C4: A9 27        	LDA	#<LAB_25B1		; set root2 pointer low byte
  5327 FF:43C6: A0 18        	LDY	#>LAB_25B1		; set root2 pointer high byte
  5328 FF:43C8: 20 00 45     	JSR	LAB_26CA		; convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
  5329 FF:43CB: A9 9A        	LDA	#<LAB_259C		; set 1 pointer low byte
  5330 FF:43CD: A0 18        	LDY	#>LAB_259C		; set 1 pointer high byte
  5331 FF:43CF: 20 4C 42     	JSR	LAB_2455		; subtract (AY) from FAC1 ((root2/(x+(1/root2)))-1)
  5332 FF:43D2: A9 16        	LDA	#<LAB_25A0		; set pointer low byte to counter
  5333 FF:43D4: A0 18        	LDY	#>LAB_25A0		; set pointer high byte to counter
  5334 FF:43D6: 20 89 4A     	JSR	LAB_2B6E		; ^2 then series evaluation
  5335 FF:43D9: A9 2B        	LDA	#<LAB_25B5		; set -0.5 pointer low byte
  5336 FF:43DB: A0 18        	LDY	#>LAB_25B5		; set -0.5 pointer high byte
  5337 FF:43DD: 20 67 42     	JSR	LAB_246C		; add (AY) to FAC1
  5338 FF:43E0: 68           	PLA				; restore FAC1 exponent
  5339 FF:43E1: 20 4F 48     	JSR	LAB_2912		; evaluate new ASCII digit
  5340 FF:43E4: A9 2F        	LDA	#<LAB_25B9		; set LOG(2) pointer low byte
  5341 FF:43E6: A0 18        	LDY	#>LAB_25B9		; set LOG(2) pointer high byte
  5342                        
  Sun Nov 21 2021 15:13                                                                                                Page 190


  5343                        ; do convert AY, FCA1*(AY)
  5344                        
  5345                        LAB_25FB
  5346 FF:43E8: 20 3A 44     	JSR	LAB_264D		; unpack memory (AY) into FAC2
  5347                        LAB_MULTIPLY
  5348 FF:43EB: F0 4C        	BEQ	LAB_264C		; exit if zero
  5349                        
  5350 FF:43ED: 20 B0 44     	JSR	LAB_2673		; test and adjust accumulators
  5351 FF:43F0: A9 00        	LDA	#$00			; clear A
  5352 FF:43F2: 85 75        	STA	<FACt_1		; clear temp mantissa1
  5353 FF:43F4: 85 76        	STA	<FACt_2		; clear temp mantissa2
  5354 FF:43F6: 85 77        	STA	<FACt_3		; clear temp mantissa3
  5355 FF:43F8: A5 B9        	LDA	<FAC1_r		; get FAC1 rounding byte
  5356 FF:43FA: 20 0F 44     	JSR	LAB_2622		; go do shift/add FAC2
  5357 FF:43FD: A5 AF        	LDA	<FAC1_3		; get FAC1 mantissa3
  5358 FF:43FF: 20 0F 44     	JSR	LAB_2622		; go do shift/add FAC2
  5359 FF:4402: A5 AE        	LDA	<FAC1_2		; get FAC1 mantissa2
  5360 FF:4404: 20 0F 44     	JSR	LAB_2622		; go do shift/add FAC2
  5361 FF:4407: A5 AD        	LDA	<FAC1_1		; get FAC1 mantissa1
  5362 FF:4409: 20 14 44     	JSR	LAB_2627		; go do shift/add FAC2
  5363 FF:440C: 4C 6D 45     	JMP	LAB_273C		; copy temp to FAC1, normalise and return
  5364                        
  5365                        LAB_2622
  5366 FF:440F: D0 03        	BNE	LAB_2627		; branch if byte <> zero
  5367                        
  5368 FF:4411: 4C 77 43     	JMP	LAB_2569		; shift FCAtemp << A+8 times
  5369                        
  5370                        					; else do shift and add
  5371                        LAB_2627
  5372 FF:4414: 4A           	LSR	A			; shift byte
  5373 FF:4415: 09 80        	ORA	#$80			; set top bit (mark for 8 times)
  5374                        LAB_262A
  5375 FF:4417: A8           	TAY				; copy result
  5376 FF:4418: 90 13        	BCC	LAB_2640		; skip next if bit was zero
  5377                        
  5378 FF:441A: 18           	CLC				; clear carry for add
  5379 FF:441B: A5 77        	LDA	<FACt_3		; get temp mantissa3
  5380 FF:441D: 65 B6        	ADC	<FAC2_3		; add FAC2 mantissa3
  5381 FF:441F: 85 77        	STA	<FACt_3		; save temp mantissa3
  5382 FF:4421: A5 76        	LDA	<FACt_2		; get temp mantissa2
  5383 FF:4423: 65 B5        	ADC	<FAC2_2		; add FAC2 mantissa2
  5384 FF:4425: 85 76        	STA	<FACt_2		; save temp mantissa2
  5385 FF:4427: A5 75        	LDA	<FACt_1		; get temp mantissa1
  5386 FF:4429: 65 B4        	ADC	<FAC2_1		; add FAC2 mantissa1
  5387 FF:442B: 85 75        	STA	<FACt_1		; save temp mantissa1
  5388                        LAB_2640
  5389 FF:442D: 66 75        	ROR	<FACt_1		; shift temp mantissa1
  5390 FF:442F: 66 76        	ROR	<FACt_2		; shift temp mantissa2
  5391 FF:4431: 66 77        	ROR	<FACt_3		; shift temp mantissa3
  5392 FF:4433: 66 B9        	ROR	<FAC1_r		; shift temp rounding byte
  5393 FF:4435: 98           	TYA				; get byte back
  5394 FF:4436: 4A           	LSR	A			; shift byte
  5395 FF:4437: D0 DE        	BNE	LAB_262A		; loop if all bits not done
  5396                        
  5397                        LAB_264C
  5398 FF:4439: 60           	RTS
  5399                        
  Sun Nov 21 2021 15:13                                                                                                Page 191


  5400                        ; unpack memory (AY) into FAC2
  5401                        
  5402                        LAB_264D
  5403 FF:443A: 85 71        	STA	<ut1_pl		; save pointer low byte
  5404 FF:443C: 84 72        	STY	<ut1_ph		; save pointer high byte
  5405 FF:443E: A0 03        	LDY	#$03			; 4 bytes to get (0-3)
  5406                        	LDAINDIRECTY ut1_pl		; get mantissa3
+ 5406 FF:4440: 8B               PHB
+ 5406 FF:4441: DA           	PHX
+ 5406 FF:4442: A2 01            LDX #$01
+ 5406 FF:4444: B5 71            LDA <ut1_pl,X
+ 5406 FF:4446: C9 00            CMP #$00
+ 5406 FF:4448: D0 04            BNE *+6
+ 5406 FF:444A: A2 00        	LDX #00
+ 5406 FF:444C: DA           	PHX
+ 5406 FF:444D: AB           	PLB
+ 5406 FF:444E: FA               PLX
+ 5406 FF:444F: B1 71        	LDA	(<ut1_pl),Y		;
+ 5406 FF:4451: 85 04            STA <TMPFLG
+ 5406 FF:4453: AB               PLB
+ 5406 FF:4454: A5 04            LDA <TMPFLG
  5407 FF:4456: 85 B6        	STA	<FAC2_3		; save FAC2 mantissa3
  5408 FF:4458: 88           	DEY				; decrement index
  5409                        	LDAINDIRECTY ut1_pl		; get mantissa2
+ 5409 FF:4459: 8B               PHB
+ 5409 FF:445A: DA           	PHX
+ 5409 FF:445B: A2 01            LDX #$01
+ 5409 FF:445D: B5 71            LDA <ut1_pl,X
+ 5409 FF:445F: C9 00            CMP #$00
+ 5409 FF:4461: D0 04            BNE *+6
+ 5409 FF:4463: A2 00        	LDX #00
+ 5409 FF:4465: DA           	PHX
+ 5409 FF:4466: AB           	PLB
+ 5409 FF:4467: FA               PLX
+ 5409 FF:4468: B1 71        	LDA	(<ut1_pl),Y		;
+ 5409 FF:446A: 85 04            STA <TMPFLG
+ 5409 FF:446C: AB               PLB
+ 5409 FF:446D: A5 04            LDA <TMPFLG
  5410 FF:446F: 85 B5        	STA	<FAC2_2		; save FAC2 mantissa2
  5411 FF:4471: 88           	DEY				; decrement index
  5412                        	LDAINDIRECTY ut1_pl		; get mantissa1+sign
+ 5412 FF:4472: 8B               PHB
+ 5412 FF:4473: DA           	PHX
+ 5412 FF:4474: A2 01            LDX #$01
+ 5412 FF:4476: B5 71            LDA <ut1_pl,X
+ 5412 FF:4478: C9 00            CMP #$00
+ 5412 FF:447A: D0 04            BNE *+6
+ 5412 FF:447C: A2 00        	LDX #00
+ 5412 FF:447E: DA           	PHX
+ 5412 FF:447F: AB           	PLB
+ 5412 FF:4480: FA               PLX
+ 5412 FF:4481: B1 71        	LDA	(<ut1_pl),Y		;
+ 5412 FF:4483: 85 04            STA <TMPFLG
+ 5412 FF:4485: AB               PLB
+ 5412 FF:4486: A5 04            LDA <TMPFLG
  5413 FF:4488: 85 B7        	STA	<FAC2_s		; save FAC2 sign (b7)
  5414 FF:448A: 45 B0        	EOR	<FAC1_s		; EOR with FAC1 sign (b7)
  Sun Nov 21 2021 15:13                                                                                                Page 192


  5415 FF:448C: 85 B8        	STA	<FAC_sc		; save sign compare (FAC1 EOR FAC2)
  5416 FF:448E: A5 B7        	LDA	<FAC2_s		; recover FAC2 sign (b7)
  5417 FF:4490: 09 80        	ORA	#$80			; set 1xxx xxx (set normal bit)
  5418 FF:4492: 85 B4        	STA	<FAC2_1		; save FAC2 mantissa1
  5419 FF:4494: 88           	DEY				; decrement index
  5420                        	LDAINDIRECTY ut1_pl		; get exponent byte
+ 5420 FF:4495: 8B               PHB
+ 5420 FF:4496: DA           	PHX
+ 5420 FF:4497: A2 01            LDX #$01
+ 5420 FF:4499: B5 71            LDA <ut1_pl,X
+ 5420 FF:449B: C9 00            CMP #$00
+ 5420 FF:449D: D0 04            BNE *+6
+ 5420 FF:449F: A2 00        	LDX #00
+ 5420 FF:44A1: DA           	PHX
+ 5420 FF:44A2: AB           	PLB
+ 5420 FF:44A3: FA               PLX
+ 5420 FF:44A4: B1 71        	LDA	(<ut1_pl),Y		;
+ 5420 FF:44A6: 85 04            STA <TMPFLG
+ 5420 FF:44A8: AB               PLB
+ 5420 FF:44A9: A5 04            LDA <TMPFLG
  5421 FF:44AB: 85 B3        	STA	<FAC2_e		; save FAC2 exponent
  5422 FF:44AD: A5 AC        	LDA	<FAC1_e		; get FAC1 exponent
  5423 FF:44AF: 60           	RTS
  5424                        
  5425                        ; test and adjust accumulators
  5426                        
  5427                        LAB_2673
  5428 FF:44B0: A5 B3        	LDA	<FAC2_e		; get FAC2 exponent
  5429                        LAB_2675
  5430 FF:44B2: F0 1D        	BEQ	LAB_2696		; branch if FAC2 = $00 (handle underflow)
  5431                        
  5432 FF:44B4: 18           	CLC				; clear carry for add
  5433 FF:44B5: 65 AC        	ADC	<FAC1_e		; add FAC1 exponent
  5434 FF:44B7: 90 04        	BCC	LAB_2680		; branch if sum of exponents <$0100
  5435                        
  5436 FF:44B9: 30 31        	BMI	LAB_269B		; do overflow error
  5437                        
  5438 FF:44BB: 18           	CLC				; clear carry for the add
  5439 FF:44BC: 2C           	.byte	$2C			; makes next line BIT $1410
  5440                        LAB_2680
  5441 FF:44BD: 10 12        	BPL	LAB_2696		; if +ve go handle underflow
  5442                        
  5443 FF:44BF: 69 80        	ADC	#$80			; adjust exponent
  5444 FF:44C1: 85 AC        	STA	<FAC1_e		; save FAC1 exponent
  5445 FF:44C3: D0 03        	BNE	LAB_268B		; branch if not zero
  5446                        
  5447 FF:44C5: 4C 03 43     	JMP	LAB_24F5		; save FAC1 sign and return
  5448                        
  5449                        LAB_268B
  5450 FF:44C8: A5 B8        	LDA	<FAC_sc		; get sign compare (FAC1 EOR FAC2)
  5451 FF:44CA: 85 B0        	STA	<FAC1_s		; save FAC1 sign (b7)
  5452                        LAB_268F
  5453 FF:44CC: 60           	RTS
  5454                        
  5455                        ; handle overflow and underflow
  5456                        
  5457                        LAB_2690
  Sun Nov 21 2021 15:13                                                                                                Page 193


  5458 FF:44CD: A5 B0        	LDA	<FAC1_s		; get FAC1 sign (b7)
  5459 FF:44CF: 10 1B        	BPL	LAB_269B		; do overflow error
  5460                        
  5461                        					; handle underflow
  5462                        LAB_2696
  5463 FF:44D1: 68           	PLA				; pop return address low byte
  5464 FF:44D2: 68           	PLA				; pop return address high byte
  5465 FF:44D3: 4C FF 42     	JMP	LAB_24F1		; clear FAC1 exponent and sign and return
  5466                        
  5467                        ; multiply by 10
  5468                        
  5469                        LAB_269E
  5470 FF:44D6: 20 69 46     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
  5471 FF:44D9: AA           	TAX				; copy exponent (set the flags)
  5472 FF:44DA: F0 F0        	BEQ	LAB_268F		; exit if zero
  5473 FF:44DC: 18           	CLC				; clear carry for add
  5474 FF:44DD: 69 02        	ADC	#$02			; add two to exponent (*4)
  5475 FF:44DF: B0 0B        	BCS	LAB_269B		; do overflow error if > $FF
  5476 FF:44E1: A2 00        	LDX	#$00			; clear byte
  5477 FF:44E3: 86 B8        	STX	<FAC_sc		; clear sign compare (FAC1 EOR FAC2)
  5478 FF:44E5: 20 84 42     	JSR	LAB_247C		; add FAC2 to FAC1 (*5)
  5479 FF:44E8: E6 AC        	INC	<FAC1_e		; increment FAC1 exponent (*10)
  5480 FF:44EA: D0 E0        	BNE	LAB_268F		; if non zero just do RTS
  5481                        
  5482                        LAB_269B
  5483 FF:44EC: 4C 72 43     	JMP	LAB_2564		; do overflow error and warm start
  5484                        
  5485                        ; divide by 10
  5486                        
  5487                        LAB_26B9
  5488 FF:44EF: 20 69 46     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
  5489 FF:44F2: A9 AB        	LDA	#<LAB_26B5		; set pointer to 10d low addr
  5490 FF:44F4: A0 18        	LDY	#>LAB_26B5		; set pointer to 10d high addr
  5491 FF:44F6: A2 00        	LDX	#$00			; clear sign
  5492                        
  5493                        ; divide by (AY) (X=sign)
  5494                        
  5495                        LAB_26C2
  5496 FF:44F8: 86 B8        	STX	<FAC_sc		; save sign compare (FAC1 EOR FAC2)
  5497 FF:44FA: 20 7C 45     	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
  5498 FF:44FD: 4C 03 45     	JMP	LAB_DIVIDE		; do FAC2/FAC1
  5499                        
  5500                        					; Perform divide-by
  5501                        ; convert AY and do (AY)/FAC1
  5502                        
  5503                        LAB_26CA
  5504 FF:4500: 20 3A 44     	JSR	LAB_264D		; unpack memory (AY) into FAC2
  5505                        
  5506                        					; Perform divide-into
  5507                        LAB_DIVIDE
  5508 FF:4503: F0 63        	BEQ	LAB_2737		; if zero go do /0 error
  5509                        
  5510 FF:4505: 20 78 46     	JSR	LAB_27BA		; round FAC1
  5511 FF:4508: A9 00        	LDA	#$00			; clear A
  5512 FF:450A: 38           	SEC				; set carry for subtract
  5513 FF:450B: E5 AC        	SBC	<FAC1_e		; subtract FAC1 exponent (2s complement)
  5514 FF:450D: 85 AC        	STA	<FAC1_e		; save FAC1 exponent
  Sun Nov 21 2021 15:13                                                                                                Page 194


  5515 FF:450F: 20 B0 44     	JSR	LAB_2673		; test and adjust accumulators
  5516 FF:4512: E6 AC        	INC	<FAC1_e		; increment FAC1 exponent
  5517 FF:4514: F0 D6        	BEQ	LAB_269B		; if zero do overflow error
  5518                        
  5519 FF:4516: A2 FF        	LDX	#$FF			; set index for pre increment
  5520 FF:4518: A9 01        	LDA	#$01			; set bit to flag byte save
  5521                        LAB_26E4
  5522 FF:451A: A4 B4        	LDY	<FAC2_1		; get FAC2 mantissa1
  5523 FF:451C: C4 AD        	CPY	<FAC1_1		; compare FAC1 mantissa1
  5524 FF:451E: D0 0A        	BNE	LAB_26F4		; branch if <>
  5525                        
  5526 FF:4520: A4 B5        	LDY	<FAC2_2		; get FAC2 mantissa2
  5527 FF:4522: C4 AE        	CPY	<FAC1_2		; compare FAC1 mantissa2
  5528 FF:4524: D0 04        	BNE	LAB_26F4		; branch if <>
  5529                        
  5530 FF:4526: A4 B6        	LDY	<FAC2_3		; get FAC2 mantissa3
  5531 FF:4528: C4 AF        	CPY	<FAC1_3		; compare FAC1 mantissa3
  5532                        LAB_26F4
  5533 FF:452A: 08           	PHP				; save FAC2-FAC1 compare status
  5534 FF:452B: 2A           	ROL	A			; shift the result byte
  5535 FF:452C: 90 0E        	BCC	LAB_2702		; if no carry skip the byte save
  5536                        
  5537 FF:452E: A0 01        	LDY	#$01			; set bit to flag byte save
  5538 FF:4530: E8           	INX				; else increment the index to FACt
  5539 FF:4531: E0 02        	CPX	#$02			; compare with the index to <FACt_3
  5540 FF:4533: 30 04        	BMI	LAB_2701		; if not last byte just go save it
  5541                        
  5542 FF:4535: D0 28        	BNE	LAB_272B		; if all done go save FAC1 rounding byte, normalise and
  5543                        					; return
  5544                        
  5545 FF:4537: A0 40        	LDY	#$40			; set bit to flag byte save for the rounding byte
  5546                        LAB_2701
  5547 FF:4539: 95 75        	STA	<FACt_1,X		; write result byte to <FACt_1 + index
  5548 FF:453B: 98           	TYA				; copy the next save byte flag
  5549                        LAB_2702
  5550 FF:453C: 28           	PLP				; restore FAC2-FAC1 compare status
  5551 FF:453D: 90 14        	BCC	LAB_2704		; if FAC2 < FAC1 then skip the subtract
  5552                        
  5553 FF:453F: A8           	TAY				; save FAC2-FAC1 compare status
  5554 FF:4540: A5 B6        	LDA	<FAC2_3		; get FAC2 mantissa3
  5555 FF:4542: E5 AF        	SBC	<FAC1_3		; subtract FAC1 mantissa3
  5556 FF:4544: 85 B6        	STA	<FAC2_3		; save FAC2 mantissa3
  5557 FF:4546: A5 B5        	LDA	<FAC2_2		; get FAC2 mantissa2
  5558 FF:4548: E5 AE        	SBC	<FAC1_2		; subtract FAC1 mantissa2
  5559 FF:454A: 85 B5        	STA	<FAC2_2		; save FAC2 mantissa2
  5560 FF:454C: A5 B4        	LDA	<FAC2_1		; get FAC2 mantissa1
  5561 FF:454E: E5 AD        	SBC	<FAC1_1		; subtract FAC1 mantissa1
  5562 FF:4550: 85 B4        	STA	<FAC2_1		; save FAC2 mantissa1
  5563 FF:4552: 98           	TYA				; restore FAC2-FAC1 compare status
  5564                        
  5565                        					; FAC2 = FAC2*2
  5566                        LAB_2704
  5567 FF:4553: 06 B6        	ASL	<FAC2_3		; shift FAC2 mantissa3
  5568 FF:4555: 26 B5        	ROL	<FAC2_2		; shift FAC2 mantissa2
  5569 FF:4557: 26 B4        	ROL	<FAC2_1		; shift FAC2 mantissa1
  5570 FF:4559: B0 CF        	BCS	LAB_26F4		; loop with no compare
  5571                        
  Sun Nov 21 2021 15:13                                                                                                Page 195


  5572 FF:455B: 30 BD        	BMI	LAB_26E4		; loop with compare
  5573                        
  5574 FF:455D: 10 CB        	BPL	LAB_26F4		; loop always with no compare
  5575                        
  5576                        ; do A<<6, save as FAC1 rounding byte, normalise and return
  5577                        
  5578                        LAB_272B
  5579 FF:455F: 4A           	LSR	A			; shift b1 - b0 ..
  5580 FF:4560: 6A           	ROR	A				; ..
  5581 FF:4561: 6A           	ROR	A			; .. to b7 - b6
  5582 FF:4562: 85 B9        	STA	<FAC1_r		; save FAC1 rounding byte
  5583 FF:4564: 28           	PLP				; dump FAC2-FAC1 compare status
  5584 FF:4565: 4C 6D 45     	JMP	LAB_273C		; copy temp to FAC1, normalise and return
  5585                        
  5586                        ; do "Divide by zero" error
  5587                        
  5588                        LAB_2737
  5589 FF:4568: A2 14        	LDX	#$14			; error code $14 ("Divide by zero" error)
  5590 FF:456A: 4C C1 28     	JMP	LAB_XERR		; do error #X, then warm start
  5591                        
  5592                        ; copy temp to FAC1 and normalise
  5593                        
  5594                        LAB_273C
  5595 FF:456D: A5 75        	LDA	<FACt_1		; get temp mantissa1
  5596 FF:456F: 85 AD        	STA	<FAC1_1		; save FAC1 mantissa1
  5597 FF:4571: A5 76        	LDA	<FACt_2		; get temp mantissa2
  5598 FF:4573: 85 AE        	STA	<FAC1_2		; save FAC1 mantissa2
  5599 FF:4575: A5 77        	LDA	<FACt_3		; get temp mantissa3
  5600 FF:4577: 85 AF        	STA	<FAC1_3		; save FAC1 mantissa3
  5601 FF:4579: 4C E3 42     	JMP	LAB_24D5		; normalise FAC1 and return
  5602                        
  5603                        ; unpack memory (AY) into FAC1
  5604                        
  5605                        LAB_UFAC
  5606 FF:457C: 85 71        	STA	<ut1_pl		; save pointer low byte
  5607 FF:457E: 84 72        	STY	<ut1_ph		; save pointer high byte
  5608 FF:4580: A0 03        	LDY	#$03			; 4 bytes to do
  5609                        	LDAINDIRECTY ut1_pl		; get last byte
+ 5609 FF:4582: 8B               PHB
+ 5609 FF:4583: DA           	PHX
+ 5609 FF:4584: A2 01            LDX #$01
+ 5609 FF:4586: B5 71            LDA <ut1_pl,X
+ 5609 FF:4588: C9 00            CMP #$00
+ 5609 FF:458A: D0 04            BNE *+6
+ 5609 FF:458C: A2 00        	LDX #00
+ 5609 FF:458E: DA           	PHX
+ 5609 FF:458F: AB           	PLB
+ 5609 FF:4590: FA               PLX
+ 5609 FF:4591: B1 71        	LDA	(<ut1_pl),Y		;
+ 5609 FF:4593: 85 04            STA <TMPFLG
+ 5609 FF:4595: AB               PLB
+ 5609 FF:4596: A5 04            LDA <TMPFLG
  5610 FF:4598: 85 AF        	STA	<FAC1_3		; save FAC1 mantissa3
  5611 FF:459A: 88           	DEY				; decrement index
  5612                        	LDAINDIRECTY ut1_pl		; get last-1 byte
+ 5612 FF:459B: 8B               PHB
+ 5612 FF:459C: DA           	PHX
  Sun Nov 21 2021 15:13                                                                                                Page 196


+ 5612 FF:459D: A2 01            LDX #$01
+ 5612 FF:459F: B5 71            LDA <ut1_pl,X
+ 5612 FF:45A1: C9 00            CMP #$00
+ 5612 FF:45A3: D0 04            BNE *+6
+ 5612 FF:45A5: A2 00        	LDX #00
+ 5612 FF:45A7: DA           	PHX
+ 5612 FF:45A8: AB           	PLB
+ 5612 FF:45A9: FA               PLX
+ 5612 FF:45AA: B1 71        	LDA	(<ut1_pl),Y		;
+ 5612 FF:45AC: 85 04            STA <TMPFLG
+ 5612 FF:45AE: AB               PLB
+ 5612 FF:45AF: A5 04            LDA <TMPFLG
  5613 FF:45B1: 85 AE        	STA	<FAC1_2		; save FAC1 mantissa2
  5614 FF:45B3: 88           	DEY				; decrement index
  5615                        	LDAINDIRECTY ut1_pl		; get second byte
+ 5615 FF:45B4: 8B               PHB
+ 5615 FF:45B5: DA           	PHX
+ 5615 FF:45B6: A2 01            LDX #$01
+ 5615 FF:45B8: B5 71            LDA <ut1_pl,X
+ 5615 FF:45BA: C9 00            CMP #$00
+ 5615 FF:45BC: D0 04            BNE *+6
+ 5615 FF:45BE: A2 00        	LDX #00
+ 5615 FF:45C0: DA           	PHX
+ 5615 FF:45C1: AB           	PLB
+ 5615 FF:45C2: FA               PLX
+ 5615 FF:45C3: B1 71        	LDA	(<ut1_pl),Y		;
+ 5615 FF:45C5: 85 04            STA <TMPFLG
+ 5615 FF:45C7: AB               PLB
+ 5615 FF:45C8: A5 04            LDA <TMPFLG
  5616 FF:45CA: 85 B0        	STA	<FAC1_s		; save FAC1 sign (b7)
  5617 FF:45CC: 09 80        	ORA	#$80			; set 1xxx xxxx (add normal bit)
  5618 FF:45CE: 85 AD        	STA	<FAC1_1		; save FAC1 mantissa1
  5619 FF:45D0: 88           	DEY				; decrement index
  5620                        	LDAINDIRECTY ut1_pl		; get first byte (exponent)
+ 5620 FF:45D1: 8B               PHB
+ 5620 FF:45D2: DA           	PHX
+ 5620 FF:45D3: A2 01            LDX #$01
+ 5620 FF:45D5: B5 71            LDA <ut1_pl,X
+ 5620 FF:45D7: C9 00            CMP #$00
+ 5620 FF:45D9: D0 04            BNE *+6
+ 5620 FF:45DB: A2 00        	LDX #00
+ 5620 FF:45DD: DA           	PHX
+ 5620 FF:45DE: AB           	PLB
+ 5620 FF:45DF: FA               PLX
+ 5620 FF:45E0: B1 71        	LDA	(<ut1_pl),Y		;
+ 5620 FF:45E2: 85 04            STA <TMPFLG
+ 5620 FF:45E4: AB               PLB
+ 5620 FF:45E5: A5 04            LDA <TMPFLG
  5621 FF:45E7: 85 AC        	STA	<FAC1_e		; save FAC1 exponent
  5622 FF:45E9: 84 B9        	STY	<FAC1_r		; clear FAC1 rounding byte
  5623 FF:45EB: 60           	RTS
  5624                        
  5625                        ; pack FAC1 into <Adatal
  5626                        
  5627                        LAB_276E
  5628 FF:45EC: A2 A4        	LDX	#<Adatal		; set pointer low byte
  5629                        LAB_2770
  Sun Nov 21 2021 15:13                                                                                                Page 197


  5630 FF:45EE: A0 00        	LDY	#>Adatal		; set pointer high byte
  5631 FF:45F0: F0 04        	BEQ	LAB_2778		; pack FAC1 into (XY) and return
  5632                        
  5633                        ; pack FAC1 into (<Lvarpl)
  5634                        
  5635                        LAB_PFAC
  5636 FF:45F2: A6 97        	LDX	<Lvarpl		; get destination pointer low byte
  5637 FF:45F4: A4 98        	LDY	<Lvarph		; get destination pointer high byte
  5638                        
  5639                        ; pack FAC1 into (XY)
  5640                        
  5641                        LAB_2778
  5642 FF:45F6: 20 78 46     	JSR	LAB_27BA		; round FAC1
  5643 FF:45F9: 86 71        	STX	<ut1_pl		; save pointer low byte
  5644 FF:45FB: 84 72        	STY	<ut1_ph		; save pointer high byte
  5645 FF:45FD: A0 03        	LDY	#$03			; set index
  5646 FF:45FF: A5 AF        	LDA	<FAC1_3		; get FAC1 mantissa3
  5647                        	STAINDIRECTY ut1_pl		; store in destination
+ 5647 FF:4601: 8B               PHB
+ 5647 FF:4602: DA           	PHX
+ 5647 FF:4603: 48               PHA
+ 5647 FF:4604: A2 01            LDX #$01
+ 5647 FF:4606: B5 71            LDA <ut1_pl,X
+ 5647 FF:4608: C9 00            CMP #$00
+ 5647 FF:460A: D0 04            BNE *+6
+ 5647 FF:460C: A2 00        	LDX #00
+ 5647 FF:460E: DA           	PHX
+ 5647 FF:460F: AB           	PLB
+ 5647 FF:4610: 68               PLA
+ 5647 FF:4611: FA               PLX
+ 5647 FF:4612: 91 71        	STA	(<ut1_pl),Y		;
+ 5647 FF:4614: AB           	PLB
+ 5647 FF:4615: 85 04            STA <TMPFLG
  5648 FF:4617: 88           	DEY				; decrement index
  5649 FF:4618: A5 AE        	LDA	<FAC1_2		; get FAC1 mantissa2
  5650                        	STAINDIRECTY ut1_pl		; store in destination
+ 5650 FF:461A: 8B               PHB
+ 5650 FF:461B: DA           	PHX
+ 5650 FF:461C: 48               PHA
+ 5650 FF:461D: A2 01            LDX #$01
+ 5650 FF:461F: B5 71            LDA <ut1_pl,X
+ 5650 FF:4621: C9 00            CMP #$00
+ 5650 FF:4623: D0 04            BNE *+6
+ 5650 FF:4625: A2 00        	LDX #00
+ 5650 FF:4627: DA           	PHX
+ 5650 FF:4628: AB           	PLB
+ 5650 FF:4629: 68               PLA
+ 5650 FF:462A: FA               PLX
+ 5650 FF:462B: 91 71        	STA	(<ut1_pl),Y		;
+ 5650 FF:462D: AB           	PLB
+ 5650 FF:462E: 85 04            STA <TMPFLG
  5651 FF:4630: 88           	DEY				; decrement index
  5652 FF:4631: A5 B0        	LDA	<FAC1_s		; get FAC1 sign (b7)
  5653 FF:4633: 09 7F        	ORA	#$7F			; set bits x111 1111
  5654 FF:4635: 25 AD        	AND	<FAC1_1		; AND in FAC1 mantissa1
  5655                        	STAINDIRECTY ut1_pl		; store in destination
+ 5655 FF:4637: 8B               PHB
  Sun Nov 21 2021 15:13                                                                                                Page 198


+ 5655 FF:4638: DA           	PHX
+ 5655 FF:4639: 48               PHA
+ 5655 FF:463A: A2 01            LDX #$01
+ 5655 FF:463C: B5 71            LDA <ut1_pl,X
+ 5655 FF:463E: C9 00            CMP #$00
+ 5655 FF:4640: D0 04            BNE *+6
+ 5655 FF:4642: A2 00        	LDX #00
+ 5655 FF:4644: DA           	PHX
+ 5655 FF:4645: AB           	PLB
+ 5655 FF:4646: 68               PLA
+ 5655 FF:4647: FA               PLX
+ 5655 FF:4648: 91 71        	STA	(<ut1_pl),Y		;
+ 5655 FF:464A: AB           	PLB
+ 5655 FF:464B: 85 04            STA <TMPFLG
  5656 FF:464D: 88           	DEY				; decrement index
  5657 FF:464E: A5 AC        	LDA	<FAC1_e		; get FAC1 exponent
  5658                        	STAINDIRECTY ut1_pl		; store in destination
+ 5658 FF:4650: 8B               PHB
+ 5658 FF:4651: DA           	PHX
+ 5658 FF:4652: 48               PHA
+ 5658 FF:4653: A2 01            LDX #$01
+ 5658 FF:4655: B5 71            LDA <ut1_pl,X
+ 5658 FF:4657: C9 00            CMP #$00
+ 5658 FF:4659: D0 04            BNE *+6
+ 5658 FF:465B: A2 00        	LDX #00
+ 5658 FF:465D: DA           	PHX
+ 5658 FF:465E: AB           	PLB
+ 5658 FF:465F: 68               PLA
+ 5658 FF:4660: FA               PLX
+ 5658 FF:4661: 91 71        	STA	(<ut1_pl),Y		;
+ 5658 FF:4663: AB           	PLB
+ 5658 FF:4664: 85 04            STA <TMPFLG
  5659 FF:4666: 84 B9        	STY	<FAC1_r		; clear FAC1 rounding byte
  5660 FF:4668: 60           	RTS
  5661                        
  5662                        ; round and copy FAC1 to FAC2
  5663                        
  5664                        LAB_27AB
  5665 FF:4669: 20 78 46     	JSR	LAB_27BA		; round FAC1
  5666                        
  5667                        ; copy FAC1 to FAC2
  5668                        
  5669                        LAB_27AE
  5670 FF:466C: A2 05        	LDX	#$05			; 5 bytes to copy
  5671                        LAB_27B0
  5672 FF:466E: B5 AB        	LDA	<FAC1_e-1,X		; get byte from FAC1,X
  5673 FF:4670: 95 B2        	STA	<FAC1_o,X		; save byte at FAC2,X
  5674 FF:4672: CA           	DEX				; decrement count
  5675 FF:4673: D0 F9        	BNE	LAB_27B0		; loop if not all done
  5676                        
  5677 FF:4675: 86 B9        	STX	<FAC1_r		; clear FAC1 rounding byte
  5678                        LAB_27B9
  5679 FF:4677: 60           	RTS
  5680                        
  5681                        ; round FAC1
  5682                        
  5683                        LAB_27BA
  Sun Nov 21 2021 15:13                                                                                                Page 199


  5684 FF:4678: A5 AC        	LDA	<FAC1_e		; get FAC1 exponent
  5685 FF:467A: F0 FB        	BEQ	LAB_27B9		; exit if zero
  5686                        
  5687 FF:467C: 06 B9        	ASL	<FAC1_r		; shift FAC1 rounding byte
  5688 FF:467E: 90 F7        	BCC	LAB_27B9		; exit if no overflow
  5689                        
  5690                        ; round FAC1 (no check)
  5691                        
  5692                        LAB_27C2
  5693 FF:4680: 20 67 43     	JSR	LAB_2559		; increment FAC1 mantissa
  5694 FF:4683: D0 F2        	BNE	LAB_27B9		; branch if no overflow
  5695                        
  5696 FF:4685: 4C 38 43     	JMP	LAB_252A		; normalise FAC1 for C=1 and return
  5697                        
  5698                        ; get FAC1 sign
  5699                        ; return A=FF,C=1/-ve A=01,C=0/+ve
  5700                        
  5701                        LAB_27CA
  5702 FF:4688: A5 AC        	LDA	<FAC1_e		; get FAC1 exponent
  5703 FF:468A: F0 09        	BEQ	LAB_27D7		; exit if zero (already correct SGN(0)=0)
  5704                        
  5705                        ; return A=FF,C=1/-ve A=01,C=0/+ve
  5706                        ; no = 0 check
  5707                        
  5708                        LAB_27CE
  5709 FF:468C: A5 B0        	LDA	<FAC1_s		; else get FAC1 sign (b7)
  5710                        
  5711                        ; return A=FF,C=1/-ve A=01,C=0/+ve
  5712                        ; no = 0 check, sign in A
  5713                        
  5714                        LAB_27D0
  5715 FF:468E: 2A           	ROL	A			; move sign bit to carry
  5716 FF:468F: A9 FF        	LDA	#$FF			; set byte for -ve result
  5717 FF:4691: B0 02        	BCS	LAB_27D7		; return if sign was set (-ve)
  5718                        
  5719 FF:4693: A9 01        	LDA	#$01			; else set byte for +ve result
  5720                        LAB_27D7
  5721 FF:4695: 60           	RTS
  5722                        
  5723                        ; perform SGN()
  5724                        
  5725                        LAB_SGN
  5726 FF:4696: 20 88 46     	JSR	LAB_27CA		; get FAC1 sign
  5727                        					; return A=$FF/-ve A=$01/+ve
  5728                        ; save A as integer byte
  5729                        
  5730                        LAB_27DB
  5731 FF:4699: 85 AD        	STA	<FAC1_1		; save FAC1 mantissa1
  5732 FF:469B: A9 00        	LDA	#$00			; clear A
  5733 FF:469D: 85 AE        	STA	<FAC1_2		; clear FAC1 mantissa2
  5734 FF:469F: A2 88        	LDX	#$88			; set exponent
  5735                        
  5736                        ; set exp=X, clearFAC1 mantissa3 and normalise
  5737                        
  5738                        LAB_27E3
  5739 FF:46A1: A5 AD        	LDA	<FAC1_1		; get FAC1 mantissa1
  5740 FF:46A3: 49 FF        	EOR	#$FF			; complement it
  Sun Nov 21 2021 15:13                                                                                                Page 200


  5741 FF:46A5: 2A           	ROL	A			; sign bit into carry
  5742                        
  5743                        ; set exp=X, clearFAC1 mantissa3 and normalise
  5744                        
  5745                        LAB_STFA
  5746 FF:46A6: A9 00        	LDA	#$00			; clear A
  5747 FF:46A8: 85 AF        	STA	<FAC1_3		; clear FAC1 mantissa3
  5748 FF:46AA: 86 AC        	STX	<FAC1_e		; set FAC1 exponent
  5749 FF:46AC: 85 B9        	STA	<FAC1_r		; clear FAC1 rounding byte
  5750 FF:46AE: 85 B0        	STA	<FAC1_s		; clear FAC1 sign (b7)
  5751 FF:46B0: 4C DE 42     	JMP	LAB_24D0		; do ABS and normalise FAC1
  5752                        
  5753                        ; perform ABS()
  5754                        
  5755                        LAB_ABS
  5756 FF:46B3: 46 B0        	LSR	<FAC1_s		; clear FAC1 sign (put zero in b7)
  5757 FF:46B5: 60           	RTS
  5758                        
  5759                        ; compare FAC1 with (AY)
  5760                        ; returns A=$00 if FAC1 = (AY)
  5761                        ; returns A=$01 if FAC1 > (AY)
  5762                        ; returns A=$FF if FAC1 < (AY)
  5763                        
  5764                        LAB_27F8
  5765 FF:46B6: 85 73        	STA	<ut2_pl		; save pointer low byte
  5766                        LAB_27FA
  5767 FF:46B8: 84 74        	STY	<ut2_ph		; save pointer high byte
  5768 FF:46BA: A0 00        	LDY	#$00			; clear index
  5769                        	LDAINDIRECTY ut2_pl		; get exponent
+ 5769 FF:46BC: 8B               PHB
+ 5769 FF:46BD: DA           	PHX
+ 5769 FF:46BE: A2 01            LDX #$01
+ 5769 FF:46C0: B5 73            LDA <ut2_pl,X
+ 5769 FF:46C2: C9 00            CMP #$00
+ 5769 FF:46C4: D0 04            BNE *+6
+ 5769 FF:46C6: A2 00        	LDX #00
+ 5769 FF:46C8: DA           	PHX
+ 5769 FF:46C9: AB           	PLB
+ 5769 FF:46CA: FA               PLX
+ 5769 FF:46CB: B1 73        	LDA	(<ut2_pl),Y		;
+ 5769 FF:46CD: 85 04            STA <TMPFLG
+ 5769 FF:46CF: AB               PLB
+ 5769 FF:46D0: A5 04            LDA <TMPFLG
  5770 FF:46D2: C8           	INY				; increment index
  5771 FF:46D3: AA           	TAX				; copy (AY) exponent to X
  5772 FF:46D4: F0 B2        	BEQ	LAB_27CA		; branch if (AY) exponent=0 and get FAC1 sign
  5773                        					; A=FF,C=1/-ve A=01,C=0/+ve
  5774                        
  5775                        	LDAINDIRECTY ut2_pl		; get (AY) mantissa1 (with sign)
+ 5775 FF:46D6: 8B               PHB
+ 5775 FF:46D7: DA           	PHX
+ 5775 FF:46D8: A2 01            LDX #$01
+ 5775 FF:46DA: B5 73            LDA <ut2_pl,X
+ 5775 FF:46DC: C9 00            CMP #$00
+ 5775 FF:46DE: D0 04            BNE *+6
+ 5775 FF:46E0: A2 00        	LDX #00
+ 5775 FF:46E2: DA           	PHX
  Sun Nov 21 2021 15:13                                                                                                Page 201


+ 5775 FF:46E3: AB           	PLB
+ 5775 FF:46E4: FA               PLX
+ 5775 FF:46E5: B1 73        	LDA	(<ut2_pl),Y		;
+ 5775 FF:46E7: 85 04            STA <TMPFLG
+ 5775 FF:46E9: AB               PLB
+ 5775 FF:46EA: A5 04            LDA <TMPFLG
  5776 FF:46EC: 45 B0        	EOR	<FAC1_s		; EOR FAC1 sign (b7)
  5777 FF:46EE: 30 9C        	BMI	LAB_27CE		; if signs <> do return A=FF,C=1/-ve
  5778                        					; A=01,C=0/+ve and return
  5779                        
  5780 FF:46F0: E4 AC        	CPX	<FAC1_e		; compare (AY) exponent with FAC1 exponent
  5781 FF:46F2: D0 56        	BNE	LAB_2828		; branch if different
  5782                        
  5783                        	LDAINDIRECTY ut2_pl		; get (AY) mantissa1 (with sign)
+ 5783 FF:46F4: 8B               PHB
+ 5783 FF:46F5: DA           	PHX
+ 5783 FF:46F6: A2 01            LDX #$01
+ 5783 FF:46F8: B5 73            LDA <ut2_pl,X
+ 5783 FF:46FA: C9 00            CMP #$00
+ 5783 FF:46FC: D0 04            BNE *+6
+ 5783 FF:46FE: A2 00        	LDX #00
+ 5783 FF:4700: DA           	PHX
+ 5783 FF:4701: AB           	PLB
+ 5783 FF:4702: FA               PLX
+ 5783 FF:4703: B1 73        	LDA	(<ut2_pl),Y		;
+ 5783 FF:4705: 85 04            STA <TMPFLG
+ 5783 FF:4707: AB               PLB
+ 5783 FF:4708: A5 04            LDA <TMPFLG
  5784 FF:470A: 09 80        	ORA	#$80			; normalise top bit
  5785 FF:470C: C5 AD        	CMP	<FAC1_1		; compare with FAC1 mantissa1
  5786 FF:470E: D0 3A        	BNE	LAB_2828		; branch if different
  5787                        
  5788 FF:4710: C8           	INY				; increment index
  5789                        	LDAINDIRECTY ut2_pl		; get mantissa2
+ 5789 FF:4711: 8B               PHB
+ 5789 FF:4712: DA           	PHX
+ 5789 FF:4713: A2 01            LDX #$01
+ 5789 FF:4715: B5 73            LDA <ut2_pl,X
+ 5789 FF:4717: C9 00            CMP #$00
+ 5789 FF:4719: D0 04            BNE *+6
+ 5789 FF:471B: A2 00        	LDX #00
+ 5789 FF:471D: DA           	PHX
+ 5789 FF:471E: AB           	PLB
+ 5789 FF:471F: FA               PLX
+ 5789 FF:4720: B1 73        	LDA	(<ut2_pl),Y		;
+ 5789 FF:4722: 85 04            STA <TMPFLG
+ 5789 FF:4724: AB               PLB
+ 5789 FF:4725: A5 04            LDA <TMPFLG
  5790 FF:4727: C5 AE        	CMP	<FAC1_2		; compare with FAC1 mantissa2
  5791 FF:4729: D0 1F        	BNE	LAB_2828		; branch if different
  5792                        
  5793 FF:472B: C8           	INY				; increment index
  5794 FF:472C: A9 7F        	LDA	#$7F			; set for 1/2 value rounding byte
  5795 FF:472E: C5 B9        	CMP	<FAC1_r		; compare with FAC1 rounding byte (set carry)
  5796                        	LDAINDIRECTY ut2_pl		; get mantissa3
+ 5796 FF:4730: 8B               PHB
+ 5796 FF:4731: DA           	PHX
  Sun Nov 21 2021 15:13                                                                                                Page 202


+ 5796 FF:4732: A2 01            LDX #$01
+ 5796 FF:4734: B5 73            LDA <ut2_pl,X
+ 5796 FF:4736: C9 00            CMP #$00
+ 5796 FF:4738: D0 04            BNE *+6
+ 5796 FF:473A: A2 00        	LDX #00
+ 5796 FF:473C: DA           	PHX
+ 5796 FF:473D: AB           	PLB
+ 5796 FF:473E: FA               PLX
+ 5796 FF:473F: B1 73        	LDA	(<ut2_pl),Y		;
+ 5796 FF:4741: 85 04            STA <TMPFLG
+ 5796 FF:4743: AB               PLB
+ 5796 FF:4744: A5 04            LDA <TMPFLG
  5797 FF:4746: E5 AF        	SBC	<FAC1_3		; subtract FAC1 mantissa3
  5798 FF:4748: F0 28        	BEQ	LAB_2850		; exit if mantissa3 equal
  5799                        
  5800                        ; gets here if number <> FAC1
  5801                        
  5802                        LAB_2828
  5803                        
  5804 FF:474A: A5 B0        	LDA	<FAC1_s		; get FAC1 sign (b7)
  5805 FF:474C: 90 02        	BCC	LAB_282E		; branch if FAC1 > (AY)
  5806                        
  5807 FF:474E: 49 FF        	EOR	#$FF			; else toggle FAC1 sign
  5808                        LAB_282E
  5809 FF:4750: 4C 8E 46     	JMP	LAB_27D0		; return A=FF,C=1/-ve A=01,C=0/+ve
  5810                        
  5811                        ; convert FAC1 floating-to-fixed
  5812                        
  5813                        LAB_2831
  5814 FF:4753: A5 AC        	LDA	<FAC1_e		; get FAC1 exponent
  5815 FF:4755: F0 4A        	BEQ	LAB_287F		; if zero go clear FAC1 and return
  5816                        
  5817 FF:4757: 38           	SEC				; set carry for subtract
  5818 FF:4758: E9 98        	SBC	#$98			; subtract maximum integer range exponent
  5819 FF:475A: 24 B0        	BIT	<FAC1_s		; test FAC1 sign (b7)
  5820 FF:475C: 10 09        	BPL	LAB_2845		; branch if FAC1 +ve
  5821                        
  5822                        					; FAC1 was -ve
  5823 FF:475E: AA           	TAX				; copy subtracted exponent
  5824 FF:475F: A9 FF        	LDA	#$FF			; overflow for -ve number
  5825 FF:4761: 85 B2        	STA	<FAC1_o		; set FAC1 overflow byte
  5826 FF:4763: 20 4B 43     	JSR	LAB_253D		; twos complement FAC1 mantissa
  5827 FF:4766: 8A           	TXA				; restore subtracted exponent
  5828                        LAB_2845
  5829 FF:4767: A2 AC        	LDX	#<FAC1_e		; set index to FAC1
  5830 FF:4769: C9 F9        	CMP	#$F9			; compare exponent result
  5831 FF:476B: 10 06        	BPL	LAB_2851		; if < 8 shifts shift FAC1 A times right and return
  5832                        
  5833 FF:476D: 20 89 43     	JSR	LAB_257B		; shift FAC1 A times right (> 8 shifts)
  5834 FF:4770: 84 B2        	STY	<FAC1_o		; clear FAC1 overflow byte
  5835                        LAB_2850
  5836 FF:4772: 60           	RTS
  5837                        
  5838                        ; shift FAC1 A times right
  5839                        
  5840                        LAB_2851
  5841 FF:4773: A8           	TAY				; copy shift count
  Sun Nov 21 2021 15:13                                                                                                Page 203


  5842 FF:4774: A5 B0        	LDA	<FAC1_s		; get FAC1 sign (b7)
  5843 FF:4776: 29 80        	AND	#$80			; mask sign bit only (x000 0000)
  5844 FF:4778: 46 AD        	LSR	<FAC1_1		; shift FAC1 mantissa1
  5845 FF:477A: 05 AD        	ORA	<FAC1_1		; OR sign in b7 FAC1 mantissa1
  5846 FF:477C: 85 AD        	STA	<FAC1_1		; save FAC1 mantissa1
  5847 FF:477E: 20 A0 43     	JSR	LAB_2592		; shift FAC1 Y times right
  5848 FF:4781: 84 B2        	STY	<FAC1_o		; clear FAC1 overflow byte
  5849 FF:4783: 60           	RTS
  5850                        
  5851                        ; perform INT()
  5852                        
  5853                        LAB_INT
  5854 FF:4784: A5 AC        	LDA	<FAC1_e		; get FAC1 exponent
  5855 FF:4786: C9 98        	CMP	#$98			; compare with max int
  5856 FF:4788: B0 1E        	BCS	LAB_2886		; exit if >= (already int, too big for fractional part!)
  5857                        
  5858 FF:478A: 20 53 47     	JSR	LAB_2831		; convert FAC1 floating-to-fixed
  5859 FF:478D: 84 B9        	STY	<FAC1_r		; save FAC1 rounding byte
  5860 FF:478F: A5 B0        	LDA	<FAC1_s		; get FAC1 sign (b7)
  5861 FF:4791: 84 B0        	STY	<FAC1_s		; save FAC1 sign (b7)
  5862 FF:4793: 49 80        	EOR	#$80			; toggle FAC1 sign
  5863 FF:4795: 2A           	ROL	A			; shift into carry
  5864 FF:4796: A9 98        	LDA	#$98			; set new exponent
  5865 FF:4798: 85 AC        	STA	<FAC1_e		; save FAC1 exponent
  5866 FF:479A: A5 AF        	LDA	<FAC1_3		; get FAC1 mantissa3
  5867 FF:479C: 85 5B        	STA	<Temp3			; save for EXP() function
  5868 FF:479E: 4C DE 42     	JMP	LAB_24D0		; do ABS and normalise FAC1
  5869                        
  5870                        ; clear FAC1 and return
  5871                        
  5872                        LAB_287F
  5873 FF:47A1: 85 AD        	STA	<FAC1_1		; clear FAC1 mantissa1
  5874 FF:47A3: 85 AE        	STA	<FAC1_2		; clear FAC1 mantissa2
  5875 FF:47A5: 85 AF        	STA	<FAC1_3		; clear FAC1 mantissa3
  5876 FF:47A7: A8           	TAY				; clear Y
  5877                        LAB_2886
  5878 FF:47A8: 60           	RTS
  5879                        
  5880                        ; get FAC1 from string
  5881                        ; this routine now handles hex and binary values from strings
  5882                        ; starting with "$" and "%" respectively
  5883                        
  5884                        LAB_2887
  5885 FF:47A9: A0 00        	LDY	#$00			; clear Y
  5886 FF:47AB: 84 5F        	STY	<Dtypef			; clear data type flag, $FF=string, $00=numeric
  5887 FF:47AD: A2 09        	LDX	#$09			; set index
  5888                        LAB_288B
  5889 FF:47AF: 94 A8        	STY <numexp,x 		; clear byte
  5890 FF:47B1: CA           	DEX					; decrement index
  5891 FF:47B2: 10 FB        	BPL	LAB_288B		; loop until <numexp to <negnum (and FAC1) = $00
  5892                        
  5893 FF:47B4: B0 03        	BCS	LAB_s28FE		; branch if 1st NOT character numeric
  5894 FF:47B6: 4C 3C 48     	JMP	LAB_28FE		; branch if 1st character numeric
  5895                        LAB_s28FE:
  5896                        
  5897                        ; get FAC1 from string .. first character wasn't numeric
  5898                        
  Sun Nov 21 2021 15:13                                                                                                Page 204


  5899 FF:47B9: C9 2D        	CMP	#'-'			; else compare with "-"
  5900 FF:47BB: D0 04        	BNE	LAB_289A		; branch if not "-"
  5901                        
  5902 FF:47BD: 86 B1        	STX	<negnum		; set flag for -ve number (X = $FF)
  5903 FF:47BF: F0 04        	BEQ	LAB_289C		; branch always (go scan and check for hex/bin)
  5904                        
  5905                        ; get FAC1 from string .. first character wasn't numeric or -
  5906                        
  5907                        LAB_289A
  5908 FF:47C1: C9 2B        	CMP	#'+'			; else compare with "+"
  5909 FF:47C3: D0 06        	BNE	LAB_289D		; branch if not "+" (go check for hex/bin)
  5910                        
  5911                        ; was "+" or "-" to start, so get next character
  5912                        
  5913                        LAB_289C
  5914 FF:47C5: 22 BC 00 00  	JSL	LAB_IGBY		; increment and scan memory
  5915 FF:47C9: 90 71        	BCC	LAB_28FE		; branch if numeric character
  5916                        
  5917                        ; code here for hex and binary numbers
  5918                        
  5919                        LAB_289D
  5920 FF:47CB: C9 24        	CMP	#'$'			; else compare with "$"
  5921 FF:47CD: D0 03        	BNE	LAB_NHEX		; branch if not "$"
  5922                        
  5923 FF:47CF: 4C FA 4C     	JMP	LAB_CHEX		; branch if "$"
  5924                        
  5925                        LAB_NHEX
  5926 FF:47D2: C9 25        	CMP	#'%'			; else compare with "%"
  5927 FF:47D4: D0 09        	BNE	LAB_28A3		; branch if not "%" (continue original code)
  5928                        
  5929 FF:47D6: 4C 29 4D     	JMP	LAB_CBIN		; branch if "%"
  5930                        
  5931                        LAB_289E
  5932 FF:47D9: 22 BC 00 00  	JSL	LAB_IGBY		; increment and scan memory (ignore + or get next number)
  5933                        LAB_28A1
  5934 FF:47DD: 90 5D        	BCC	LAB_28FE		; branch if numeric character
  5935                        
  5936                        ; get FAC1 from string .. character wasn't numeric, -, +, hex or binary
  5937                        
  5938                        LAB_28A3
  5939 FF:47DF: C9 2E        	CMP	#'.'			; else compare with "."
  5940 FF:47E1: F0 30        	BEQ	LAB_28D5		; branch if "."
  5941                        
  5942                        ; get FAC1 from string .. character wasn't numeric, -, + or .
  5943                        
  5944 FF:47E3: C9 45        	CMP	#'E'			; else compare with "E"
  5945 FF:47E5: D0 32        	BNE	LAB_28DB		; branch if not "E"
  5946                        
  5947                        					; was "E" so evaluate exponential part
  5948 FF:47E7: 22 BC 00 00  	JSL	LAB_IGBY		; increment and scan memory
  5949 FF:47EB: 90 18        	BCC	LAB_28C7		; branch if numeric character
  5950                        
  5951 FF:47ED: C9 CC        	CMP	#TK_MINUS		; else compare with token for -
  5952 FF:47EF: F0 0E        	BEQ	LAB_28C2		; branch if token for -
  5953                        
  5954 FF:47F1: C9 2D        	CMP	#'-'			; else compare with "-"
  5955 FF:47F3: F0 0A        	BEQ	LAB_28C2		; branch if "-"
  Sun Nov 21 2021 15:13                                                                                                Page 205


  5956                        
  5957 FF:47F5: C9 CB        	CMP	#TK_PLUS		; else compare with token for +
  5958 FF:47F7: F0 08        	BEQ	LAB_28C4		; branch if token for +
  5959                        
  5960 FF:47F9: C9 2B        	CMP	#'+'			; else compare with "+"
  5961 FF:47FB: F0 04        	BEQ	LAB_28C4		; branch if "+"
  5962                        
  5963 FF:47FD: D0 08        	BNE	LAB_28C9		; branch always
  5964                        
  5965                        LAB_28C2
  5966 FF:47FF: 66 AB        	ROR	<expneg		; set exponent -ve flag (C, which=1, into b7)
  5967                        LAB_28C4
  5968 FF:4801: 22 BC 00 00  	JSL	LAB_IGBY		; increment and scan memory
  5969                        LAB_28C7
  5970 FF:4805: 90 5B        	BCC	LAB_2925		; branch if numeric character
  5971                        
  5972                        LAB_28C9
  5973 FF:4807: 24 AB        	BIT	<expneg		; test exponent -ve flag
  5974 FF:4809: 10 0E        	BPL	LAB_28DB		; if +ve go evaluate exponent
  5975                        
  5976                        					; else do exponent = -exponent
  5977 FF:480B: A9 00        	LDA	#$00			; clear result
  5978 FF:480D: 38           	SEC				; set carry for subtract
  5979 FF:480E: E5 A9        	SBC	<expcnt		; subtract exponent byte
  5980 FF:4810: 4C 1B 48     	JMP	LAB_28DD		; go evaluate exponent
  5981                        
  5982                        LAB_28D5
  5983 FF:4813: 66 AA        	ROR	<numdpf		; set decimal point flag
  5984 FF:4815: 24 AA        	BIT	<numdpf		; test decimal point flag
  5985 FF:4817: 50 C0        	BVC	LAB_289E		; branch if only one decimal point so far
  5986                        
  5987                        					; evaluate exponent
  5988                        LAB_28DB
  5989 FF:4819: A5 A9        	LDA	<expcnt		; get exponent count byte
  5990                        LAB_28DD
  5991 FF:481B: 38           	SEC				; set carry for subtract
  5992 FF:481C: E5 A8        	SBC	<numexp		; subtract numerator exponent
  5993 FF:481E: 85 A9        	STA	<expcnt		; save exponent count byte
  5994 FF:4820: F0 12        	BEQ	LAB_28F6		; branch if no adjustment
  5995                        
  5996 FF:4822: 10 09        	BPL	LAB_28EF		; else if +ve go do FAC1*10^<expcnt
  5997                        
  5998                        					; else go do FAC1/10^(0-<expcnt)
  5999                        LAB_28E6
  6000 FF:4824: 20 EF 44     	JSR	LAB_26B9		; divide by 10
  6001 FF:4827: E6 A9        	INC	<expcnt		; increment exponent count byte
  6002 FF:4829: D0 F9        	BNE	LAB_28E6		; loop until all done
  6003                        
  6004 FF:482B: F0 07        	BEQ	LAB_28F6		; branch always
  6005                        
  6006                        LAB_28EF
  6007 FF:482D: 20 D6 44     	JSR	LAB_269E		; multiply by 10
  6008 FF:4830: C6 A9        	DEC	<expcnt		; decrement exponent count byte
  6009 FF:4832: D0 F9        	BNE	LAB_28EF		; loop until all done
  6010                        
  6011                        LAB_28F6
  6012 FF:4834: A5 B1        	LDA	<negnum		; get -ve flag
  Sun Nov 21 2021 15:13                                                                                                Page 206


  6013 FF:4836: 30 01        	BMI	LAB_28FB		; if -ve do - FAC1 and return
  6014                        
  6015 FF:4838: 60           	RTS
  6016                        
  6017                        ; do - FAC1 and return
  6018                        
  6019                        LAB_28FB
  6020 FF:4839: 4C 2C 4A     	JMP	LAB_GTHAN		; do - FAC1 and return
  6021                        
  6022                        ; do unsigned FAC1*10+number
  6023                        
  6024                        LAB_28FE
  6025 FF:483C: 48           	PHA				; save character
  6026 FF:483D: 24 AA        	BIT	<numdpf		; test decimal point flag
  6027 FF:483F: 10 02        	BPL	LAB_2905		; skip exponent increment if not set
  6028                        
  6029 FF:4841: E6 A8        	INC	<numexp		; else increment number exponent
  6030                        LAB_2905
  6031 FF:4843: 20 D6 44     	JSR	LAB_269E		; multiply FAC1 by 10
  6032 FF:4846: 68           	PLA				; restore character
  6033 FF:4847: 29 0F        	AND	#$0F			; convert to binary
  6034 FF:4849: 20 4F 48     	JSR	LAB_2912		; evaluate new ASCII digit
  6035 FF:484C: 4C D9 47     	JMP	LAB_289E		; go do next character
  6036                        
  6037                        ; evaluate new ASCII digit
  6038                        
  6039                        LAB_2912
  6040 FF:484F: 48           	PHA				; save digit
  6041 FF:4850: 20 69 46     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
  6042 FF:4853: 68           	PLA				; restore digit
  6043 FF:4854: 20 99 46     	JSR	LAB_27DB		; save A as integer byte
  6044 FF:4857: A5 B7        	LDA	<FAC2_s		; get FAC2 sign (b7)
  6045 FF:4859: 45 B0        	EOR	<FAC1_s		; toggle with FAC1 sign (b7)
  6046 FF:485B: 85 B8        	STA	<FAC_sc		; save sign compare (FAC1 EOR FAC2)
  6047 FF:485D: A6 AC        	LDX	<FAC1_e		; get FAC1 exponent
  6048 FF:485F: 4C 6A 42     	JMP	LAB_ADD		; add FAC2 to FAC1 and return
  6049                        
  6050                        ; evaluate next character of exponential part of number
  6051                        
  6052                        LAB_2925
  6053 FF:4862: A5 A9        	LDA	<expcnt		; get exponent count byte
  6054 FF:4864: C9 0A        	CMP	#$0A			; compare with 10 decimal
  6055 FF:4866: 90 09        	BCC	LAB_2934		; branch if less
  6056                        
  6057 FF:4868: A9 64        	LDA	#$64			; make all -ve exponents = -100 decimal (causes underflow)
  6058 FF:486A: 24 AB        	BIT	<expneg		; test exponent -ve flag
  6059 FF:486C: 30 25        	BMI	LAB_2942		; branch if -ve
  6060                        
  6061 FF:486E: 4C 72 43     	JMP	LAB_2564		; else do overflow error
  6062                        
  6063                        LAB_2934
  6064 FF:4871: 0A           	ASL	A			; * 2
  6065 FF:4872: 0A           	ASL	A			; * 4
  6066 FF:4873: 65 A9        	ADC	<expcnt		; * 5
  6067 FF:4875: 0A           	ASL	A			; * 10
  6068 FF:4876: A0 00        	LDY	#$00			; set index
  6069                        	ADCINDIRECTY	Bpntrl		; add character (will be $30 too much!)
  Sun Nov 21 2021 15:13                                                                                                Page 207


+ 6069 FF:4878: 8B               PHB
+ 6069 FF:4879: 48               PHA
+ 6069 FF:487A: DA               PHX
+ 6069 FF:487B: A2 01            LDX #$01
+ 6069 FF:487D: B5 C3            LDA <Bpntrl,X
+ 6069 FF:487F: C9 00            CMP #$00
+ 6069 FF:4881: D0 04            BNE *+6
+ 6069 FF:4883: A2 00        	LDX #00
+ 6069 FF:4885: DA           	PHX
+ 6069 FF:4886: AB           	PLB
+ 6069 FF:4887: FA               PLX
+ 6069 FF:4888: B1 C3            LDA	(<Bpntrl),Y		;
+ 6069 FF:488A: 85 04            STA <TMPFLG
+ 6069 FF:488C: 68               PLA
+ 6069 FF:488D: AB               PLB
+ 6069 FF:488E: 18               CLC
+ 6069 FF:488F: 65 04            ADC	<TMPFLG 		;
  6070 FF:4891: E9 2F        	SBC	#'0'-1		; convert character to binary
  6071                        LAB_2942
  6072 FF:4893: 85 A9        	STA	<expcnt		; save exponent count byte
  6073 FF:4895: 4C 01 48     	JMP	LAB_28C4		; go get next character
  6074                        
  6075                        ; print " in line [LINE #]"
  6076                        
  6077                        LAB_2953
  6078 FF:4898: A9 D1        	LDA	#<LAB_LMSG		; point to " in line " message low byte
  6079 FF:489A: A0 17        	LDY	#>LAB_LMSG		; point to " in line " message high byte
  6080 FF:489C: 20 85 31     	JSR	LAB_18C3		; print null terminated string from memory
  6081                        
  6082                        					; print Basic line #
  6083 FF:489F: A5 88        	LDA	<Clineh		; get current line high byte
  6084 FF:48A1: A6 87        	LDX	<Clinel		; get current line low byte
  6085                        
  6086                        ; print XA as unsigned integer
  6087                        
  6088                        LAB_295E
  6089 FF:48A3: 85 AD        	STA	<FAC1_1		; save low byte as FAC1 mantissa1
  6090 FF:48A5: 86 AE        	STX	<FAC1_2		; save high byte as FAC1 mantissa2
  6091 FF:48A7: A2 90        	LDX	#$90			; set exponent to 16d bits
  6092 FF:48A9: 38           	SEC				; set integer is +ve flag
  6093 FF:48AA: 20 A6 46     	JSR	LAB_STFA		; set exp=X, clearFAC1 mantissa3 and normalise
  6094 FF:48AD: A0 00        	LDY	#$00			; clear index
  6095 FF:48AF: 98           	TYA				; clear A
  6096 FF:48B0: 20 C5 48     	JSR	LAB_297B		; convert FAC1 to string, skip sign character save
  6097 FF:48B3: 4C 85 31     	JMP	LAB_18C3		; print null terminated string from memory and return
  6098                        
  6099                        ; convert FAC1 to ASCII string result in (AY)
  6100                        ; not any more, moved scratchpad to page 0
  6101                        
  6102                        LAB_296E
  6103 FF:48B6: A0 01        	LDY	#$01			; set index = 1
  6104 FF:48B8: A9 20        	LDA	#$20			; character = " " (assume +ve)
  6105 FF:48BA: 24 B0        	BIT	<FAC1_s		; test FAC1 sign (b7)
  6106 FF:48BC: 10 02        	BPL	LAB_2978		; branch if +ve
  6107                        
  6108 FF:48BE: A9 2D        	LDA	#$2D			; else character = "-"
  6109                        LAB_2978
  Sun Nov 21 2021 15:13                                                                                                Page 208


  6110 FF:48C0: DA           	phx
  6111 FF:48C1: BB           	tyx
  6112 FF:48C2: 95 EF        	STA	<Decss,X		; save leading character (" " or "-")
  6113 FF:48C4: FA           	plx
  6114                        LAB_297B
  6115 FF:48C5: 85 B0        	STA	<FAC1_s		; clear FAC1 sign (b7)
  6116 FF:48C7: 84 BA        	STY	<Sendl			; save index
  6117 FF:48C9: C8           	INY				; increment index
  6118 FF:48CA: A6 AC        	LDX	<FAC1_e		; get FAC1 exponent
  6119 FF:48CC: D0 05        	BNE	LAB_2989		; branch if FAC1<>0
  6120                        
  6121                        					; exponent was $00 so FAC1 is 0
  6122 FF:48CE: A9 30        	LDA	#'0'			; set character = "0"
  6123 FF:48D0: 4C E2 49     	JMP	LAB_2A89		; save last character, [EOT] and exit
  6124                        
  6125                        					; FAC1 is some non zero value
  6126                        LAB_2989
  6127 FF:48D3: A9 00        	LDA	#$00			; clear (number exponent count)
  6128 FF:48D5: E0 81        	CPX	#$81			; compare FAC1 exponent with $81 (>1.00000)
  6129                        
  6130 FF:48D7: B0 09        	BCS	LAB_299A		; branch if FAC1=>1
  6131                        
  6132                        					; FAC1<1
  6133 FF:48D9: A9 3B        	LDA	#<LAB_294F		; set pointer low byte to 1,000,000
  6134 FF:48DB: A0 18        	LDY	#>LAB_294F		; set pointer high byte to 1,000,000
  6135 FF:48DD: 20 E8 43     	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
  6136 FF:48E0: A9 FA        	LDA	#$FA			; set number exponent count (-6)
  6137                        LAB_299A
  6138 FF:48E2: 85 A8        	STA	<numexp		; save number exponent count
  6139                        LAB_299C
  6140 FF:48E4: A9 37        	LDA	#<LAB_294B		; set pointer low byte to 999999.4375 (max before sci note)
  6141 FF:48E6: A0 18        	LDY	#>LAB_294B		; set pointer high byte to 999999.4375
  6142 FF:48E8: 20 B6 46     	JSR	LAB_27F8		; compare FAC1 with (AY)
  6143 FF:48EB: F0 1E        	BEQ	LAB_29C3		; exit if FAC1 = (AY)
  6144 FF:48ED: 10 12        	BPL	LAB_29B9		; go do /10 if FAC1 > (AY)
  6145                        					; FAC1 < (AY)
  6146                        LAB_29A7
  6147 FF:48EF: A9 33        	LDA	#<LAB_2947		; set pointer low byte to 99999.9375
  6148 FF:48F1: A0 18        	LDY	#>LAB_2947		; set pointer high byte to 99999.9375
  6149 FF:48F3: 20 B6 46     	JSR	LAB_27F8		; compare FAC1 with (AY)
  6150 FF:48F6: F0 02        	BEQ	LAB_29B2		; branch if FAC1 = (AY) (allow decimal places)
  6151 FF:48F8: 10 0E        	BPL	LAB_29C0		; branch if FAC1 > (AY) (no decimal places)
  6152                        					; FAC1 <= (AY)
  6153                        LAB_29B2
  6154 FF:48FA: 20 D6 44     	JSR	LAB_269E		; multiply by 10
  6155 FF:48FD: C6 A8        	DEC	<numexp		; decrement number exponent count
  6156 FF:48FF: D0 EE        	BNE	LAB_29A7		; go test again (branch always)
  6157                        
  6158                        LAB_29B9
  6159 FF:4901: 20 EF 44     	JSR	LAB_26B9		; divide by 10
  6160 FF:4904: E6 A8        	INC	<numexp		; increment number exponent count
  6161 FF:4906: D0 DC        	BNE	LAB_299C		; go test again (branch always)
  6162                        
  6163                        ; now we have just the digits to do
  6164                        
  6165                        LAB_29C0
  6166 FF:4908: 20 63 42     	JSR	LAB_244E		; add 0.5 to FAC1 (round FAC1)
  Sun Nov 21 2021 15:13                                                                                                Page 209


  6167                        LAB_29C3
  6168 FF:490B: 20 53 47     	JSR	LAB_2831		; convert FAC1 floating-to-fixed
  6169 FF:490E: A2 01        	LDX	#$01			; set default digits before dp = 1
  6170 FF:4910: A5 A8        	LDA	<numexp		; get number exponent count
  6171 FF:4912: 18           	CLC				; clear carry for add
  6172 FF:4913: 69 07        	ADC	#$07			; up to 6 digits before point
  6173 FF:4915: 30 09        	BMI	LAB_29D8		; if -ve then 1 digit before dp
  6174                        
  6175 FF:4917: C9 08        	CMP	#$08			; A>=8 if n>=1E6
  6176 FF:4919: B0 06        	BCS	LAB_29D9		; branch if >= $08
  6177                        
  6178                        					; carry is clear
  6179 FF:491B: 69 FF        	ADC	#$FF			; take 1 from digit count
  6180 FF:491D: AA           	TAX				; copy to A
  6181 FF:491E: A9 02        	LDA	#$02			;.set exponent adjust
  6182                        LAB_29D8
  6183 FF:4920: 38           	SEC				; set carry for subtract
  6184                        LAB_29D9
  6185 FF:4921: E9 02        	SBC	#$02			; -2
  6186 FF:4923: 85 A9        	STA	<expcnt		;.save exponent adjust
  6187 FF:4925: 86 A8        	STX	<numexp		; save digits before dp count
  6188 FF:4927: 8A           	TXA				; copy to A
  6189 FF:4928: F0 02        	BEQ	LAB_29E4		; branch if no digits before dp
  6190                        
  6191 FF:492A: 10 17        	BPL	LAB_29F7		; branch if digits before dp
  6192                        
  6193                        LAB_29E4
  6194 FF:492C: A4 BA        	LDY	<Sendl			; get output string index
  6195 FF:492E: A9 2E        	LDA	#$2E			; character "."
  6196 FF:4930: C8           	INY				; increment index
  6197 FF:4931: DA           	phx
  6198 FF:4932: BB           	tyx
  6199 FF:4933: 95 EF        	STA	<Decss,X		; save to output string
  6200 FF:4935: FA           	plx
  6201 FF:4936: 8A           	TXA				;.
  6202 FF:4937: F0 08        	BEQ	LAB_29F5		;.
  6203                        
  6204 FF:4939: A9 30        	LDA	#'0'			; character "0"
  6205 FF:493B: C8           	INY				; increment index
  6206 FF:493C: DA           	phx
  6207 FF:493D: BB           	tyx
  6208 FF:493E: 95 EF        	STA	<Decss,X		; save to output string
  6209 FF:4940: FA           	plx
  6210                        LAB_29F5
  6211 FF:4941: 84 BA        	STY	<Sendl			; save output string index
  6212                        LAB_29F7
  6213 FF:4943: A0 00        	LDY	#$00			; clear index (point to 100,000)
  6214 FF:4945: A2 80        	LDX	#$80			;
  6215                        LAB_29FB
  6216 FF:4947: A5 AF        	LDA	<FAC1_3		; get FAC1 mantissa3
  6217 FF:4949: 18           	CLC				; clear carry for add
  6218 FF:494A: 79 B1 18     	ADC	LAB_2A9C,Y		; add -ve LSB
  6219 FF:494D: 85 AF        	STA	<FAC1_3		; save FAC1 mantissa3
  6220 FF:494F: A5 AE        	LDA	<FAC1_2		; get FAC1 mantissa2
  6221 FF:4951: 79 B0 18     	ADC	LAB_2A9B,Y		; add -ve NMSB
  6222 FF:4954: 85 AE        	STA	<FAC1_2		; save FAC1 mantissa2
  6223 FF:4956: A5 AD        	LDA	<FAC1_1		; get FAC1 mantissa1
  Sun Nov 21 2021 15:13                                                                                                Page 210


  6224 FF:4958: 79 AF 18     	ADC	LAB_2A9A,Y		; add -ve MSB
  6225 FF:495B: 85 AD        	STA	<FAC1_1		; save FAC1 mantissa1
  6226 FF:495D: E8           	INX				;
  6227 FF:495E: B0 04        	BCS	LAB_2A18		;
  6228                        
  6229 FF:4960: 10 E5        	BPL	LAB_29FB		; not -ve so try again
  6230                        
  6231 FF:4962: 30 02        	BMI	LAB_2A1A		;
  6232                        
  6233                        LAB_2A18
  6234 FF:4964: 30 E1        	BMI	LAB_29FB		;
  6235                        
  6236                        LAB_2A1A
  6237 FF:4966: 8A           	TXA				;
  6238 FF:4967: 90 04        	BCC	LAB_2A21		;
  6239                        
  6240 FF:4969: 49 FF        	EOR	#$FF			;
  6241 FF:496B: 69 0A        	ADC	#$0A			;
  6242                        LAB_2A21
  6243 FF:496D: 69 2F        	ADC	#'0'-1		; add "0"-1 to result
  6244 FF:496F: C8           	INY				; increment index ..
  6245 FF:4970: C8           	INY				; .. to next less ..
  6246 FF:4971: C8           	INY				; .. power of ten
  6247 FF:4972: 84 95        	STY	<Cvaral		; save as current var address low byte
  6248 FF:4974: A4 BA        	LDY	<Sendl			; get output string index
  6249 FF:4976: C8           	INY				; increment output string index
  6250 FF:4977: AA           	TAX				; copy character to X
  6251 FF:4978: 29 7F        	AND	#$7F			; mask out top bit
  6252 FF:497A: DA           	phx
  6253 FF:497B: BB           	tyx
  6254 FF:497C: 95 EF        	STA	<Decss,X		; save to output string
  6255 FF:497E: FA           	plx
  6256 FF:497F: C6 A8        	DEC	<numexp		; decrement # of characters before the dp
  6257 FF:4981: D0 08        	BNE	LAB_2A3B		; branch if still characters to do
  6258                        
  6259                        					; else output the point
  6260 FF:4983: A9 2E        	LDA	#$2E			; character "."
  6261 FF:4985: C8           	INY				; increment output string index
  6262 FF:4986: DA           	phx
  6263 FF:4987: BB           	tyx
  6264 FF:4988: 95 EF        	STA	<Decss,X		; save to output string
  6265 FF:498A: FA           	plx
  6266                        LAB_2A3B
  6267 FF:498B: 84 BA        	STY	<Sendl			; save output string index
  6268 FF:498D: A4 95        	LDY	<Cvaral		; get current var address low byte
  6269 FF:498F: 8A           	TXA				; get character back
  6270 FF:4990: 49 FF        	EOR	#$FF			;
  6271 FF:4992: 29 80        	AND	#$80			;
  6272 FF:4994: AA           	TAX				;
  6273 FF:4995: C0 12        	CPY	#$12			; compare index with max
  6274 FF:4997: D0 AE        	BNE	LAB_29FB		; loop if not max
  6275                        
  6276                        					; now remove trailing zeroes
  6277 FF:4999: A4 BA        	LDY	<Sendl			; get output string index
  6278                        LAB_2A4B
  6279 FF:499B: DA           	phx
  6280 FF:499C: BB           	tyx
  Sun Nov 21 2021 15:13                                                                                                Page 211


  6281 FF:499D: B5 EF        	LDA	<Decss,X		; get character from output string
  6282 FF:499F: FA           	plx
  6283 FF:49A0: 88           	DEY				; decrement output string index
  6284 FF:49A1: C9 30        	CMP	#'0'			; compare with "0"
  6285 FF:49A3: F0 F6        	BEQ	LAB_2A4B		; loop until non "0" character found
  6286                        
  6287 FF:49A5: C9 2E        	CMP	#'.'			; compare with "."
  6288 FF:49A7: F0 01        	BEQ	LAB_2A58		; branch if was dp
  6289                        
  6290                        					; restore last character
  6291 FF:49A9: C8           	INY				; increment output string index
  6292                        LAB_2A58
  6293 FF:49AA: A9 2B        	LDA	#$2B			; character "+"
  6294 FF:49AC: A6 A9        	LDX	<expcnt		; get exponent count
  6295 FF:49AE: F0 37        	BEQ	LAB_2A8C		; if zero go set null terminator and exit
  6296                        
  6297                        					; exponent isn't zero so write exponent
  6298 FF:49B0: 10 08        	BPL	LAB_2A68		; branch if exponent count +ve
  6299                        
  6300 FF:49B2: A9 00        	LDA	#$00			; clear A
  6301 FF:49B4: 38           	SEC				; set carry for subtract
  6302 FF:49B5: E5 A9        	SBC	<expcnt		; subtract exponent count adjust (convert -ve to +ve)
  6303 FF:49B7: AA           	TAX				; copy exponent count to X
  6304 FF:49B8: A9 2D        	LDA	#'-'			; character "-"
  6305                        LAB_2A68
  6306 FF:49BA: DA           	phx
  6307 FF:49BB: BB           	tyx
  6308 FF:49BC: 95 F1        	STA	<Decss+2,X		; save to output string
  6309 FF:49BE: A9 45        	LDA	#$45			; character "E"
  6310 FF:49C0: 95 F0        	STA	<Decss+1,X		; save exponent sign to output string
  6311 FF:49C2: FA           	plx
  6312 FF:49C3: 8A           	TXA				; get exponent count back
  6313 FF:49C4: A2 2F        	LDX	#'0'-1		; one less than "0" character
  6314 FF:49C6: 38           	SEC				; set carry for subtract
  6315                        LAB_2A74
  6316 FF:49C7: E8           	INX				; increment 10's character
  6317 FF:49C8: E9 0A        	SBC	#$0A			;.subtract 10 from exponent count
  6318 FF:49CA: B0 FB        	BCS	LAB_2A74		; loop while still >= 0
  6319                        
  6320 FF:49CC: 69 3A        	ADC	#':'			; add character ":" ($30+$0A, result is 10 less that value)
  6321 FF:49CE: DA           	phx
  6322 FF:49CF: BB           	tyx
  6323 FF:49D0: 95 F3        	STA	<Decss+4,X		; save to output string
  6324 FF:49D2: FA           	plx
  6325 FF:49D3: 8A           	TXA				; copy 10's character
  6326 FF:49D4: DA           	phx
  6327 FF:49D5: BB           	tyx
  6328 FF:49D6: 95 F2        	STA	<Decss+3,X		; save to output string
  6329 FF:49D8: FA           	plx
  6330 FF:49D9: A9 00        	LDA	#$00			; set null terminator
  6331 FF:49DB: DA           	phx
  6332 FF:49DC: BB           	tyx
  6333 FF:49DD: 95 F4        	STA	<Decss+5,X		; save to output string
  6334 FF:49DF: FA           	plx
  6335 FF:49E0: F0 0C        	BEQ	LAB_2A91		; go set string pointer (AY) and exit (branch always)
  6336                        
  6337                        					; save last character, [EOT] and exit
  Sun Nov 21 2021 15:13                                                                                                Page 212


  6338                        LAB_2A89
  6339 FF:49E2: DA           	phx
  6340 FF:49E3: BB           	tyx
  6341 FF:49E4: 95 EF        	STA	<Decss,X		; save last character to output string
  6342 FF:49E6: FA           	plx
  6343                        					; set null terminator and exit
  6344                        LAB_2A8C
  6345 FF:49E7: A9 00        	LDA	#$00			; set null terminator
  6346 FF:49E9: DA           	phx
  6347 FF:49EA: BB           	tyx
  6348 FF:49EB: 95 F0        	STA	<Decss+1,X		; save after last character
  6349 FF:49ED: FA           	plx
  6350                        					; set string pointer (AY) and exit
  6351                        LAB_2A91
  6352 FF:49EE: A9 F0        	LDA	#<Decssp1		; set result string low pointer
  6353 FF:49F0: A0 00        	LDY	#>Decssp1		; set result string high pointer
  6354 FF:49F2: 60           	RTS
  6355                        
  6356                        ; perform power function
  6357                        
  6358                        LAB_POWER
  6359 FF:49F3: F0 42        	BEQ	LAB_EXP		; go do  EXP()
  6360                        
  6361 FF:49F5: A5 B3        	LDA	<FAC2_e		; get FAC2 exponent
  6362 FF:49F7: D0 03        	BNE	LAB_2ABF		; branch if FAC2<>0
  6363                        
  6364 FF:49F9: 4C 01 43     	JMP	LAB_24F3		; clear FAC1 exponent and sign and return
  6365                        
  6366                        LAB_2ABF
  6367 FF:49FC: A2 9C        	LDX	#<func_l		; set destination pointer low byte
  6368 FF:49FE: A0 00        	LDY	#>func_l		; set destination pointer high byte
  6369 FF:4A00: 20 F6 45     	JSR	LAB_2778		; pack FAC1 into (XY)
  6370 FF:4A03: A5 B7        	LDA	<FAC2_s		; get FAC2 sign (b7)
  6371 FF:4A05: 10 0F        	BPL	LAB_2AD9		; branch if FAC2>0
  6372                        
  6373                        					; else FAC2 is -ve and can only be raised to an
  6374                        					; integer power which gives an x +j0 result
  6375 FF:4A07: 20 84 47     	JSR	LAB_INT		; perform INT
  6376 FF:4A0A: A9 9C        	LDA	#<func_l		; set source pointer low byte
  6377 FF:4A0C: A0 00        	LDY	#>func_l		; set source pointer high byte
  6378 FF:4A0E: 20 B6 46     	JSR	LAB_27F8		; compare FAC1 with (AY)
  6379 FF:4A11: D0 03        	BNE	LAB_2AD9		; branch if FAC1 <> (AY) to allow Function Call error
  6380                        					; this will leave FAC1 -ve and cause a Function Call
  6381                        					; error when LOG() is called
  6382                        
  6383 FF:4A13: 98           	TYA				; clear sign b7
  6384 FF:4A14: A4 5B        	LDY	<Temp3			; save mantissa 3 from INT() function as sign in Y
  6385                        					; for possible later negation, b0
  6386                        LAB_2AD9
  6387 FF:4A16: 20 6E 42     	JSR	LAB_279D		; save FAC1 sign and copy ABS(FAC2) to FAC1
  6388 FF:4A19: 98           	TYA				; copy sign back ..
  6389 FF:4A1A: 48           	PHA				; .. and save it
  6390 FF:4A1B: 20 AA 43     	JSR	LAB_LOG		; do LOG(n)
  6391 FF:4A1E: A9 9C        	LDA	#<garb_l		; set pointer low byte
  6392 FF:4A20: A0 00        	LDY	#>garb_l		; set pointer high byte
  6393 FF:4A22: 20 E8 43     	JSR	LAB_25FB		; do convert AY, FCA1*(AY) (square the value)
  6394 FF:4A25: 20 37 4A     	JSR	LAB_EXP		; go do EXP(n)
  Sun Nov 21 2021 15:13                                                                                                Page 213


  6395 FF:4A28: 68           	PLA				; pull sign from stack
  6396 FF:4A29: 4A           	LSR	A			; b0 is to be tested, shift to Cb
  6397 FF:4A2A: 90 0A        	BCC	LAB_2AF9		; if no bit then exit
  6398                        
  6399                        					; Perform negation
  6400                        ; do - FAC1
  6401                        
  6402                        LAB_GTHAN
  6403 FF:4A2C: A5 AC        	LDA	<FAC1_e		; get FAC1 exponent
  6404 FF:4A2E: F0 06        	BEQ	LAB_2AF9		; exit if <FAC1_e = $00
  6405                        
  6406 FF:4A30: A5 B0        	LDA	<FAC1_s		; get FAC1 sign (b7)
  6407 FF:4A32: 49 FF        	EOR	#$FF			; complement it
  6408 FF:4A34: 85 B0        	STA	<FAC1_s		; save FAC1 sign (b7)
  6409                        LAB_2AF9
  6410 FF:4A36: 60           	RTS
  6411                        
  6412                        ; perform EXP()	(x^e)
  6413                        
  6414                        LAB_EXP
  6415 FF:4A37: A9 3F        	LDA	#<LAB_2AFA		; set 1.443 pointer low byte
  6416 FF:4A39: A0 18        	LDY	#>LAB_2AFA		; set 1.443 pointer high byte
  6417 FF:4A3B: 20 E8 43     	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
  6418 FF:4A3E: A5 B9        	LDA	<FAC1_r		; get FAC1 rounding byte
  6419 FF:4A40: 69 50        	ADC	#$50			; +$50/$100
  6420 FF:4A42: 90 03        	BCC	LAB_2B2B		; skip rounding if no carry
  6421                        
  6422 FF:4A44: 20 80 46     	JSR	LAB_27C2		; round FAC1 (no check)
  6423                        LAB_2B2B
  6424 FF:4A47: 85 A3        	STA	<FAC2_r		; save FAC2 rounding byte
  6425 FF:4A49: 20 6C 46     	JSR	LAB_27AE		; copy FAC1 to FAC2
  6426 FF:4A4C: A5 AC        	LDA	<FAC1_e		; get FAC1 exponent
  6427 FF:4A4E: C9 88        	CMP	#$88			; compare with EXP limit (256d)
  6428 FF:4A50: 90 03        	BCC	LAB_2B39		; branch if less
  6429                        
  6430                        LAB_2B36
  6431 FF:4A52: 20 CD 44     	JSR	LAB_2690		; handle overflow and underflow
  6432                        LAB_2B39
  6433 FF:4A55: 20 84 47     	JSR	LAB_INT		; perform INT
  6434 FF:4A58: A5 5B        	LDA	<Temp3			; get mantissa 3 from INT() function
  6435 FF:4A5A: 18           	CLC				; clear carry for add
  6436 FF:4A5B: 69 81        	ADC	#$81			; normalise +1
  6437 FF:4A5D: F0 F3        	BEQ	LAB_2B36		; if $00 go handle overflow
  6438                        
  6439 FF:4A5F: 38           	SEC				; set carry for subtract
  6440 FF:4A60: E9 01        	SBC	#$01			; now correct for exponent
  6441 FF:4A62: 48           	PHA				; save FAC2 exponent
  6442                        
  6443                        					; swap FAC1 and FAC2
  6444 FF:4A63: A2 04        	LDX	#$04			; 4 bytes to do
  6445                        LAB_2B49
  6446 FF:4A65: B5 B3        	LDA	<FAC2_e,X		; get FAC2,X
  6447 FF:4A67: B4 AC        	LDY	<FAC1_e,X		; get FAC1,X
  6448 FF:4A69: 95 AC        	STA	<FAC1_e,X		; save FAC1,X
  6449 FF:4A6B: 94 B3        	STY <FAC2_e,X  ; save FAC2,X
  6450 FF:4A6D: CA           	DEX				; decrement count/index
  6451 FF:4A6E: 10 F5        	BPL	LAB_2B49		; loop if not all done
  Sun Nov 21 2021 15:13                                                                                                Page 214


  6452                        
  6453 FF:4A70: A5 A3        	LDA	<FAC2_r		; get FAC2 rounding byte
  6454 FF:4A72: 85 B9        	STA	<FAC1_r		; save as FAC1 rounding byte
  6455 FF:4A74: 20 4F 42     	JSR	LAB_SUBTRACT	; perform subtraction, FAC2 from FAC1
  6456 FF:4A77: 20 2C 4A     	JSR	LAB_GTHAN		; do - FAC1
  6457 FF:4A7A: A9 43        	LDA	#<LAB_2AFE		; set counter pointer low byte
  6458 FF:4A7C: A0 18        	LDY	#>LAB_2AFE		; set counter pointer high byte
  6459 FF:4A7E: 20 9F 4A     	JSR	LAB_2B84		; go do series evaluation
  6460 FF:4A81: A9 00        	LDA	#$00			; clear A
  6461 FF:4A83: 85 B8        	STA	<FAC_sc		; clear sign compare (FAC1 EOR FAC2)
  6462 FF:4A85: 68           	PLA				;.get saved FAC2 exponent
  6463 FF:4A86: 4C B2 44     	JMP	LAB_2675		; test and adjust accumulators and return
  6464                        
  6465                        ; ^2 then series evaluation
  6466                        
  6467                        LAB_2B6E
  6468 FF:4A89: 85 BA        	STA	<Cptrl			; save count pointer low byte
  6469 FF:4A8B: 84 BB        	STY	<Cptrh			; save count pointer high byte
  6470 FF:4A8D: 20 EC 45     	JSR	LAB_276E		; pack FAC1 into <Adatal
  6471 FF:4A90: A9 A4        	LDA	#<Adatal		; set pointer low byte (Y already $00)
  6472 FF:4A92: 20 E8 43     	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
  6473 FF:4A95: 20 A3 4A     	JSR	LAB_2B88		; go do series evaluation
  6474 FF:4A98: A9 A4        	LDA	#<Adatal		; pointer to original # low byte
  6475 FF:4A9A: A0 00        	LDY	#>Adatal		; pointer to original # high byte
  6476 FF:4A9C: 4C E8 43     	JMP	LAB_25FB		; do convert AY, FCA1*(AY) and return
  6477                        
  6478                        ; series evaluation
  6479                        
  6480                        LAB_2B84
  6481 FF:4A9F: 85 BA        	STA	<Cptrl			; save count pointer low byte
  6482 FF:4AA1: 84 BB        	STY	<Cptrh			; save count pointer high byte
  6483                        LAB_2B88
  6484 FF:4AA3: A2 A8        	LDX	#<numexp		; set pointer low byte
  6485 FF:4AA5: 20 EE 45     	JSR	LAB_2770		; set pointer high byte and pack FAC1 into <numexp
  6486                        	LDAINDIRECTY Cptrl		; get constants count
+ 6486 FF:4AA8: 8B               PHB
+ 6486 FF:4AA9: DA           	PHX
+ 6486 FF:4AAA: A2 01            LDX #$01
+ 6486 FF:4AAC: B5 BA            LDA <Cptrl,X
+ 6486 FF:4AAE: C9 00            CMP #$00
+ 6486 FF:4AB0: D0 04            BNE *+6
+ 6486 FF:4AB2: A2 00        	LDX #00
+ 6486 FF:4AB4: DA           	PHX
+ 6486 FF:4AB5: AB           	PLB
+ 6486 FF:4AB6: FA               PLX
+ 6486 FF:4AB7: B1 BA        	LDA	(<Cptrl),Y		;
+ 6486 FF:4AB9: 85 04            STA <TMPFLG
+ 6486 FF:4ABB: AB               PLB
+ 6486 FF:4ABC: A5 04            LDA <TMPFLG
  6487 FF:4ABE: 85 B1        	STA	<numcon		; save constants count
  6488 FF:4AC0: A4 BA        	LDY	<Cptrl			; get count pointer low byte
  6489 FF:4AC2: C8           	INY				; increment it (now constants pointer)
  6490 FF:4AC3: 98           	TYA				; copy it
  6491 FF:4AC4: D0 02        	BNE	LAB_2B97		; skip next if no overflow
  6492                        
  6493 FF:4AC6: E6 BB        	INC	<Cptrh			; else increment high byte
  6494                        LAB_2B97
  Sun Nov 21 2021 15:13                                                                                                Page 215


  6495 FF:4AC8: 85 BA        	STA	<Cptrl			; save low byte
  6496 FF:4ACA: A4 BB        	LDY	<Cptrh			; get high byte
  6497                        LAB_2B9B
  6498 FF:4ACC: 20 E8 43     	JSR	LAB_25FB		; do convert AY, FCA1*(AY)
  6499 FF:4ACF: A5 BA        	LDA	<Cptrl			; get constants pointer low byte
  6500 FF:4AD1: A4 BB        	LDY	<Cptrh			; get constants pointer high byte
  6501 FF:4AD3: 18           	CLC				; clear carry for add
  6502 FF:4AD4: 69 04        	ADC	#$04			; +4 to  low pointer (4 bytes per constant)
  6503 FF:4AD6: 90 01        	BCC	LAB_2BA8		; skip next if no overflow
  6504                        
  6505 FF:4AD8: C8           	INY				; increment high byte
  6506                        LAB_2BA8
  6507 FF:4AD9: 85 BA        	STA	<Cptrl			; save pointer low byte
  6508 FF:4ADB: 84 BB        	STY	<Cptrh			; save pointer high byte
  6509 FF:4ADD: 20 67 42     	JSR	LAB_246C		; add (AY) to FAC1
  6510 FF:4AE0: A9 A8        	LDA	#<numexp		; set pointer low byte to partial @ <numexp
  6511 FF:4AE2: A0 00        	LDY	#>numexp		; set pointer high byte to partial @ <numexp
  6512 FF:4AE4: C6 B1        	DEC	<numcon		; decrement constants count
  6513 FF:4AE6: D0 E4        	BNE	LAB_2B9B		; loop until all done
  6514                        
  6515 FF:4AE8: 60           	RTS
  6516                        
  6517                        ; RND(n), 32 bit Galoise version. make n=0 for 19th next number in sequence or n<>0
  6518                        ; to get 19th next number in sequence after seed n. This version of the PRNG uses
  6519                        ; the Galois method and a sample of 65536 bytes produced gives the following values.
  6520                        
  6521                        ; Entropy = 7.997442 bits per byte
  6522                        ; Optimum compression would reduce these 65536 bytes by 0 percent
  6523                        
  6524                        ; Chi square distribution for 65536 samples is 232.01, and
  6525                        ; randomly would exceed this value 75.00 percent of the time
  6526                        
  6527                        ; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
  6528                        ; Monte Carlo value for Pi is 3.122871269, error 0.60 percent
  6529                        ; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
  6530                        
  6531                        LAB_RND
  6532 FF:4AE9: A5 AC        	LDA	<FAC1_e		; get FAC1 exponent
  6533 FF:4AEB: F0 07        	BEQ	NextPRN		; do next random # if zero
  6534                        
  6535                        					; else get seed into random number store
  6536 FF:4AED: A2 E1        	LDX	#<Rbyte4		; set PRNG pointer low byte
  6537 FF:4AEF: A0 00        	LDY	#$00			; set PRNG pointer high byte
  6538 FF:4AF1: 20 F6 45     	JSR	LAB_2778		; pack FAC1 into (XY)
  6539                        NextPRN
  6540 FF:4AF4: A2 AF        	LDX	#$AF			; set EOR byte
  6541 FF:4AF6: A0 13        	LDY	#$13			; do this nineteen times
  6542                        LoopPRN
  6543 FF:4AF8: 06 E2        	ASL	<Rbyte1		; shift PRNG most significant byte
  6544 FF:4AFA: 26 E3        	ROL	<Rbyte2		; shift PRNG middle byte
  6545 FF:4AFC: 26 E4        	ROL	<Rbyte3		; shift PRNG least significant byte
  6546 FF:4AFE: 26 E1        	ROL	<Rbyte4		; shift PRNG extra byte
  6547 FF:4B00: 90 05        	BCC	Ninc1			; branch if bit 32 clear
  6548                        
  6549 FF:4B02: 8A           	TXA				; set EOR byte
  6550 FF:4B03: 45 E2        	EOR	<Rbyte1		; EOR PRNG extra byte
  6551 FF:4B05: 85 E2        	STA	<Rbyte1		; save new PRNG extra byte
  Sun Nov 21 2021 15:13                                                                                                Page 216


  6552                        Ninc1
  6553 FF:4B07: 88           	DEY				; decrement loop count
  6554 FF:4B08: D0 EE        	BNE	LoopPRN		; loop if not all done
  6555                        
  6556 FF:4B0A: A2 02        	LDX	#$02			; three bytes to copy
  6557                        CopyPRNG
  6558 FF:4B0C: B5 E2        	LDA	<Rbyte1,X		; get PRNG byte
  6559 FF:4B0E: 95 AD        	STA	<FAC1_1,X		; save FAC1 byte
  6560 FF:4B10: CA           	DEX
  6561 FF:4B11: 10 F9        	BPL	CopyPRNG		; loop if not complete
  6562                        
  6563 FF:4B13: A9 80        	LDA	#$80			; set the exponent
  6564 FF:4B15: 85 AC        	STA	<FAC1_e		; save FAC1 exponent
  6565                        
  6566 FF:4B17: 0A           	ASL	A			; clear A
  6567 FF:4B18: 85 B0        	STA	<FAC1_s		; save FAC1 sign
  6568                        
  6569 FF:4B1A: 4C E3 42     	JMP	LAB_24D5		; normalise FAC1 and return
  6570                        
  6571                        ; perform COS()
  6572                        
  6573                        LAB_COS
  6574 FF:4B1D: A9 60        	LDA	#<LAB_2C78		; set (pi/2) pointer low byte
  6575 FF:4B1F: A0 18        	LDY	#>LAB_2C78		; set (pi/2) pointer high byte
  6576 FF:4B21: 20 67 42     	JSR	LAB_246C		; add (AY) to FAC1
  6577                        
  6578                        ; perform SIN()
  6579                        
  6580                        LAB_SIN
  6581 FF:4B24: 20 69 46     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
  6582 FF:4B27: A9 75        	LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
  6583 FF:4B29: A0 18        	LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
  6584 FF:4B2B: A6 B7        	LDX	<FAC2_s		; get FAC2 sign (b7)
  6585 FF:4B2D: 20 F8 44     	JSR	LAB_26C2		; divide by (AY) (X=sign)
  6586 FF:4B30: 20 69 46     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
  6587 FF:4B33: 20 84 47     	JSR	LAB_INT		; perform INT
  6588 FF:4B36: A9 00        	LDA	#$00			; clear byte
  6589 FF:4B38: 85 B8        	STA	<FAC_sc		; clear sign compare (FAC1 EOR FAC2)
  6590 FF:4B3A: 20 4F 42     	JSR	LAB_SUBTRACT	; perform subtraction, FAC2 from FAC1
  6591 FF:4B3D: A9 A7        	LDA	#<LAB_2C80		; set 0.25 pointer low byte
  6592 FF:4B3F: A0 18        	LDY	#>LAB_2C80		; set 0.25 pointer high byte
  6593 FF:4B41: 20 4C 42     	JSR	LAB_2455		; perform subtraction, (AY) from FAC1
  6594 FF:4B44: A5 B0        	LDA	<FAC1_s		; get FAC1 sign (b7)
  6595 FF:4B46: 48           	PHA				; save FAC1 sign
  6596 FF:4B47: 10 0D        	BPL	LAB_2C35		; branch if +ve
  6597                        
  6598                        					; FAC1 sign was -ve
  6599 FF:4B49: 20 63 42     	JSR	LAB_244E		; add 0.5 to FAC1
  6600 FF:4B4C: A5 B0        	LDA	<FAC1_s		; get FAC1 sign (b7)
  6601 FF:4B4E: 30 09        	BMI	LAB_2C38		; branch if -ve
  6602                        
  6603 FF:4B50: A5 63        	LDA	<Cflag			; get comparison evaluation flag
  6604 FF:4B52: 49 FF        	EOR	#$FF			; toggle flag
  6605 FF:4B54: 85 63        	STA	<Cflag			; save comparison evaluation flag
  6606                        LAB_2C35
  6607 FF:4B56: 20 2C 4A     	JSR	LAB_GTHAN		; do - FAC1
  6608                        LAB_2C38
  Sun Nov 21 2021 15:13                                                                                                Page 217


  6609 FF:4B59: A9 A7        	LDA	#<LAB_2C80		; set 0.25 pointer low byte
  6610 FF:4B5B: A0 18        	LDY	#>LAB_2C80		; set 0.25 pointer high byte
  6611 FF:4B5D: 20 67 42     	JSR	LAB_246C		; add (AY) to FAC1
  6612 FF:4B60: 68           	PLA				; restore FAC1 sign
  6613 FF:4B61: 10 03        	BPL	LAB_2C45		; branch if was +ve
  6614                        
  6615                        					; else correct FAC1
  6616 FF:4B63: 20 2C 4A     	JSR	LAB_GTHAN		; do - FAC1
  6617                        LAB_2C45
  6618 FF:4B66: A9 64        	LDA	#<LAB_2C84		; set pointer low byte to counter
  6619 FF:4B68: A0 18        	LDY	#>LAB_2C84		; set pointer high byte to counter
  6620 FF:4B6A: 4C 89 4A     	JMP	LAB_2B6E		; ^2 then series evaluation and return
  6621                        
  6622                        ; perform TAN()
  6623                        
  6624                        LAB_TAN
  6625 FF:4B6D: 20 EC 45     	JSR	LAB_276E		; pack FAC1 into <Adatal
  6626 FF:4B70: A9 00        	LDA	#$00			; clear byte
  6627 FF:4B72: 85 63        	STA	<Cflag			; clear comparison evaluation flag
  6628 FF:4B74: 20 24 4B     	JSR	LAB_SIN		; go do SIN(n)
  6629 FF:4B77: A2 9C        	LDX	#<func_l		; set sin(n) pointer low byte
  6630 FF:4B79: A0 00        	LDY	#>func_l		; set sin(n) pointer high byte
  6631 FF:4B7B: 20 F6 45     	JSR	LAB_2778		; pack FAC1 into (XY)
  6632 FF:4B7E: A9 A4        	LDA	#<Adatal		; set n pointer low addr
  6633 FF:4B80: A0 00        	LDY	#>Adatal		; set n pointer high addr
  6634 FF:4B82: 20 7C 45     	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
  6635 FF:4B85: A9 00        	LDA	#$00			; clear byte
  6636 FF:4B87: 85 B0        	STA	<FAC1_s		; clear FAC1 sign (b7)
  6637 FF:4B89: A5 63        	LDA	<Cflag			; get comparison evaluation flag
  6638 FF:4B8B: 20 95 4B     	JSR	LAB_2C74		; save flag and go do series evaluation
  6639                        
  6640 FF:4B8E: A9 9C        	LDA	#<func_l		; set sin(n) pointer low byte
  6641 FF:4B90: A0 00        	LDY	#>func_l		; set sin(n) pointer high byte
  6642 FF:4B92: 4C 00 45     	JMP	LAB_26CA		; convert AY and do (AY)/FAC1
  6643                        
  6644                        LAB_2C74
  6645 FF:4B95: 48           	PHA				; save comparison evaluation flag
  6646 FF:4B96: 4C 56 4B     	JMP	LAB_2C35		; go do series evaluation
  6647                        
  6648                        ; perform USR()
  6649                        
  6650                        LAB_USR
  6651 FF:4B99: 20 0A 00     	JSR	Usrjmp		; call user code
  6652 FF:4B9C: 4C 13 35     	JMP	LAB_1BFB		; scan for ")", else do syntax error then warm start
  6653                        
  6654                        ; perform ATN()
  6655                        
  6656                        LAB_ATN
  6657 FF:4B9F: A5 B0        	LDA	<FAC1_s		; get FAC1 sign (b7)
  6658 FF:4BA1: 48           	PHA				; save sign
  6659 FF:4BA2: 10 03        	BPL	LAB_2CA1		; branch if +ve
  6660                        
  6661 FF:4BA4: 20 2C 4A     	JSR	LAB_GTHAN		; else do - FAC1
  6662                        LAB_2CA1
  6663 FF:4BA7: A5 AC        	LDA	<FAC1_e		; get FAC1 exponent
  6664 FF:4BA9: 48           	PHA				; push exponent
  6665 FF:4BAA: C9 81        	CMP	#$81			; compare with 1
  Sun Nov 21 2021 15:13                                                                                                Page 218


  6666 FF:4BAC: 90 07        	BCC	LAB_2CAF		; branch if FAC1<1
  6667                        
  6668 FF:4BAE: A9 9A        	LDA	#<LAB_259C		; set 1 pointer low byte
  6669 FF:4BB0: A0 18        	LDY	#>LAB_259C		; set 1 pointer high byte
  6670 FF:4BB2: 20 00 45     	JSR	LAB_26CA		; convert AY and do (AY)/FAC1
  6671                        LAB_2CAF
  6672 FF:4BB5: A9 79        	LDA	#<LAB_2CC9		; set pointer low byte to counter
  6673 FF:4BB7: A0 18        	LDY	#>LAB_2CC9		; set pointer high byte to counter
  6674 FF:4BB9: 20 89 4A     	JSR	LAB_2B6E		; ^2 then series evaluation
  6675 FF:4BBC: 68           	PLA				; restore old FAC1 exponent
  6676 FF:4BBD: C9 81        	CMP	#$81			; compare with 1
  6677 FF:4BBF: 90 07        	BCC	LAB_2CC2		; branch if FAC1<1
  6678                        
  6679 FF:4BC1: A9 60        	LDA	#<LAB_2C78		; set (pi/2) pointer low byte
  6680 FF:4BC3: A0 18        	LDY	#>LAB_2C78		; set (pi/2) pointer high byte
  6681 FF:4BC5: 20 4C 42     	JSR	LAB_2455		; perform subtraction, (AY) from FAC1
  6682                        LAB_2CC2
  6683 FF:4BC8: 68           	PLA				; restore FAC1 sign
  6684 FF:4BC9: 10 16        	BPL	LAB_2D04		; exit if was +ve
  6685                        
  6686 FF:4BCB: 4C 2C 4A     	JMP	LAB_GTHAN		; else do - FAC1 and return
  6687                        
  6688                        ; perform BITSET
  6689                        
  6690                        LAB_BITSET
  6691 FF:4BCE: 20 29 41     	JSR	LAB_GADB		; get two parameters for POKE or WAIT
  6692 FF:4BD1: E0 08        	CPX	#$08			; only 0 to 7 are allowed
  6693 FF:4BD3: B0 20        	BCS	FCError		; branch if > 7
  6694                        
  6695 FF:4BD5: A9 00        	LDA	#$00			; clear A
  6696 FF:4BD7: 38           	SEC				; set the carry
  6697                        S_Bits
  6698 FF:4BD8: 2A           	ROL	A			; shift bit
  6699 FF:4BD9: CA           	DEX				; decrement bit number
  6700 FF:4BDA: 10 FC        	BPL	S_Bits		; loop if still +ve
  6701                        
  6702 FF:4BDC: E8           	INX				; make X = $00
  6703 FF:4BDD: 01 11        	ORA	(<Itempl,X)		; or with byte via temporary integer (addr)
  6704 FF:4BDF: 81 11        	STA (<Itempl,X)		; save byte via temporary integer (addr)
  6705                        LAB_2D04
  6706 FF:4BE1: 60           	RTS
  6707                        
  6708                        ; perform BITCLR
  6709                        
  6710                        LAB_BITCLR
  6711 FF:4BE2: 20 29 41     	JSR	LAB_GADB		; get two parameters for POKE or WAIT
  6712 FF:4BE5: E0 08        	CPX	#$08			; only 0 to 7 are allowed
  6713 FF:4BE7: B0 0C        	BCS	FCError		; branch if > 7
  6714                        
  6715 FF:4BE9: A9 FF        	LDA	#$FF			; set A
  6716                        S_Bitc
  6717 FF:4BEB: 2A           	ROL	A			; shift bit
  6718 FF:4BEC: CA           	DEX				; decrement bit number
  6719 FF:4BED: 10 FC        	BPL	S_Bitc		; loop if still +ve
  6720                        
  6721 FF:4BEF: E8           	INX				; make X = $00
  6722 FF:4BF0: 21 11        	AND	(<Itempl,X)		; and with byte via temporary integer (addr)
  Sun Nov 21 2021 15:13                                                                                                Page 219


  6723 FF:4BF2: 81 11        	STA (<Itempl,X)		; save byte via temporary integer (addr)
  6724 FF:4BF4: 60           	RTS
  6725                        
  6726                        FCError
  6727 FF:4BF5: 4C 87 38     	JMP	LAB_FCER		; do function call error then warm start
  6728                        
  6729                        ; perform BITTST()
  6730                        
  6731                        LAB_BTST
  6732 FF:4BF8: 22 BC 00 00  	JSL	LAB_IGBY		; increment BASIC pointer
  6733 FF:4BFC: 20 29 41     	JSR	LAB_GADB		; get two parameters for POKE or WAIT
  6734 FF:4BFF: E0 08        	CPX	#$08			; only 0 to 7 are allowed
  6735 FF:4C01: B0 F2        	BCS	FCError		; branch if > 7
  6736                        
  6737 FF:4C03: 22 C2 00 00  	JSL	LAB_GBYT		; get next BASIC byte
  6738 FF:4C07: C9 29        	CMP	#')'			; is next character ")"
  6739 FF:4C09: F0 03        	BEQ	TST_OK		; if ")" go do rest of function
  6740                        
  6741 FF:4C0B: 4C 28 35     	JMP	LAB_SNER		; do syntax error then warm start
  6742                        
  6743                        TST_OK
  6744 FF:4C0E: 22 BC 00 00  	JSL	LAB_IGBY		; update BASIC execute pointer (to character past ")")
  6745 FF:4C12: A9 00        	LDA	#$00			; clear A
  6746 FF:4C14: 38           	SEC				; set the carry
  6747                        T_Bits
  6748 FF:4C15: 2A           	ROL	A			; shift bit
  6749 FF:4C16: CA           	DEX				; decrement bit number
  6750 FF:4C17: 10 FC        	BPL	T_Bits		; loop if still +ve
  6751                        
  6752 FF:4C19: E8           	INX				; make X = $00
  6753 FF:4C1A: 21 11        	AND	(<Itempl,X)		; AND with byte via temporary integer (addr)
  6754 FF:4C1C: F0 02        	BEQ	LAB_NOTT		; branch if zero (already correct)
  6755                        
  6756 FF:4C1E: A9 FF        	LDA	#$FF			; set for -1 result
  6757                        LAB_NOTT
  6758 FF:4C20: 4C 99 46     	JMP	LAB_27DB		; go do SGN tail
  6759                        
  6760                        ; perform BIN$()
  6761                        
  6762                        LAB_BINS
  6763 FF:4C23: E0 19        	CPX	#$19			; max + 1
  6764 FF:4C25: B0 71        	BCS	BinFErr		; exit if too big ( > or = )
  6765                        
  6766 FF:4C27: 86 78        	STX	<TempB			; save # of characters ($00 = leading zero remove)
  6767 FF:4C29: A9 18        	LDA	#$18			; need A byte long space
  6768 FF:4C2B: 20 2E 3B     	JSR	LAB_MSSP		; make string space A bytes long
  6769 FF:4C2E: A0 17        	LDY	#$17			; set index
  6770 FF:4C30: A2 18        	LDX	#$18			; character count
  6771                        NextB1
  6772 FF:4C32: 46 11        	LSR	<nums_1		; shift highest byte
  6773 FF:4C34: 66 12        	ROR	<nums_2		; shift middle byte
  6774 FF:4C36: 66 13        	ROR	<nums_3		; shift lowest byte bit 0 to carry
  6775 FF:4C38: 8A           	TXA				; load with "0"/2
  6776 FF:4C39: 2A           	ROL	A			; shift in carry
  6777                        	STAINDIRECTY str_pl		; save to temp string + index
+ 6777 FF:4C3A: 8B               PHB
+ 6777 FF:4C3B: DA           	PHX
  Sun Nov 21 2021 15:13                                                                                                Page 220


+ 6777 FF:4C3C: 48               PHA
+ 6777 FF:4C3D: A2 01            LDX #$01
+ 6777 FF:4C3F: B5 AD            LDA <str_pl,X
+ 6777 FF:4C41: C9 00            CMP #$00
+ 6777 FF:4C43: D0 04            BNE *+6
+ 6777 FF:4C45: A2 00        	LDX #00
+ 6777 FF:4C47: DA           	PHX
+ 6777 FF:4C48: AB           	PLB
+ 6777 FF:4C49: 68               PLA
+ 6777 FF:4C4A: FA               PLX
+ 6777 FF:4C4B: 91 AD        	STA	(<str_pl),Y		;
+ 6777 FF:4C4D: AB           	PLB
+ 6777 FF:4C4E: 85 04            STA <TMPFLG
  6778 FF:4C50: 88           	DEY				; decrement index
  6779 FF:4C51: 10 DF        	BPL	NextB1		; loop if not done
  6780                        
  6781 FF:4C53: A5 78        	LDA	<TempB			; get # of characters
  6782 FF:4C55: F0 0A        	BEQ	EndBHS		; branch if truncate
  6783                        
  6784 FF:4C57: AA           	TAX				; copy length to X
  6785 FF:4C58: 38           	SEC				; set carry for add !
  6786 FF:4C59: 49 FF        	EOR	#$FF			; 1's complement
  6787 FF:4C5B: 69 18        	ADC	#$18			; add 24d
  6788 FF:4C5D: F0 30        	BEQ	GoPr2			; if zero print whole string
  6789                        
  6790 FF:4C5F: D0 23        	BNE	GoPr1			; else go make output string
  6791                        
  6792                        ; this is the exit code and is also used by HEX$()
  6793                        ; truncate string to remove leading "0"s
  6794                        
  6795                        EndBHS
  6796 FF:4C61: A8           	TAY				; clear index (A=0, X=length here)
  6797                        NextB2
  6798                        	LDAINDIRECTY str_pl		; get character from string
+ 6798 FF:4C62: 8B               PHB
+ 6798 FF:4C63: DA           	PHX
+ 6798 FF:4C64: A2 01            LDX #$01
+ 6798 FF:4C66: B5 AD            LDA <str_pl,X
+ 6798 FF:4C68: C9 00            CMP #$00
+ 6798 FF:4C6A: D0 04            BNE *+6
+ 6798 FF:4C6C: A2 00        	LDX #00
+ 6798 FF:4C6E: DA           	PHX
+ 6798 FF:4C6F: AB           	PLB
+ 6798 FF:4C70: FA               PLX
+ 6798 FF:4C71: B1 AD        	LDA	(<str_pl),Y		;
+ 6798 FF:4C73: 85 04            STA <TMPFLG
+ 6798 FF:4C75: AB               PLB
+ 6798 FF:4C76: A5 04            LDA <TMPFLG
  6799 FF:4C78: C9 30        	CMP	#'0'			; compare with "0"
  6800 FF:4C7A: D0 07        	BNE	GoPr			; if not "0" then go print string from here
  6801                        
  6802 FF:4C7C: CA           	DEX				; decrement character count
  6803 FF:4C7D: F0 03        	BEQ	GoPr3			; if zero then end of string so go print it
  6804                        
  6805 FF:4C7F: C8           	INY				; else increment index
  6806 FF:4C80: 10 E0        	BPL	NextB2		; loop always
  6807                        
  Sun Nov 21 2021 15:13                                                                                                Page 221


  6808                        ; make fixed length output string - ignore overflows!
  6809                        
  6810                        GoPr3
  6811 FF:4C82: E8           	INX				; need at least 1 character
  6812                        GoPr
  6813 FF:4C83: 98           	TYA				; copy result
  6814                        GoPr1
  6815 FF:4C84: 18           	CLC				; clear carry for add
  6816 FF:4C85: 65 AD        	ADC	<str_pl		; add low address
  6817 FF:4C87: 85 AD        	STA	<str_pl		; save low address
  6818 FF:4C89: A9 00        	LDA	#$00			; do high byte
  6819 FF:4C8B: 65 AE        	ADC	<str_ph		; add high address
  6820 FF:4C8D: 85 AE        	STA	<str_ph		; save high address
  6821                        GoPr2
  6822 FF:4C8F: 86 AC        	STX	<str_ln		; X holds string length
  6823 FF:4C91: 22 BC 00 00  	JSL	LAB_IGBY		; update BASIC execute pointer (to character past ")")
  6824 FF:4C95: 4C 91 3B     	JMP	LAB_RTST		; check for space on descriptor stack then put address
  6825                        					; and length on descriptor stack and update stack pointers
  6826                        
  6827                        BinFErr
  6828 FF:4C98: 4C 87 38     	JMP	LAB_FCER		; do function call error then warm start
  6829                        
  6830                        ; perform HEX$()
  6831                        
  6832                        LAB_HEXS
  6833 FF:4C9B: E0 07        	CPX	#$07			; max + 1
  6834 FF:4C9D: B0 F9        	BCS	BinFErr		; exit if too big ( > or = )
  6835                        
  6836 FF:4C9F: 86 78        	STX	<TempB			; save # of characters
  6837                        
  6838 FF:4CA1: A9 06        	LDA	#$06			; need 6 bytes for string
  6839 FF:4CA3: 20 2E 3B     	JSR	LAB_MSSP		; make string space A bytes long
  6840 FF:4CA6: A0 05        	LDY	#$05			; set string index
  6841                        
  6842 FF:4CA8: F8           	SED				; need decimal mode for nibble convert
  6843 FF:4CA9: A5 13        	LDA	<nums_3		; get lowest byte
  6844 FF:4CAB: 20 C9 4C     	JSR	LAB_A2HX		; convert A to ASCII hex byte and output
  6845 FF:4CAE: A5 12        	LDA	<nums_2		; get middle byte
  6846 FF:4CB0: 20 C9 4C     	JSR	LAB_A2HX		; convert A to ASCII hex byte and output
  6847 FF:4CB3: A5 11        	LDA	<nums_1		; get highest byte
  6848 FF:4CB5: 20 C9 4C     	JSR	LAB_A2HX		; convert A to ASCII hex byte and output
  6849 FF:4CB8: D8           	CLD				; back to binary
  6850                        
  6851 FF:4CB9: A2 06        	LDX	#$06			; character count
  6852 FF:4CBB: A5 78        	LDA	<TempB			; get # of characters
  6853 FF:4CBD: F0 A2        	BEQ	EndBHS		; branch if truncate
  6854                        
  6855 FF:4CBF: AA           	TAX				; copy length to X
  6856 FF:4CC0: 38           	SEC				; set carry for add !
  6857 FF:4CC1: 49 FF        	EOR	#$FF			; 1's complement
  6858 FF:4CC3: 69 06        	ADC	#$06			; add 6d
  6859 FF:4CC5: F0 C8        	BEQ	GoPr2			; if zero print whole string
  6860                        
  6861 FF:4CC7: D0 BB        	BNE	GoPr1			; else go make output string (branch always)
  6862                        
  6863                        ; convert A to ASCII hex byte and output .. note set decimal mode before calling
  6864                        
  Sun Nov 21 2021 15:13                                                                                                Page 222


  6865                        LAB_A2HX
  6866 FF:4CC9: AA           	TAX				; save byte
  6867 FF:4CCA: 29 0F        	AND	#$0F			; mask off top bits
  6868 FF:4CCC: 20 D4 4C     	JSR	LAB_AL2X		; convert low nibble to ASCII and output
  6869 FF:4CCF: 8A           	TXA				; get byte back
  6870 FF:4CD0: 4A           	LSR	A			; /2	shift high nibble to low nibble
  6871 FF:4CD1: 4A           	LSR	A			; /4
  6872 FF:4CD2: 4A           	LSR	A			; /8
  6873 FF:4CD3: 4A           	LSR	A			; /16
  6874                        LAB_AL2X
  6875 FF:4CD4: C9 0A        	CMP	#$0A			; set carry for +1 if >9
  6876 FF:4CD6: 69 30        	ADC	#'0'			; add ASCII "0"
  6877                        	STAINDIRECTY str_pl		; save to temp string
+ 6877 FF:4CD8: 8B               PHB
+ 6877 FF:4CD9: DA           	PHX
+ 6877 FF:4CDA: 48               PHA
+ 6877 FF:4CDB: A2 01            LDX #$01
+ 6877 FF:4CDD: B5 AD            LDA <str_pl,X
+ 6877 FF:4CDF: C9 00            CMP #$00
+ 6877 FF:4CE1: D0 04            BNE *+6
+ 6877 FF:4CE3: A2 00        	LDX #00
+ 6877 FF:4CE5: DA           	PHX
+ 6877 FF:4CE6: AB           	PLB
+ 6877 FF:4CE7: 68               PLA
+ 6877 FF:4CE8: FA               PLX
+ 6877 FF:4CE9: 91 AD        	STA	(<str_pl),Y		;
+ 6877 FF:4CEB: AB           	PLB
+ 6877 FF:4CEC: 85 04            STA <TMPFLG
  6878 FF:4CEE: 88           	DEY				; decrement counter
  6879 FF:4CEF: 60           	RTS
  6880                        
  6881                        LAB_NLTO
  6882 FF:4CF0: 85 AC        	STA	<FAC1_e		; save FAC1 exponent
  6883 FF:4CF2: A9 00        	LDA	#$00			; clear sign compare
  6884                        LAB_MLTE
  6885 FF:4CF4: 85 B8        	STA	<FAC_sc		; save sign compare (FAC1 EOR FAC2)
  6886 FF:4CF6: 8A           	TXA				; restore character
  6887 FF:4CF7: 20 4F 48     	JSR	LAB_2912		; evaluate new ASCII digit
  6888                        
  6889                        ; gets here if the first character was "$" for hex
  6890                        ; get hex number
  6891                        
  6892                        LAB_CHEX
  6893 FF:4CFA: 22 BC 00 00  	JSL	LAB_IGBY		; increment and scan memory
  6894 FF:4CFE: 90 0A        	BCC	LAB_ISHN		; branch if numeric character
  6895                        
  6896 FF:4D00: 09 20        	ORA	#$20			; case convert, allow "A" to "F" and "a" to "f"
  6897 FF:4D02: E9 61        	SBC	#'a'			; subtract "a" (carry set here)
  6898 FF:4D04: C9 06        	CMP	#$06			; compare normalised with $06 (max+1)
  6899 FF:4D06: B0 2B        	BCS	LAB_EXCH		; exit if >"f" or <"0"
  6900                        
  6901 FF:4D08: 69 0A        	ADC	#$0A			; convert to nibble
  6902                        LAB_ISHN
  6903 FF:4D0A: 29 0F        	AND	#$0F			; convert to binary
  6904 FF:4D0C: AA           	TAX				; save nibble
  6905 FF:4D0D: A5 AC        	LDA	<FAC1_e		; get FAC1 exponent
  6906 FF:4D0F: F0 E3        	BEQ	LAB_MLTE		; skip multiply if zero
  Sun Nov 21 2021 15:13                                                                                                Page 223


  6907                        
  6908 FF:4D11: 69 04        	ADC	#$04			; add four to exponent (*16 - carry clear here)
  6909 FF:4D13: 90 DB        	BCC	LAB_NLTO		; if no overflow do evaluate digit
  6910                        
  6911                        LAB_MLTO
  6912 FF:4D15: 4C 72 43     	JMP	LAB_2564		; do overflow error and warm start
  6913                        
  6914                        LAB_NXCH
  6915 FF:4D18: AA           	TAX				; save bit
  6916 FF:4D19: A5 AC        	LDA	<FAC1_e		; get FAC1 exponent
  6917 FF:4D1B: F0 06        	BEQ	LAB_MLBT		; skip multiply if zero
  6918                        
  6919 FF:4D1D: E6 AC        	INC	<FAC1_e		; increment FAC1 exponent (*2)
  6920 FF:4D1F: F0 F4        	BEQ	LAB_MLTO		; do overflow error if = $00
  6921                        
  6922 FF:4D21: A9 00        	LDA	#$00			; clear sign compare
  6923                        LAB_MLBT
  6924 FF:4D23: 85 B8        	STA	<FAC_sc		; save sign compare (FAC1 EOR FAC2)
  6925 FF:4D25: 8A           	TXA				; restore bit
  6926 FF:4D26: 20 4F 48     	JSR	LAB_2912		; evaluate new ASCII digit
  6927                        
  6928                        ; gets here if the first character was  "%" for binary
  6929                        ; get binary number
  6930                        
  6931                        LAB_CBIN
  6932 FF:4D29: 22 BC 00 00  	JSL	LAB_IGBY		; increment and scan memory
  6933 FF:4D2D: 49 30        	EOR	#'0'			; convert "0" to 0 etc.
  6934 FF:4D2F: C9 02        	CMP	#$02			; compare with max+1
  6935 FF:4D31: 90 E5        	BCC	LAB_NXCH		; branch exit if < 2
  6936                        
  6937                        LAB_EXCH
  6938 FF:4D33: 4C 34 48     	JMP	LAB_28F6		; evaluate -ve flag and return
  6939                        
  6940                        ; ctrl-c check routine. includes limited "life" byte save for INGET routine
  6941                        ; now also the code that checks to see if an interrupt has occurred
  6942                        
  6943                        CTRLC
  6944 FF:4D36: AF 00 02 00  	LDA	>ccflag		; get [CTRL-C] check flag
  6945 FF:4D3A: D0 21        	BNE	LAB_FBA2		; exit if inhibited
  6946                        
  6947 FF:4D3C: 20 C1 18     	JSR	V_INPT		; scan input device
  6948 FF:4D3F: B0 11        	BCS	LAB_FBA0		; exit if buffer empty
  6949                        
  6950 FF:4D41: 8F 01 02 00  	STA	>ccbyte		; save received byte
  6951 FF:4D45: A9 20        	LDA	#$20		; "life" timer for bytes
  6952 FF:4D47: 8F 02 02 00  	STA	>ccnull		; set countdown
  6953 FF:4D4B: AF 01 02 00  	LDA	>ccbyte
  6954 FF:4D4F: 4C D4 2C     	JMP	LAB_1636	; return to BASIC
  6955                        
  6956                        LAB_FBA0
  6957 FF:4D52: AF 02 02 00  	LDA	>ccnull		; get countdown byte
  6958 FF:4D56: F0 05        	BEQ	LAB_FBA2		; exit if finished
  6959 FF:4D58: 3A           	DEC 	A
  6960 FF:4D59: 8F 02 02 00  	STA	>ccnull		; else decrement countdown
  6961                        LAB_FBA2
  6962 FF:4D5D: A2 E5        	LDX	#<NmiBase		; set pointer to NMI values
  6963 FF:4D5F: 20 6C 4D     	JSR	LAB_CKIN		; go check interrupt
  Sun Nov 21 2021 15:13                                                                                                Page 224


  6964 FF:4D62: A2 E8        	LDX	#<IrqBase		; set pointer to IRQ values
  6965 FF:4D64: 20 6C 4D     	JSR	LAB_CKIN		; go check interrupt
  6966 FF:4D67: AF 01 02 00  	LDA	>ccbyte
  6967                        LAB_CRTS
  6968 FF:4D6B: 60           	RTS
  6969                        
  6970                        ; check whichever interrupt is indexed by X
  6971                        
  6972                        LAB_CKIN
  6973 FF:4D6C: B5 00        	LDA	<PLUS_0,X		; get interrupt flag byte
  6974 FF:4D6E: 10 FB        	BPL	LAB_CRTS		; branch if interrupt not enabled
  6975                        
  6976                        ; we disable the interrupt here and make two new commands RETIRQ and RETNMI to
  6977                        ; automatically enable the interrupt when we exit
  6978                        
  6979 FF:4D70: 0A           	ASL	A			; move happened bit to setup bit
  6980 FF:4D71: 29 40        	AND	#$40			; mask happened bits
  6981 FF:4D73: F0 F6        	BEQ	LAB_CRTS		; if no interrupt then exit
  6982                        
  6983 FF:4D75: 95 00        	STA	<PLUS_0,X		; save interrupt flag byte
  6984                        
  6985 FF:4D77: 8A           	TXA				; copy index ..
  6986 FF:4D78: A8           	TAY				; .. to Y
  6987                        
  6988 FF:4D79: 68           	PLA				; dump return address low byte, call from CTRL-C
  6989 FF:4D7A: 68           	PLA				; dump return address high byte
  6990                        
  6991 FF:4D7B: A9 05        	LDA	#$05			; need 5 bytes for GOSUB
  6992 FF:4D7D: 20 78 28     	JSR	LAB_1212		; check room on stack for A bytes
  6993 FF:4D80: A5 C4        	LDA	<Bpntrh		; get BASIC execute pointer high byte
  6994 FF:4D82: 48           	PHA				; push on stack
  6995 FF:4D83: A5 C3        	LDA	<Bpntrl		; get BASIC execute pointer low byte
  6996 FF:4D85: 48           	PHA				; push on stack
  6997 FF:4D86: A5 88        	LDA	<Clineh		; get current line high byte
  6998 FF:4D88: 48           	PHA				; push on stack
  6999 FF:4D89: A5 87        	LDA	<Clinel		; get current line low byte
  7000 FF:4D8B: 48           	PHA				; push on stack
  7001 FF:4D8C: A9 8F        	LDA	#TK_GOSUB		; token for GOSUB
  7002 FF:4D8E: 48           	PHA				; push on stack
  7003 FF:4D8F: DA           	phx
  7004 FF:4D90: BB           	tyx
  7005 FF:4D91: B5 01        	LDA	<PLUS_1,X		; get interrupt code pointer low byte
  7006 FF:4D93: 85 C3        	STA	<Bpntrl		; save as BASIC execute pointer low byte
  7007 FF:4D95: B5 02        	LDA	<PLUS_2,X		; get interrupt code pointer high byte
  7008 FF:4D97: 85 C4        	STA	<Bpntrh		; save as BASIC execute pointer high byte
  7009 FF:4D99: FA           	plx
  7010 FF:4D9A: 4C 76 2C     	JMP	LAB_15C2		; go do interpreter inner loop
  7011                        					; can't RTS, we used the stack! the RTS from the ctrl-c
  7012                        					; check will be taken when the RETIRQ/RETNMI/RETURN is
  7013                        					; executed at the end of the subroutine
  7014                        
  7015                        ; get byte from input device, no waiting
  7016                        ; returns with carry set if byte in A
  7017                        
  7018                        INGET
  7019 FF:4D9D: 20 C1 18     	JSR	V_INPT		; call scan input device
  7020 FF:4DA0: 90 0B        	BCC	LAB_FB95		; if byte go reset timer
  Sun Nov 21 2021 15:13                                                                                                Page 225


  7021                        
  7022 FF:4DA2: AF 02 02 00  	LDA	>ccnull		; get countdown
  7023 FF:4DA6: F0 0F        	BEQ	LAB_FB96		; exit if empty
  7024                        
  7025 FF:4DA8: AF 01 02 00  	LDA	>ccbyte		; get last received byte
  7026 FF:4DAC: 38           	SEC				; flag we got a byte
  7027                        LAB_FB95
  7028 FF:4DAD: A9 00        	LDA	#$00			; clear X
  7029 FF:4DAF: 8F 02 02 00  	STA	>ccnull		; clear timer because we got a byte
  7030 FF:4DB3: AF 01 02 00  	LDA	>ccbyte		; get last received byte
  7031                        LAB_FB96
  7032 FF:4DB7: 60           	RTS
  7033                        
  7034                        ; these routines only enable the interrupts if the set-up flag is set
  7035                        ; if not they have no effect
  7036                        
  7037                        ; perform IRQ {ON|OFF|CLEAR}
  7038                        
  7039                        LAB_IRQ
  7040 FF:4DB8: A2 E8        	LDX	#<IrqBase		; set pointer to IRQ values
  7041 FF:4DBA: 2C           	.byte	$2C			; make next line BIT abs.
  7042                        
  7043                        ; perform NMI {ON|OFF|CLEAR}
  7044                        
  7045                        LAB_NMI
  7046 FF:4DBB: A2 E5        	LDX	#<NmiBase		; set pointer to NMI values
  7047 FF:4DBD: C9 93        	CMP	#TK_ON		; compare with token for ON
  7048 FF:4DBF: F0 11        	BEQ	LAB_INON		; go turn on interrupt
  7049                        
  7050 FF:4DC1: C9 CA        	CMP	#TK_OFF		; compare with token for OFF
  7051 FF:4DC3: F0 07        	BEQ	LAB_IOFF		; go turn off interrupt
  7052                        
  7053 FF:4DC5: 49 A1        	EOR	#TK_CLEAR		; compare with token for CLEAR, A = $00 if = TK_CLEAR
  7054 FF:4DC7: F0 0E        	BEQ	LAB_INEX		; go clear interrupt flags and return
  7055                        
  7056 FF:4DC9: 4C 28 35     	JMP	LAB_SNER		; do syntax error then warm start
  7057                        
  7058                        LAB_IOFF
  7059 FF:4DCC: A9 7F        	LDA	#$7F			; clear A
  7060 FF:4DCE: 35 00        	AND	<PLUS_0,X		; AND with interrupt setup flag
  7061 FF:4DD0: 10 05        	BPL	LAB_INEX		; go clear interrupt enabled flag and return
  7062                        
  7063                        LAB_INON
  7064 FF:4DD2: B5 00        	LDA	<PLUS_0,X		; get interrupt setup flag
  7065 FF:4DD4: 0A           	ASL	A			; Shift bit to enabled flag
  7066 FF:4DD5: 15 00        	ORA	<PLUS_0,X		; OR with flag byte
  7067                        LAB_INEX
  7068 FF:4DD7: 95 00        	STA	<PLUS_0,X		; save interrupt flag byte
  7069 FF:4DD9: 22 BC 00 00  	JSL	LAB_IGBY		; update BASIC execute pointer and return
  7070 FF:4DDD: 60           	RTS
  7071                        ; these routines set up the pointers and flags for the interrupt routines
  7072                        ; note that the interrupts are also enabled by these commands
  7073                        
  7074                        
  7075                        ; MAX() MIN() pre process
  7076                        
  7077                        LAB_MMPP
  Sun Nov 21 2021 15:13                                                                                                Page 226


  7078 FF:4DDE: 20 0A 34     	JSR	LAB_EVEZ		; process expression
  7079 FF:4DE1: 4C F1 33     	JMP	LAB_CTNM		; check if source is numeric, else do type mismatch
  7080                        
  7081                        ; perform MAX()
  7082                        
  7083                        LAB_MAX
  7084 FF:4DE4: 20 14 4E     	JSR	LAB_PHFA		; push FAC1, evaluate expression,
  7085                        					; pull FAC2 and compare with FAC1
  7086 FF:4DE7: 10 FB        	BPL	LAB_MAX		; branch if no swap to do
  7087                        
  7088 FF:4DE9: A5 B4        	LDA	<FAC2_1		; get FAC2 mantissa1
  7089 FF:4DEB: 09 80        	ORA	#$80			; set top bit (clear sign from compare)
  7090 FF:4DED: 85 B4        	STA	<FAC2_1		; save FAC2 mantissa1
  7091 FF:4DEF: 20 6C 42     	JSR	LAB_279B		; copy FAC2 to FAC1
  7092 FF:4DF2: F0 F0        	BEQ	LAB_MAX		; go do next (branch always)
  7093                        
  7094                        ; perform MIN()
  7095                        
  7096                        LAB_MIN
  7097 FF:4DF4: 20 14 4E     	JSR	LAB_PHFA		; push FAC1, evaluate expression,
  7098                        					; pull FAC2 and compare with FAC1
  7099 FF:4DF7: 30 FB        	BMI	LAB_MIN		; branch if no swap to do
  7100                        
  7101 FF:4DF9: F0 F9        	BEQ	LAB_MIN		; branch if no swap to do
  7102                        
  7103 FF:4DFB: A5 B4        	LDA	<FAC2_1		; get FAC2 mantissa1
  7104 FF:4DFD: 09 80        	ORA	#$80			; set top bit (clear sign from compare)
  7105 FF:4DFF: 85 B4        	STA	<FAC2_1		; save FAC2 mantissa1
  7106 FF:4E01: 20 6C 42     	JSR	LAB_279B		; copy FAC2 to FAC1
  7107 FF:4E04: F0 EE        	BEQ	LAB_MIN		; go do next (branch always)
  7108                        
  7109                        ; exit routine. don't bother returning to the loop code
  7110                        ; check for correct exit, else so syntax error
  7111                        
  7112                        LAB_MMEC
  7113 FF:4E06: C9 29        	CMP	#')'			; is it end of function?
  7114 FF:4E08: D0 07        	BNE	LAB_MMSE		; if not do MAX MIN syntax error
  7115                        
  7116 FF:4E0A: 68           	PLA				; dump return address low byte
  7117 FF:4E0B: 68           	PLA				; dump return address high byte
  7118 FF:4E0C: 22 BC 00 00  	JSL	LAB_IGBY		; update BASIC execute pointer (to chr past ")")
  7119 FF:4E10: 60           	RTS
  7120                        LAB_MMSE
  7121 FF:4E11: 4C 28 35     	JMP	LAB_SNER		; do syntax error then warm start
  7122                        
  7123                        ; check for next, evaluate and return or exit
  7124                        ; this is the routine that does most of the work
  7125                        
  7126                        LAB_PHFA
  7127 FF:4E14: 22 C2 00 00  	JSL	LAB_GBYT		; get next BASIC byte
  7128 FF:4E18: C9 2C        	CMP	#','			; is there more ?
  7129 FF:4E1A: D0 EA        	BNE	LAB_MMEC		; if not go do end check
  7130                        
  7131                        					; push FAC1
  7132 FF:4E1C: 20 78 46     	JSR	LAB_27BA		; round FAC1
  7133 FF:4E1F: A5 B0        	LDA	<FAC1_s		; get FAC1 sign
  7134 FF:4E21: 09 7F        	ORA	#$7F			; set all non sign bits
  Sun Nov 21 2021 15:13                                                                                                Page 227


  7135 FF:4E23: 25 AD        	AND	<FAC1_1		; AND FAC1 mantissa1 (AND in sign bit)
  7136 FF:4E25: 48           	PHA				; push on stack
  7137 FF:4E26: A5 AE        	LDA	<FAC1_2		; get FAC1 mantissa2
  7138 FF:4E28: 48           	PHA				; push on stack
  7139 FF:4E29: A5 AF        	LDA	<FAC1_3		; get FAC1 mantissa3
  7140 FF:4E2B: 48           	PHA				; push on stack
  7141 FF:4E2C: A5 AC        	LDA	<FAC1_e		; get FAC1 exponent
  7142 FF:4E2E: 48           	PHA				; push on stack
  7143                        
  7144 FF:4E2F: 22 BC 00 00  	JSL	LAB_IGBY		; scan and get next BASIC byte (after ",")
  7145 FF:4E33: 20 EE 33     	JSR	LAB_EVNM		; evaluate expression and check is numeric,
  7146                        					; else do type mismatch
  7147                        
  7148                        					; pop FAC2 (MAX/MIN expression so far)
  7149 FF:4E36: 68           	PLA				; pop exponent
  7150 FF:4E37: 85 B3        	STA	<FAC2_e		; save FAC2 exponent
  7151 FF:4E39: 68           	PLA				; pop mantissa3
  7152 FF:4E3A: 85 B6        	STA	<FAC2_3		; save FAC2 mantissa3
  7153 FF:4E3C: 68           	PLA				; pop mantissa1
  7154 FF:4E3D: 85 B5        	STA	<FAC2_2		; save FAC2 mantissa2
  7155 FF:4E3F: 68           	PLA				; pop sign/mantissa1
  7156 FF:4E40: 85 B4        	STA	<FAC2_1		; save FAC2 sign/mantissa1
  7157 FF:4E42: 85 B7        	STA	<FAC2_s		; save FAC2 sign
  7158                        
  7159                        					; compare FAC1 with (packed) FAC2
  7160 FF:4E44: A9 B3        	LDA	#<FAC2_e		; set pointer low byte to FAC2
  7161 FF:4E46: A0 00        	LDY	#>FAC2_e		; set pointer high byte to FAC2
  7162 FF:4E48: 4C B6 46     	JMP	LAB_27F8		; compare FAC1 with FAC2 (AY) and return
  7163                        					; returns A=$00 if FAC1 = (AY)
  7164                        					; returns A=$01 if FAC1 > (AY)
  7165                        					; returns A=$FF if FAC1 < (AY)
  7166                        
  7167                        ; perform WIDTH
  7168                        
  7169                        LAB_WDTH
  7170 FF:4E4B: C9 2C        	CMP	#','			; is next byte ","
  7171 FF:4E4D: F0 1C        	BEQ	LAB_TBSZ		; if so do tab size
  7172                        
  7173 FF:4E4F: 20 9E 40     	JSR	LAB_GTBY		; get byte parameter
  7174 FF:4E52: 8A           	TXA				; copy width to A
  7175 FF:4E53: F0 0A        	BEQ	LAB_NSTT		; branch if set for infinite line
  7176                        
  7177 FF:4E55: E0 10        	CPX	#$10			; else make min width = 16d
  7178 FF:4E57: 90 46        	BCC	TabErr		; if less do function call error and exit
  7179                        
  7180                        ; this next compare ensures that we can't exit WIDTH via an error leaving the
  7181                        ; tab size greater than the line length.
  7182                        
  7183 FF:4E59: E4 64        	CPX	<TabSiz		; compare with tab size
  7184 FF:4E5B: B0 02        	BCS	LAB_NSTT		; branch if >= tab size
  7185                        
  7186 FF:4E5D: 86 64        	STX	<TabSiz		; else make tab size = terminal width
  7187                        LAB_NSTT
  7188 FF:4E5F: 86 0F        	STX	<TWidth		; set the terminal width
  7189 FF:4E61: 22 C2 00 00  	JSL	LAB_GBYT		; get BASIC byte back
  7190 FF:4E65: F0 1A        	BEQ	WExit			; exit if no following
  7191                        
  Sun Nov 21 2021 15:13                                                                                                Page 228


  7192 FF:4E67: C9 2C        	CMP	#','			; else is it ","
  7193 FF:4E69: D0 A6        	BNE	LAB_MMSE		; if not do syntax error
  7194                        
  7195                        LAB_TBSZ
  7196 FF:4E6B: 20 9A 40     	JSR	LAB_SGBY		; scan and get byte parameter
  7197 FF:4E6E: 8A           	TXA				; copy TAB size
  7198 FF:4E6F: 30 2E        	BMI	TabErr		; if >127 do function call error and exit
  7199                        
  7200 FF:4E71: E0 01        	CPX	#$01			; compare with min-1
  7201 FF:4E73: 90 2A        	BCC	TabErr		; if <=1 do function call error and exit
  7202                        
  7203 FF:4E75: A5 0F        	LDA	<TWidth		; set flags for width
  7204 FF:4E77: F0 06        	BEQ	LAB_SVTB		; skip check if infinite line
  7205                        
  7206 FF:4E79: E4 0F        	CPX	<TWidth		; compare TAB with width
  7207 FF:4E7B: F0 02        	BEQ	LAB_SVTB		; ok if =
  7208                        
  7209 FF:4E7D: B0 20        	BCS	TabErr		; branch if too big
  7210                        
  7211                        LAB_SVTB
  7212 FF:4E7F: 86 64        	STX	<TabSiz		; save TAB size
  7213                        
  7214                        ; calculate tab column limit from TAB size. The <Iclim is set to the last tab
  7215                        ; position on a line that still has at least one whole tab width between it
  7216                        ; and the end of the line.
  7217                        
  7218                        WExit
  7219 FF:4E81: A5 0F        	LDA	<TWidth		; get width
  7220 FF:4E83: F0 06        	BEQ	LAB_SULP		; branch if infinite line
  7221                        
  7222 FF:4E85: C5 64        	CMP	<TabSiz		; compare with tab size
  7223 FF:4E87: B0 03        	BCS	LAB_WDLP		; branch if >= tab size
  7224                        
  7225 FF:4E89: 85 64        	STA	<TabSiz		; else make tab size = terminal width
  7226                        LAB_SULP
  7227 FF:4E8B: 38           	SEC				; set carry for subtract
  7228                        LAB_WDLP
  7229 FF:4E8C: E5 64        	SBC	<TabSiz		; subtract tab size
  7230 FF:4E8E: B0 FC        	BCS	LAB_WDLP		; loop while no borrow
  7231                        
  7232 FF:4E90: 65 64        	ADC	<TabSiz		; add tab size back
  7233 FF:4E92: 18           	CLC				; clear carry for add
  7234 FF:4E93: 65 64        	ADC	<TabSiz		; add tab size back again
  7235 FF:4E95: 85 10        	STA	<Iclim			; save for now
  7236 FF:4E97: A5 0F        	LDA	<TWidth		; get width back
  7237 FF:4E99: 38           	SEC				; set carry for subtract
  7238 FF:4E9A: E5 10        	SBC	<Iclim			; subtract remainder
  7239 FF:4E9C: 85 10        	STA	<Iclim			; save tab column limit
  7240                        LAB_NOSQ
  7241 FF:4E9E: 60           	RTS
  7242                        
  7243                        TabErr
  7244 FF:4E9F: 4C 87 38     	JMP	LAB_FCER		; do function call error then warm start
  7245                        
  7246                        ; perform SQR()
  7247                        
  7248                        LAB_SQR
  Sun Nov 21 2021 15:13                                                                                                Page 229


  7249 FF:4EA2: A5 B0        	LDA	<FAC1_s		; get FAC1 sign
  7250 FF:4EA4: 30 F9        	BMI	TabErr		; if -ve do function call error
  7251                        
  7252 FF:4EA6: A5 AC        	LDA	<FAC1_e		; get exponent
  7253 FF:4EA8: F0 F4        	BEQ	LAB_NOSQ		; if zero just return
  7254                        
  7255                        					; else do root
  7256 FF:4EAA: 20 69 46     	JSR	LAB_27AB		; round and copy FAC1 to FAC2
  7257 FF:4EAD: A9 00        	LDA	#$00			; clear A
  7258                        
  7259 FF:4EAF: 85 77        	STA	<FACt_3		; clear remainder
  7260 FF:4EB1: 85 76        	STA	<FACt_2		; ..
  7261 FF:4EB3: 85 75        	STA	<FACt_1		; ..
  7262 FF:4EB5: 85 78        	STA	<TempB			; ..
  7263                        
  7264 FF:4EB7: 85 AF        	STA	<FAC1_3		; clear root
  7265 FF:4EB9: 85 AE        	STA	<FAC1_2		; ..
  7266 FF:4EBB: 85 AD        	STA	<FAC1_1		; ..
  7267                        
  7268 FF:4EBD: A2 18        	LDX	#$18			; 24 pairs of bits to do
  7269 FF:4EBF: A5 B3        	LDA	<FAC2_e		; get exponent
  7270 FF:4EC1: 4A           	LSR	A			; check odd/even
  7271 FF:4EC2: B0 0E        	BCS	LAB_SQE2		; if odd only 1 shift first time
  7272                        
  7273                        LAB_SQE1
  7274 FF:4EC4: 06 B6        	ASL	<FAC2_3		; shift highest bit of number ..
  7275 FF:4EC6: 26 B5        	ROL	<FAC2_2		; ..
  7276 FF:4EC8: 26 B4        	ROL	<FAC2_1		; ..
  7277 FF:4ECA: 26 77        	ROL	<FACt_3		; .. into remainder
  7278 FF:4ECC: 26 76        	ROL	<FACt_2		; ..
  7279 FF:4ECE: 26 75        	ROL	<FACt_1		; ..
  7280 FF:4ED0: 26 78        	ROL	<TempB			; .. never overflows
  7281                        LAB_SQE2
  7282 FF:4ED2: 06 B6        	ASL	<FAC2_3		; shift highest bit of number ..
  7283 FF:4ED4: 26 B5        	ROL	<FAC2_2		; ..
  7284 FF:4ED6: 26 B4        	ROL	<FAC2_1		; ..
  7285 FF:4ED8: 26 77        	ROL	<FACt_3		; .. into remainder
  7286 FF:4EDA: 26 76        	ROL	<FACt_2		; ..
  7287 FF:4EDC: 26 75        	ROL	<FACt_1		; ..
  7288 FF:4EDE: 26 78        	ROL	<TempB			; .. never overflows
  7289                        
  7290 FF:4EE0: 06 AF        	ASL	<FAC1_3		; root = root * 2
  7291 FF:4EE2: 26 AE        	ROL	<FAC1_2		; ..
  7292 FF:4EE4: 26 AD        	ROL	<FAC1_1		; .. never overflows
  7293                        
  7294 FF:4EE6: A5 AF        	LDA	<FAC1_3		; get root low byte
  7295 FF:4EE8: 2A           	ROL	A		; *2
  7296 FF:4EE9: 85 5B        	STA	<Temp3			; save partial low byte
  7297 FF:4EEB: A5 AE        	LDA	<FAC1_2		; get root low mid byte
  7298 FF:4EED: 2A           	ROL	A			; *2
  7299 FF:4EEE: 85 5C        	STA	<Temp3+1		; save partial low mid byte
  7300 FF:4EF0: A5 AD        	LDA	<FAC1_1		; get root high mid byte
  7301 FF:4EF2: 2A           	ROL	A			; *2
  7302 FF:4EF3: 85 5D        	STA	<Temp3+2		; save partial high mid byte
  7303 FF:4EF5: A9 00        	LDA	#$00			; get root high byte (always $00)
  7304 FF:4EF7: 2A           	ROL	A			; *2
  7305 FF:4EF8: 85 5E        	STA	<Temp3+3		; save partial high byte
  Sun Nov 21 2021 15:13                                                                                                Page 230


  7306                        
  7307                        					; carry clear for subtract +1
  7308 FF:4EFA: A5 77        	LDA	<FACt_3		; get remainder low byte
  7309 FF:4EFC: E5 5B        	SBC	<Temp3			; subtract partial low byte
  7310 FF:4EFE: 85 5B        	STA	<Temp3			; save partial low byte
  7311                        
  7312 FF:4F00: A5 76        	LDA	<FACt_2		; get remainder low mid byte
  7313 FF:4F02: E5 5C        	SBC	<Temp3+1		; subtract partial low mid byte
  7314 FF:4F04: 85 5C        	STA	<Temp3+1		; save partial low mid byte
  7315                        
  7316 FF:4F06: A5 75        	LDA	<FACt_1		; get remainder high mid byte
  7317 FF:4F08: E5 5D        	SBC	<Temp3+2		; subtract partial high mid byte
  7318 FF:4F0A: A8           	TAY				; copy partial high mid byte
  7319                        
  7320 FF:4F0B: A5 78        	LDA	<TempB			; get remainder high byte
  7321 FF:4F0D: E5 5E        	SBC	<Temp3+3		; subtract partial high byte
  7322 FF:4F0F: 90 0E        	BCC	LAB_SQNS		; skip sub if remainder smaller
  7323                        
  7324 FF:4F11: 85 78        	STA	<TempB			; save remainder high byte
  7325                        
  7326 FF:4F13: 84 75        	STY	<FACt_1		; save remainder high mid byte
  7327                        
  7328 FF:4F15: A5 5C        	LDA	<Temp3+1		; get remainder low mid byte
  7329 FF:4F17: 85 76        	STA	<FACt_2		; save remainder low mid byte
  7330                        
  7331 FF:4F19: A5 5B        	LDA	<Temp3			; get partial low byte
  7332 FF:4F1B: 85 77        	STA	<FACt_3		; save remainder low byte
  7333                        
  7334 FF:4F1D: E6 AF        	INC	<FAC1_3		; increment root low byte (never any rollover)
  7335                        LAB_SQNS
  7336 FF:4F1F: CA           	DEX				; decrement bit pair count
  7337 FF:4F20: D0 A2        	BNE	LAB_SQE1		; loop if not all done
  7338                        LAB_SQNSA:
  7339 FF:4F22: 38           	SEC				; set carry for subtract
  7340 FF:4F23: A5 B3        	LDA	<FAC2_e		; get exponent
  7341 FF:4F25: E9 80        	SBC	#$80			; normalise
  7342 FF:4F27: 6A           	ROR	A			; /2 and re-bias to $80
  7343 FF:4F28: 69 00        	ADC	#$00			; add bit zero back in (allow for half shift)
  7344 FF:4F2A: 85 AC        	STA	<FAC1_e		; save it
  7345 FF:4F2C: 4C E3 42     	JMP	LAB_24D5		; normalise FAC1 and return
  7346                        
  7347                        ; perform VARPTR()
  7348                        
  7349                        LAB_VARPTR
  7350 FF:4F2F: 22 BC 00 00  	JSL	LAB_IGBY		; increment and scan memory
  7351 FF:4F33: 20 FF 36     	JSR	LAB_GVAR		; get var address
  7352 FF:4F36: 20 13 35     	JSR	LAB_1BFB		; scan for ")" , else do syntax error then warm start
  7353 FF:4F39: A4 95        	LDY	<Cvaral		; get var address low byte
  7354 FF:4F3B: A5 96        	LDA	<Cvarah		; get var address high byte
  7355 FF:4F3D: 4C BD 39     	JMP	LAB_AYFC		; save and convert integer AY to FAC1 and return
  7356                        
  7357                        ; perform PI
  7358                        
  7359                        LAB_PI
  7360 FF:4F40: A9 75        	LDA	#<LAB_2C7C		; set (2*pi) pointer low byte
  7361 FF:4F42: A0 18        	LDY	#>LAB_2C7C		; set (2*pi) pointer high byte
  7362 FF:4F44: 20 7C 45     	JSR	LAB_UFAC		; unpack memory (AY) into FAC1
  Sun Nov 21 2021 15:13                                                                                                Page 231


  7363 FF:4F47: C6 AC        	DEC	<FAC1_e		; make result = PI
  7364 FF:4F49: 60           	RTS
  7365                        
  7366                        
  7367                        
  7368                        
  7369                        
  7370                        AA_end_basic
  7371 FF:4F4A: 44 45 52 49  ENDOFBASIC	.DB	"DERIVED FROM ehBASIC"
       FF:4F4E: 56 45 44 20 
       FF:4F52: 46 52 4F 4D 
       FF:4F56: 20 65 68 42 
       FF:4F5A: 41 53 49 43 
  7372                        
  7373                        
  7374                        
  7375                        
  7376                        		 .END


      Lines assembled: 12938
      Errors: 0
